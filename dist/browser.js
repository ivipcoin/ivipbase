(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ivipbase = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deleteApp = exports.getFirstApp = exports.getAppsName = exports.getApps = exports.getApp = exports.appExists = exports.initializeApp = exports.IvipBaseApp = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var internal_1 = require("./internal");
var erros_1 = require("../controller/erros");
var server_1 = require("../server");
var verifyStorage_1 = require("./verifyStorage");
var settings_1 = require("./settings");
var database_1 = require("../database");
var request_1 = __importDefault(require("../controller/request"));
var socket_io_client_1 = require("socket.io-client");
var utils_1 = require("../utils");
var error_1 = require("../controller/request/error");
var ipc_1 = require("../ipc");
var storage_1 = require("../storage");
var CONNECTION_STATE_DISCONNECTED = "disconnected";
var CONNECTION_STATE_CONNECTING = "connecting";
var CONNECTION_STATE_CONNECTED = "connected";
var CONNECTION_STATE_DISCONNECTING = "disconnecting";
var IvipBaseApp = /*#__PURE__*/function (_ivipbase_core_1$Simp) {
  function IvipBaseApp(options) {
    var _this;
    _classCallCheck(this, IvipBaseApp);
    _this = _callSuper(this, IvipBaseApp);
    _this._ready = false;
    _this.id = ivipbase_core_1.ID.generate();
    _this.name = internal_1.DEFAULT_ENTRY_NAME;
    _this.isDeleted = false;
    _this.databases = new Map();
    _this.auth = new Map();
    _this.storageFile = new Map();
    _this._socket = null;
    _this._ipc = undefined;
    _this._connectionState = CONNECTION_STATE_DISCONNECTED;
    if (typeof options.name === "string") {
      _this.name = options.name;
    }
    _this.settings = options.settings instanceof settings_1.IvipBaseSettings ? options.settings : new settings_1.IvipBaseSettings();
    if (typeof options.isDeleted === "boolean") {
      _this.isDeleted = options.isDeleted;
    }
    _this.storage = (0, verifyStorage_1.applySettings)(_this);
    _this.isServer = _typeof(_this.settings.server) === "object" && _this.settings.server !== null && _this.settings.isServer;
    if (_this.settings.isPossiplyServer) {
      _this._ipc = (0, ipc_1.getIPCPeer)(_this.name);
    }
    _this.on("ready", function (data) {
      _this._ready = true;
    });
    return _this;
  }
  _inherits(IvipBaseApp, _ivipbase_core_1$Simp);
  return _createClass(IvipBaseApp, [{
    key: "on",
    value: function on(event, callback) {
      return _get(_getPrototypeOf(IvipBaseApp.prototype), "on", this).call(this, event, callback);
    }
  }, {
    key: "emit",
    value: function emit(event, data) {
      _get(_getPrototypeOf(IvipBaseApp.prototype), "emit", this).call(this, event, data);
      return this;
    }
  }, {
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _this2 = this;
        var _a, id, dbList, _iterator, _step, dbName, db;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this._ready) {
                _context.next = 33;
                break;
              }
              id = this.id;
              if (!(this.settings.bootable && !this.isServer && (typeof this.settings.database === "string" || Array.isArray(this.settings.database) && this.settings.database.length > 0))) {
                _context.next = 5;
                break;
              }
              _context.next = 5;
              return new Promise(function (resolve) {
                if (_this2._socket) {
                  _this2.disconnect();
                  _this2._socket = null;
                }
                var fn = function fn() {
                  return resolve();
                };
                _this2.once("connect", fn);
                _this2.on("reset", function () {
                  _this2.off("connect", fn);
                  resolve();
                });
                _this2.on("destroyed", function () {
                  _this2.off("connect", fn);
                  resolve();
                });
                _this2.connect();
              });
            case 5:
              if (!(this.settings.bootable && this.id === id)) {
                _context.next = 32;
                break;
              }
              dbList = Array.isArray(this.settings.dbname) ? this.settings.dbname : [this.settings.dbname];
              _context.next = 9;
              return this.storage.ready();
            case 9:
              if (!this.isServer) {
                _context.next = 13;
                break;
              }
              if (!this.server) {
                this.server = new server_1.LocalServer(this, this.settings.server);
              }
              _context.next = 13;
              return this.server.ready();
            case 13:
              _iterator = _createForOfIteratorHelper(dbList);
              _context.prev = 14;
              _iterator.s();
            case 16:
              if ((_step = _iterator.n()).done) {
                _context.next = 24;
                break;
              }
              dbName = _step.value;
              db = (_a = this.databases.get(dbName)) !== null && _a !== void 0 ? _a : new database_1.DataBase(dbName, this);
              _context.next = 21;
              return db.ready();
            case 21:
              if (!this.databases.has(dbName)) {
                this.databases.set(dbName, db);
                this.storageFile.set(dbName, new storage_1.Storage(this, db));
              }
            case 22:
              _context.next = 16;
              break;
            case 24:
              _context.next = 29;
              break;
            case 26:
              _context.prev = 26;
              _context.t0 = _context["catch"](14);
              _iterator.e(_context.t0);
            case 29:
              _context.prev = 29;
              _iterator.f();
              return _context.finish(29);
            case 32:
              if (this.id === id) {
                this.emit("ready");
              }
            case 33:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[14, 26, 29, 32]]);
      }));
      function initialize() {
        return _initialize.apply(this, arguments);
      }
      return initialize;
    }()
    /**
     * Aguarda o serviço estar pronto antes de executar o seu callback.
     * @param callback (opcional) função de retorno chamada quando o serviço estiver pronto para ser usado. Você também pode usar a promise retornada.
     * @returns retorna uma promise que resolve quando estiver pronto
     */
  }, {
    key: "ready",
    value: (function () {
      var _ready = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(callback) {
        var _this3 = this;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (this._ready) {
                _context2.next = 3;
                break;
              }
              _context2.next = 3;
              return new Promise(function (resolve) {
                return _this3.once("ready", resolve);
              });
            case 3:
              callback === null || callback === void 0 ? void 0 : callback();
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function ready(_x) {
        return _ready.apply(this, arguments);
      }
      return ready;
    }())
  }, {
    key: "isConnected",
    get: function get() {
      return this.isServer || this._connectionState === CONNECTION_STATE_CONNECTED;
    }
  }, {
    key: "isConnecting",
    get: function get() {
      return !this.isServer && this._connectionState === CONNECTION_STATE_CONNECTING;
    }
  }, {
    key: "connectionState",
    get: function get() {
      return this.isServer ? CONNECTION_STATE_CONNECTED : this._connectionState;
    }
  }, {
    key: "socket",
    get: function get() {
      return this._socket;
    }
  }, {
    key: "ipc",
    get: function get() {
      var _this4 = this;
      if (!this.settings.isPossiplyServer) {
        return;
      }
      if (this._ipc instanceof ipc_1.IPCPeer === false) {
        this._ipc = (0, ipc_1.getIPCPeer)(this.name);
      }
      this._ipc.on("connect", function () {
        _this4.emit("connectIPC", _this4._ipc);
      });
      return this._ipc;
    }
  }, {
    key: "ipcReady",
    value: function () {
      var _ipcReady = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(callback) {
        var _this5 = this;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (!(!this._ipc && this.settings.isPossiplyServer)) {
                _context3.next = 3;
                break;
              }
              _context3.next = 3;
              return new Promise(function (resolve) {
                return _this5.once("connectIPC", resolve);
              });
            case 3:
              if (this._ipc instanceof ipc_1.IPCPeer) {
                callback === null || callback === void 0 ? void 0 : callback(this._ipc);
              }
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function ipcReady(_x2) {
        return _ipcReady.apply(this, arguments);
      }
      return ipcReady;
    }()
  }, {
    key: "onConnect",
    value: function () {
      var _onConnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(callback) {
        var _this6 = this;
        var isOnce,
          count,
          isReset,
          event,
          _args4 = arguments;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              isOnce = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : false;
              count = 0, isReset = false;
              event = function event() {
                if (isReset) {
                  return;
                }
                if (_this6.isConnected) {
                  count++;
                  if (count > 1 && isOnce) {
                    return;
                  }
                  callback(_this6.socket);
                  if (isOnce) {
                    _this6.off("connect", event);
                  }
                  return;
                }
              };
              if (!this.isServer && (typeof this.settings.database === "string" || Array.isArray(this.settings.database) && this.settings.database.length > 0)) {
                this.on("connect", event);
              }
              event();
              this.on("reset", function () {
                isReset = true;
                _this6.off("connect", event);
              });
              this.on("destroyed", function () {
                isReset = true;
                _this6.off("connect", event);
              });
              return _context4.abrupt("return", {
                stop: function stop() {
                  _this6.off("connect", event);
                }
              });
            case 8:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function onConnect(_x3) {
        return _onConnect.apply(this, arguments);
      }
      return onConnect;
    }()
  }, {
    key: "isReady",
    get: function get() {
      return this._ready;
    }
  }, {
    key: "url",
    get: function get() {
      var _a;
      return "".concat(this.settings.protocol, "://").concat((_a = this.settings.host) !== null && _a !== void 0 ? _a : "localhost").concat(typeof this.settings.port === "number" ? ":".concat(this.settings.port) : "");
    }
  }, {
    key: "request",
    value: function () {
      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(options) {
        var url;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              url = "".concat(this.url, "/").concat(options.route.replace(/^\/+/, ""));
              return _context7.abrupt("return", new Promise( /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(resolve, reject) {
                  var result;
                  return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                    while (1) switch (_context6.prev = _context6.next) {
                      case 0:
                        _context6.prev = 0;
                        _context6.next = 3;
                        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
                          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                            while (1) switch (_context5.prev = _context5.next) {
                              case 0:
                                _context5.prev = 0;
                                _context5.next = 3;
                                return (0, request_1["default"])(options.method || "GET", url, {
                                  data: options.data,
                                  accessToken: options.accessToken,
                                  dataReceivedCallback: options.dataReceivedCallback,
                                  dataRequestCallback: options.dataRequestCallback,
                                  context: options.context
                                });
                              case 3:
                                return _context5.abrupt("return", _context5.sent);
                              case 6:
                                _context5.prev = 6;
                                _context5.t0 = _context5["catch"](0);
                                throw _context5.t0;
                              case 9:
                              case "end":
                                return _context5.stop();
                            }
                          }, _callee5, null, [[0, 6]]);
                        }))();
                      case 3:
                        result = _context6.sent;
                        if (!(options.includeContext === true)) {
                          _context6.next = 9;
                          break;
                        }
                        if (!result.context) {
                          result.context = {};
                        }
                        return _context6.abrupt("return", resolve(result));
                      case 9:
                        return _context6.abrupt("return", resolve(result.data));
                      case 10:
                        _context6.next = 15;
                        break;
                      case 12:
                        _context6.prev = 12;
                        _context6.t0 = _context6["catch"](0);
                        reject(_context6.t0);
                      case 15:
                      case "end":
                        return _context6.stop();
                    }
                  }, _callee6, null, [[0, 12]]);
                }));
                return function (_x5, _x6) {
                  return _ref.apply(this, arguments);
                };
              }()));
            case 2:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function request(_x4) {
        return _request.apply(this, arguments);
      }
      return request;
    }()
  }, {
    key: "websocketRequest",
    value: function websocketRequest(socket, event, data, dbName) {
      var _a, _b;
      if (!socket) {
        throw new Error("Cannot send request because websocket connection is not open");
      }
      var requestId = ivipbase_core_1.ID.generate();
      var accessToken = (_b = (_a = this.auth.get(dbName)) === null || _a === void 0 ? void 0 : _a.currentUser) === null || _b === void 0 ? void 0 : _b.accessToken;
      // const request = data;
      // request.req_id = requestId;
      // request.access_token = accessToken;
      var request = Object.assign(Object.assign({}, data), {
        req_id: requestId,
        access_token: accessToken,
        dbName: dbName
      });
      return new Promise(function (resolve, reject) {
        var checkConnection = function checkConnection() {
          if (!(socket === null || socket === void 0 ? void 0 : socket.connected)) {
            return reject(new error_1.RequestError(request, null, "websocket", "No open websocket connection"));
          }
        };
        checkConnection();
        var timeout;
        var send = function send() {
          var retry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
          checkConnection();
          socket.emit(event, request);
          timeout = setTimeout(function () {
            if (retry < 2) {
              return send(retry + 1);
            }
            socket.off("result", handle);
            var err = new error_1.RequestError(request, null, "timeout", "Server did not respond to \"".concat(event, "\" request after ").concat(retry + 1, " tries"));
            reject(err);
          }, 1000);
        };
        var handle = function handle(response) {
          if (response.req_id === requestId) {
            clearTimeout(timeout);
            socket.off("result", handle);
            if (response.success) {
              return resolve(response);
            }
            // Access denied?
            var code = _typeof(response.reason) === "object" ? response.reason.code : response.reason;
            var message = _typeof(response.reason) === "object" ? response.reason.message : "request failed: ".concat(code);
            var err = new error_1.RequestError(request, response, code, message);
            reject(err);
          }
        };
        socket.on("result", handle);
        send();
      });
    }
  }, {
    key: "projects",
    value: function () {
      var _projects = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              return _context8.abrupt("return", this.request({
                route: "projects"
              }));
            case 1:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function projects() {
        return _projects.apply(this, arguments);
      }
      return projects;
    }()
  }, {
    key: "connect",
    value: function () {
      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var _this7 = this;
        var dbNames;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              if (!(this._connectionState === CONNECTION_STATE_DISCONNECTED)) {
                _context9.next = 10;
                break;
              }
              this._connectionState = CONNECTION_STATE_CONNECTING;
              dbNames = Array.isArray(this.settings.dbname) ? this.settings.dbname : [this.settings.dbname];
              this._socket = (0, socket_io_client_1.connect)(this.url.replace(/^http(s?)/gi, "ws$1"), {
                // Use default socket.io connection settings:
                path: "/socket.io",
                autoConnect: true,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                timeout: 20000,
                randomizationFactor: 0.5,
                transports: ["websocket"],
                // Override default setting of ['polling', 'websocket']
                query: {
                  dbNames: JSON.stringify(dbNames),
                  id: this.id
                }
              });
              this._socket.on("connect", function () {
                _this7._connectionState = CONNECTION_STATE_CONNECTED;
                _this7.emit("connect");
              });
              this._socket.on("disconnect", function () {
                _this7._connectionState = CONNECTION_STATE_DISCONNECTED;
                _this7.emit("disconnect");
              });
              this._socket.on("reconnecting", function () {
                _this7._connectionState = CONNECTION_STATE_CONNECTING;
                _this7.emit("reconnecting");
              });
              this._socket.on("reconnect", function () {
                _this7._connectionState = CONNECTION_STATE_CONNECTED;
                _this7.emit("reconnect");
              });
              this._socket.on("reconnect_failed", function () {
                _this7._connectionState = CONNECTION_STATE_DISCONNECTED;
                _this7.emit("reconnect_failed");
              });
              return _context9.abrupt("return");
            case 10:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function connect() {
        return _connect.apply(this, arguments);
      }
      return connect;
    }()
  }, {
    key: "disconnect",
    value: function () {
      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        var _a;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              if (this._connectionState === CONNECTION_STATE_CONNECTED) {
                this._connectionState = CONNECTION_STATE_DISCONNECTING;
                (_a = this._socket) === null || _a === void 0 ? void 0 : _a.disconnect();
              }
            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function disconnect() {
        return _disconnect.apply(this, arguments);
      }
      return disconnect;
    }()
  }, {
    key: "reconnect",
    value: function () {
      var _reconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              if (this._connectionState === CONNECTION_STATE_DISCONNECTED) {
                this.connect();
              }
            case 1:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function reconnect() {
        return _reconnect.apply(this, arguments);
      }
      return reconnect;
    }()
  }, {
    key: "destroy",
    value: function () {
      var _destroy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              this.disconnect();
              this._socket = null;
            case 2:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function destroy() {
        return _destroy.apply(this, arguments);
      }
      return destroy;
    }()
  }, {
    key: "reset",
    value: function () {
      var _reset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(options) {
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              this._ready = false;
              this.emit("destroyed");
              this.id = ivipbase_core_1.ID.generate();
              _context13.next = 5;
              return this.destroy();
            case 5:
              this._connectionState = CONNECTION_STATE_DISCONNECTED;
              this._socket = null;
              this.isDeleted = false;
              this.settings = new settings_1.IvipBaseSettings((0, utils_1.joinObjects)(this.settings.options, options));
              this.storage = (0, verifyStorage_1.applySettings)(this);
              this.isServer = _typeof(this.settings.server) === "object";
              // this.auth.clear();
              this.databases.clear();
              this.storageFile.clear();
              this.emit("reset");
              _context13.next = 16;
              return this.initialize();
            case 16:
              _context13.next = 18;
              return this.ready();
            case 18:
              return _context13.abrupt("return", this);
            case 19:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function reset(_x7) {
        return _reset.apply(this, arguments);
      }
      return reset;
    }()
  }]);
}(ivipbase_core_1.SimpleEventEmitter);
exports.IvipBaseApp = IvipBaseApp;
function initializeApp(options) {
  var settings = new settings_1.IvipBaseSettings(options);
  var newApp = new IvipBaseApp({
    name: settings.name,
    settings: settings
  });
  var existingApp = internal_1._apps.get(newApp.name);
  if (existingApp) {
    if (ivipbase_core_1.Utils.deepEqual(newApp.settings, existingApp.settings)) {
      return existingApp;
    } else {
      throw erros_1.ERROR_FACTORY.create("duplicate-app" /* AppError.DUPLICATE_APP */, {
        appName: newApp.name
      });
    }
  }
  internal_1._apps.set(newApp.name, newApp);
  newApp.initialize();
  return newApp;
}
exports.initializeApp = initializeApp;
function appExists(name) {
  return typeof name === "string" && internal_1._apps.has(name);
}
exports.appExists = appExists;
function getApp() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : internal_1.DEFAULT_ENTRY_NAME;
  var app = internal_1._apps.get(name);
  if (!app) {
    throw erros_1.ERROR_FACTORY.create("no-app" /* AppError.NO_APP */, {
      appName: name
    });
  }
  return app;
}
exports.getApp = getApp;
function getApps() {
  return Array.from(internal_1._apps.values());
}
exports.getApps = getApps;
function getAppsName() {
  return Array.from(internal_1._apps.keys());
}
exports.getAppsName = getAppsName;
function getFirstApp() {
  var app;
  if (internal_1._apps.has(internal_1.DEFAULT_ENTRY_NAME)) {
    app = internal_1._apps.get(internal_1.DEFAULT_ENTRY_NAME);
  }
  app = !app ? getApps()[0] : app;
  if (!app) {
    throw erros_1.ERROR_FACTORY.create("no-app" /* AppError.NO_APP */, {
      appName: internal_1.DEFAULT_ENTRY_NAME
    });
  }
  return app;
}
exports.getFirstApp = getFirstApp;
function deleteApp(app) {
  var name = app.name;
  if (internal_1._apps.has(name)) {
    internal_1._apps["delete"](name);
    app.isDeleted = true;
  }
}
exports.deleteApp = deleteApp;

},{"../controller/erros":7,"../controller/request":11,"../controller/request/error":10,"../database":23,"../ipc":27,"../server":30,"../storage":32,"../utils":37,"./internal":2,"./settings":3,"./verifyStorage":4,"ivipbase-core":152,"socket.io-client":157}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._apps = exports.DEFAULT_ENTRY_NAME = void 0;
exports.DEFAULT_ENTRY_NAME = "[DEFAULT]";
/**
 * @internal
 */
exports._apps = new Map();

},{}],3:[function(require,module,exports){
"use strict";

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IvipBaseSettings = exports.ServerEmailSettings = void 0;
var internal_1 = require("../internal");
var verifyStorage_1 = require("../verifyStorage");
var NotImplementedError = /*#__PURE__*/function (_Error) {
  function NotImplementedError(name) {
    _classCallCheck(this, NotImplementedError);
    return _callSuper(this, NotImplementedError, ["".concat(name, " is not implemented")]);
  }
  _inherits(NotImplementedError, _Error);
  return _createClass(NotImplementedError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var ServerEmailSettings = /*#__PURE__*/function () {
  function ServerEmailSettings(options) {
    _classCallCheck(this, ServerEmailSettings);
    this.prepareModel = function () {
      return {
        title: "",
        subject: "",
        message: ""
      };
    };
    this.server = options.server;
  }
  /** Função a ser chamada quando um e-mail precisa ser enviado */
  return _createClass(ServerEmailSettings, [{
    key: "send",
    value: function send(request) {
      throw new NotImplementedError("ServerEmail");
    }
  }]);
}();
exports.ServerEmailSettings = ServerEmailSettings;
var hostnameRegex = /^((https?):\/\/)?(localhost|([\da-z\.-]+\.[a-z\.]{2,6}|[\d\.]+))(\:{1}(\d+))?$/;
var IvipBaseSettings = /*#__PURE__*/function () {
  function IvipBaseSettings() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, IvipBaseSettings);
    this.options = options;
    this.name = internal_1.DEFAULT_ENTRY_NAME;
    this.dbname = "root";
    this.database = {
      name: "root",
      description: "iVipBase database"
    };
    this.description = "";
    this.logLevel = "log";
    this.protocol = "http";
    this.host = "localhost";
    this.isServer = false;
    this.isValidClient = true;
    this.isConnectionDefined = false;
    this.bootable = true;
    this.defaultRules = {
      rules: {}
    };
    this.reset(options);
  }
  return _createClass(IvipBaseSettings, [{
    key: "isPossiplyServer",
    get: function get() {
      return false;
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this = this;
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _a, _b, _c, _d;
      if (typeof options.name === "string") {
        this.name = options.name;
      }
      if (typeof options.dbname === "string" || Array.isArray(options.dbname)) {
        this.dbname = (Array.isArray(options.dbname) ? options.dbname : [options.dbname]).filter(function (n) {
          return typeof n === "string" && n.trim() !== "";
        });
        this.dbname = this.dbname.length > 0 ? this.dbname : "root";
      }
      if (Array.isArray(options.database) || _typeof(options.database) === "object") {
        this.database = (Array.isArray(options.database) ? options.database : [options.database]).filter(function (o) {
          return _typeof(o) === "object" && typeof o.name === "string" && o.name.trim() !== "";
        });
        this.dbname = Array.isArray(this.dbname) ? this.dbname : typeof this.dbname === "string" ? [this.dbname] : [];
        this.dbname = this.dbname.concat(this.database.map(function (_ref) {
          var name = _ref.name;
          return name;
        }));
        this.dbname = this.dbname.length > 0 ? this.dbname : "root";
      }
      var databases = Array.isArray(this.dbname) ? this.dbname : [this.dbname];
      this.database = Array.isArray(this.database) ? this.database : [this.database];
      databases.forEach(function (name) {
        var index = _this.database.findIndex(function (db) {
          return db.name === name;
        });
        if (index === -1) {
          _this.database.push({
            name: name,
            description: "IvipBase database"
          });
        }
      });
      this.description = (_a = options.description) !== null && _a !== void 0 ? _a : "IvipBase database";
      if (typeof options.logLevel === "string" && ["log", "warn", "error"].includes(options.logLevel)) {
        this.logLevel = options.logLevel;
      }
      if ((0, verifyStorage_1.validSettings)(options.storage)) {
        this.storage = options.storage;
      }
      var _ref2 = (_b = (typeof options.host === "string" ? options.host : "").match(hostnameRegex)) !== null && _b !== void 0 ? _b : [],
        _ref3 = _slicedToArray(_ref2, 7),
        _ = _ref3[0],
        _protocol = _ref3[1],
        protocol = _ref3[2],
        host = _ref3[3],
        _host = _ref3[4],
        _port = _ref3[5],
        port = _ref3[6];
      this.isConnectionDefined = !!host;
      this.protocol = ["https", "http"].includes(protocol) ? protocol : options.protocol === "https" ? "https" : "http";
      this.host = host !== null && host !== void 0 ? host : "localhost";
      this.port = port ? parseInt(port) : options.port;
      this.bootable = (_c = options.bootable) !== null && _c !== void 0 ? _c : true;
      this.defaultRules = (_d = options.defaultRules) !== null && _d !== void 0 ? _d : {
        rules: {}
      };
    }
  }]);
}();
exports.IvipBaseSettings = IvipBaseSettings;

},{"../internal":2,"../verifyStorage":4}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataStorageSettings = exports.DataStorage = exports.CustomStorage = exports.applySettings = exports.validSettings = void 0;
var storage_1 = require("../../controller/storage");
Object.defineProperty(exports, "CustomStorage", {
  enumerable: true,
  get: function get() {
    return storage_1.CustomStorage;
  }
});
Object.defineProperty(exports, "DataStorage", {
  enumerable: true,
  get: function get() {
    return storage_1.DataStorage;
  }
});
Object.defineProperty(exports, "DataStorageSettings", {
  enumerable: true,
  get: function get() {
    return storage_1.DataStorageSettings;
  }
});
function validSettings(options) {
  return options instanceof storage_1.DataStorageSettings || options instanceof storage_1.CustomStorage;
}
exports.validSettings = validSettings;
function applySettings(app) {
  var dbname = app.settings.dbname;
  var options = app.settings.storage;
  if (options instanceof storage_1.DataStorageSettings) {
    return new storage_1.DataStorage(dbname, options, app);
  } else if (options instanceof storage_1.CustomStorage) {
    return options;
  }
  return new storage_1.DataStorage(dbname, options, app);
}
exports.applySettings = applySettings;

},{"../../controller/storage":19}],5:[function(require,module,exports){
"use strict";

function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAuth = exports.Auth = exports.AuthUser = void 0;
var app_1 = require("../app");
var database_1 = require("../database");
var ivipbase_core_1 = require("ivipbase-core");
var localStorage_1 = __importDefault(require("../utils/localStorage"));
var utils_1 = require("../utils");
var base64_1 = __importDefault(require("../utils/base64"));
var AUTH_USER_LOGIN_ERROR_MESSAGE = "auth/login-failed";
var AuthUser = /*#__PURE__*/function () {
  function AuthUser(auth, user) {
    var access_token = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    _classCallCheck(this, AuthUser);
    var _a, _b, _c;
    this.auth = auth;
    /**
     * Whether the user's email address has been verified
     */
    this.emailVerified = false;
    /**
     * Whether the user has to change their password
     */
    this.changePassword = false;
    this._lastAccessTokenRefresh = 0;
    Object.assign(this, user);
    if (!user.uid) {
      throw new Error("User details is missing required uid field");
    }
    this.uid = user.uid;
    this.displayName = (_a = user.displayName) !== null && _a !== void 0 ? _a : "unknown";
    this.created = (_b = user.created) !== null && _b !== void 0 ? _b : new Date(0).toISOString();
    this.settings = (_c = user.settings) !== null && _c !== void 0 ? _c : {};
    this._accessToken = access_token;
    this._lastAccessTokenRefresh = 0;
  }
  return _createClass(AuthUser, [{
    key: "accessToken",
    get: function get() {
      return this._accessToken;
    }
  }, {
    key: "providerData",
    get: function get() {
      return [];
    }
    /**
     * Atualiza os dados do perfil de um usuário.
     * @param profile O displayName e o photoURL do perfil para atualizar.
     * @returns Uma promise que é resolvida quando a atualização for concluída.
     * @throws auth/invalid-display-name Lançado se o nome de exibição for inválido.
     * @throws auth/invalid-photo-url Lançado se a URL da foto for inválida.
     */
  }, {
    key: "updateProfile",
    value: (function () {
      var _updateProfile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(profile) {
        var _a, result;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.auth.app.request({
                method: "POST",
                route: "/auth/".concat(this.auth.database, "/update"),
                data: profile
              });
            case 2:
              result = _context.sent;
              Object.assign(this, (_a = result.user) !== null && _a !== void 0 ? _a : {});
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function updateProfile(_x) {
        return _updateProfile.apply(this, arguments);
      }
      return updateProfile;
    }()
    /**
     * Atualiza o endereço de e-mail do usuário.
     * @param email O novo endereço de e-mail do usuário.
     * @returns Uma promise que é resolvida se o novo e-mail for válido e atualizado com sucesso no banco de dados do usuário.
     * @throws auth/email-already-in-use Lançado se o e-mail já estiver em uso por outro usuário.
     * @throws auth/invalid-email Lançado se o e-mail não for válido.
     * @throws auth/requires-recent-login Lançado se o último tempo de login do usuário não atender ao limite de segurança. Use reauthenticateWithCredential para resolver. Isso não se aplica se o usuário for anônimo.
     */
    )
  }, {
    key: "updateEmail",
    value: (function () {
      var _updateEmail = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(email) {
        var _a, result;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.auth.app.request({
                method: "POST",
                route: "/auth/".concat(this.auth.database, "/update"),
                data: {
                  email: email
                }
              });
            case 2:
              result = _context2.sent;
              Object.assign(this, (_a = result.user) !== null && _a !== void 0 ? _a : {});
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function updateEmail(_x2) {
        return _updateEmail.apply(this, arguments);
      }
      return updateEmail;
    }()
    /**
     * Atualiza o nome de usuário do usuário.
     * @param username O novo nome de usuário do usuário.
     * @returns Uma promise que é resolvida se o novo nome de usuário for válido e atualizado com sucesso no banco de dados do usuário.
     * @throws auth/username-already-in-use Lançado se o nome de usuário já estiver em uso por outro usuário.
     * @throws auth/invalid-username Lançado se o nome de usuário não for válido.
     * @throws auth/requires-recent-login Lançado se o último tempo de login do usuário não atender ao limite de segurança. Use reauthenticateWithCredential para resolver. Isso não se aplica se o usuário for anônimo.
     */
    )
  }, {
    key: "updateUsername",
    value: (function () {
      var _updateUsername = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(username) {
        var _a, result;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.auth.app.request({
                method: "POST",
                route: "/auth/".concat(this.auth.database, "/update"),
                data: {
                  username: username
                }
              });
            case 2:
              result = _context3.sent;
              Object.assign(this, (_a = result.user) !== null && _a !== void 0 ? _a : {});
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function updateUsername(_x3) {
        return _updateUsername.apply(this, arguments);
      }
      return updateUsername;
    }()
    /**
     * Atualiza a senha do usuário.
     * @param currentPassword A senha atual do usuário.
     * @param newPassword A nova senha do usuário.
     * @returns Uma promise que é resolvida se a nova senha for válida e atualizada com sucesso no banco de dados do usuário.
     * @throws auth/weak-password Lançado se a senha não for forte o suficiente.
     * @throws auth/requires-recent-login Lançado se o último tempo de login do usuário não atender ao limite de segurança. Use reauthenticateWithCredential para resolver. Isso não se aplica se o usuário for anônimo.
     */
    )
  }, {
    key: "updatePassword",
    value: (function () {
      var _updatePassword = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(currentPassword, newPassword) {
        var result;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (this.accessToken) {
                _context4.next = 2;
                break;
              }
              throw new Error("auth/requires-recent-login");
            case 2:
              _context4.next = 4;
              return this.auth.app.request({
                method: "POST",
                route: "/auth/".concat(this.auth.database, "/change_password"),
                data: {
                  uid: this.uid,
                  password: currentPassword,
                  new_password: newPassword
                }
              });
            case 4:
              result = _context4.sent;
              this._accessToken = result.access_token;
              this._lastAccessTokenRefresh = Date.now();
              this.auth.emit("signin", this);
            case 8:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function updatePassword(_x4, _x5) {
        return _updatePassword.apply(this, arguments);
      }
      return updatePassword;
    }()
    /**
     * Envia um e-mail de verificação para um usuário.
     * @returns Uma promise que é resolvida quando o e-mail for enviado.
     * @throws auth/missing-android-pkg-name Lançado se o nome do pacote Android estiver ausente quando o aplicativo Android for necessário.
     * @throws auth/missing-continue-uri Lançado se a URL de continuação estiver ausente quando o widget da web for necessário.
     * @throws auth/missing-ios-bundle-id Lançado se o ID do pacote iOS estiver ausente quando o aplicativo iOS for necessário.
     * @throws auth/invalid-continue-uri Lançado se a URL de continuação for inválida.
     * @throws auth/unauthorized-continue-uri Lançado se o domínio da URL de continuação não estiver na lista de permissões. Coloque o domínio na lista de permissões no console do Firebase.
     */
    )
  }, {
    key: "sendEmailVerification",
    value: (function () {
      var _sendEmailVerification = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var result;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (this.accessToken) {
                _context5.next = 2;
                break;
              }
              throw new Error("auth/requires-recent-login");
            case 2:
              _context5.next = 4;
              return this.auth.app.request({
                method: "POST",
                route: "/auth/".concat(this.auth.database, "/send_email_verification"),
                data: {
                  username: this.username,
                  email: this.email
                }
              });
            case 4:
              result = _context5.sent;
            case 5:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function sendEmailVerification() {
        return _sendEmailVerification.apply(this, arguments);
      }
      return sendEmailVerification;
    }()
    /**
     * Exclui a conta do usuário (também desconecta o usuário)
     * @returns Uma promise que é resolvida quando a conta do usuário for excluída
     * @throws auth/requires-recent-login Lançado se o último tempo de login do usuário não atender ao limite de segurança. Use reauthenticateWithCredential para resolver. Isso não se aplica se o usuário for anônimo.
     */
    )
  }, {
    key: "delete",
    value: (function () {
      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var result, access_token;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.auth.app.request({
                method: "POST",
                route: "/auth/".concat(this.auth.database, "/delete"),
                data: {
                  uid: this.uid
                }
              });
            case 2:
              result = _context6.sent;
              if (result) {
                access_token = this._accessToken;
                this._accessToken = undefined;
                this._lastAccessTokenRefresh = 0;
                this.auth.emit("signout", access_token);
              }
            case 4:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function _delete() {
        return _delete2.apply(this, arguments);
      }
      return _delete;
    }()
    /**
     * Retorna um JSON Web Token (JWT) usado para identificar o usuário a um serviço Firebase.
     * @param forceRefresh Indica se deve ou não forçar a atualização do token
     * @returns Uma promise que é resolvida com o token atual se não tiver expirado. Caso contrário, será null.
     */
    )
  }, {
    key: "getIdToken",
    value: (function () {
      var _getIdToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(forceRefresh) {
        var _a, _b, now, result, access_token;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              now = Date.now();
              forceRefresh = forceRefresh || now - this._lastAccessTokenRefresh > 1000 * 60 * 15; // 15 minutes
              if (!(this._accessToken && forceRefresh)) {
                _context7.next = 20;
                break;
              }
              this._lastAccessTokenRefresh = Date.now();
              _context7.prev = 4;
              _context7.next = 7;
              return this.auth.app.request({
                method: "POST",
                route: "/auth/".concat(this.auth.database, "/signin"),
                data: {
                  method: "token",
                  access_token: this._accessToken,
                  client_id: this.auth.app.socket && this.auth.app.socket.id
                }
              });
            case 7:
              result = _context7.sent;
              Object.assign(this, (_a = result.user) !== null && _a !== void 0 ? _a : {});
              this._accessToken = result.access_token;
              this.auth.emit("signin", this);
              _context7.next = 20;
              break;
            case 13:
              _context7.prev = 13;
              _context7.t0 = _context7["catch"](4);
              this._lastAccessTokenRefresh = 0;
              access_token = this._accessToken;
              this._accessToken = undefined;
              this.auth.emit("signout", access_token);
              throw new Error(AUTH_USER_LOGIN_ERROR_MESSAGE);
            case 20:
              return _context7.abrupt("return", Promise.resolve((_b = this._accessToken) !== null && _b !== void 0 ? _b : ""));
            case 21:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[4, 13]]);
      }));
      function getIdToken(_x6) {
        return _getIdToken.apply(this, arguments);
      }
      return getIdToken;
    }()
    /**
     * Retorna um JSON Web Token (JWT) desserializado usado para identificar o usuário a um serviço Firebase.
     * @param forceRefresh Indica se deve ou não forçar a atualização do token
     * @returns Uma promise que é resolvida com o token atual se não tiver expirado. Caso contrário, será null.
     */
    )
  }, {
    key: "getIdTokenResult",
    value: function getIdTokenResult(forceRefresh) {
      throw new Error("Method not implemented.");
    }
    /**
     * Atualiza o usuário atual, se estiver conectado.
     * @returns Uma promise que é resolvida com o usuário atual após uma possível atualização do token.
     */
  }, {
    key: "reload",
    value: (function () {
      var _reload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var forceRefresh,
          _args8 = arguments;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              forceRefresh = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : true;
              if (this._accessToken) {
                _context8.next = 3;
                break;
              }
              throw new Error(AUTH_USER_LOGIN_ERROR_MESSAGE);
            case 3:
              _context8.next = 5;
              return this.getIdToken(forceRefresh);
            case 5:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function reload() {
        return _reload.apply(this, arguments);
      }
      return reload;
    }()
    /**
     * Retorna uma representação JSON serializável deste objeto.
     * @returns Uma representação JSON serializável deste objeto.
     */
    )
  }, {
    key: "toJSON",
    value: function toJSON() {
      var _a;
      return {
        uid: this.uid,
        username: this.username,
        email: this.email,
        displayName: this.displayName,
        photoURL: this.photoURL,
        emailVerified: this.emailVerified,
        created: this.created,
        prevSignin: this.prevSignin,
        prevSigninIp: this.prevSigninIp,
        lastSignin: this.lastSignin,
        lastSigninIp: this.lastSigninIp,
        changePassword: this.changePassword,
        changePasswordRequested: this.changePasswordRequested,
        changePasswordBefore: this.changePasswordBefore,
        settings: this.settings,
        accessToken: this.accessToken,
        providerData: (_a = this.providerData) !== null && _a !== void 0 ? _a : []
      };
    }
    /**
     * Cria uma instância de AuthUser a partir de um objeto JSON.
     * @param auth Uma instância de Auth.
     * @param json Um objeto JSON representando um usuário.
     * @returns Uma instância de AuthUser criada a partir do objeto JSON.
     */
  }], [{
    key: "fromJSON",
    value: function fromJSON(auth, json) {
      var accessToken = json.accessToken,
        providerData = json.providerData,
        userInfo = __rest(json, ["accessToken", "providerData"]);
      return new AuthUser(auth, userInfo, accessToken);
    }
  }]);
}();
exports.AuthUser = AuthUser;
var Auth = /*#__PURE__*/function (_ivipbase_core_1$Simp) {
  function Auth(database, app) {
    var _this;
    _classCallCheck(this, Auth);
    _this = _callSuper(this, Auth);
    _this.database = database;
    _this.app = app;
    _this._ready = false;
    /**
     * Currently signed in user
     */
    _this._user = null;
    _this.isValidAuth = app.isServer || !app.settings.isValidClient ? false : true;
    _this.on("ready", function () {
      _this._ready = true;
    });
    _this.on("signin", function (user) {
      var _a;
      try {
        if (user) {
          _this._user = user;
          localStorage_1["default"].setItem("[".concat(_this.database, "][auth_user]"), base64_1["default"].encode(JSON.stringify(user.toJSON())));
        } else {
          _this._user = null;
          localStorage_1["default"].removeItem("[".concat(_this.database, "][auth_user]"));
        }
      } catch (_b) {
        _this._user = null;
        localStorage_1["default"].removeItem("[".concat(_this.database, "][auth_user]"));
      }
      if (!_this._ready) {
        _this.emit("ready");
      }
      (_a = _this.app.socket) === null || _a === void 0 ? void 0 : _a.emit("signin", {
        dbName: _this.database,
        accessToken: user.accessToken
      });
    });
    _this.on("signout", function (accessToken) {
      var _a;
      _this._user = null;
      localStorage_1["default"].removeItem("[".concat(_this.database, "][auth_user]"));
      if (!_this._ready) {
        _this.emit("ready");
      }
      if (accessToken) {
        (_a = _this.app.socket) === null || _a === void 0 ? void 0 : _a.emit("signout", {
          dbName: _this.database,
          accessToken: accessToken
        });
      }
    });
    _this.initialize();
    return _this;
  }
  _inherits(Auth, _ivipbase_core_1$Simp);
  return _createClass(Auth, [{
    key: "on",
    value: function on(event, callback) {
      return _get(_getPrototypeOf(Auth.prototype), "on", this).call(this, event, callback);
    }
  }, {
    key: "emit",
    value: function emit(event, data) {
      return _get(_getPrototypeOf(Auth.prototype), "emit", this).call(this, event, data);
    }
  }, {
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        var _this2 = this;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              this._ready = false;
              this.app.onConnect( /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(socket) {
                  var _a, user;
                  return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                    while (1) switch (_context9.prev = _context9.next) {
                      case 0:
                        _context9.prev = 0;
                        if (_this2._user) {
                          _context9.next = 10;
                          break;
                        }
                        user = localStorage_1["default"].getItem("[".concat(_this2.database, "][auth_user]"));
                        if (!user) {
                          _context9.next = 9;
                          break;
                        }
                        _this2._user = AuthUser.fromJSON(_this2, JSON.parse(base64_1["default"].decode(user)));
                        _context9.next = 7;
                        return _this2._user.reload(false);
                      case 7:
                        _context9.next = 10;
                        break;
                      case 9:
                        if (!_this2._ready) {
                          _this2.emit("ready");
                        }
                      case 10:
                        if (((_a = _this2._user) === null || _a === void 0 ? void 0 : _a.accessToken) && socket) {
                          socket.emit("signin", {
                            dbName: _this2.database,
                            accessToken: _this2._user.accessToken
                          });
                        }
                        _context9.next = 18;
                        break;
                      case 13:
                        _context9.prev = 13;
                        _context9.t0 = _context9["catch"](0);
                        _this2._user = null;
                        localStorage_1["default"].removeItem("[".concat(_this2.database, "][auth_user]"));
                        if (!_this2._ready) {
                          _this2.emit("ready");
                        }
                      case 18:
                      case "end":
                        return _context9.stop();
                    }
                  }, _callee9, null, [[0, 13]]);
                }));
                return function (_x7) {
                  return _ref.apply(this, arguments);
                };
              }(), true);
            case 2:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function initialize() {
        return _initialize.apply(this, arguments);
      }
      return initialize;
    }()
    /**
     * Aguarda até que o módulo Auth esteja pronto.
     * @param callback Uma função de retorno de chamada que será chamada quando o módulo Auth estiver pronto.
     * @returns Uma promise que é resolvida quando o módulo Auth estiver pronto.
     */
  }, {
    key: "ready",
    value: (function () {
      var _ready = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(callback) {
        var _this3 = this;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              if (this._ready) {
                _context11.next = 3;
                break;
              }
              _context11.next = 3;
              return new Promise(function (resolve) {
                return _this3.once("ready", resolve);
              });
            case 3:
              callback === null || callback === void 0 ? void 0 : callback(this._user);
            case 4:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function ready(_x8) {
        return _ready.apply(this, arguments);
      }
      return ready;
    }())
  }, {
    key: "user",
    get: function get() {
      return this._user;
    },
    set: function set(value) {
      try {
        if (value) {
          localStorage_1["default"].setItem("[".concat(this.database, "][auth_user]"), base64_1["default"].encode(JSON.stringify(value.toJSON())));
        } else {
          localStorage_1["default"].removeItem("[".concat(this.database, "][auth_user]"));
        }
      } catch (_a) {}
      this._user = value;
    }
  }, {
    key: "currentUser",
    get: function get() {
      return this.user;
    }
  }, {
    key: "handleSignInResult",
    value: function handleSignInResult(result) {
      var emitEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (!result || !result.user || !result.access_token) {
        this.user = null;
        this.emit("signout");
        throw new Error("auth/user-not-found");
      }
      var user = new AuthUser(this, result.user, result.access_token);
      this.user = user;
      var details = {
        user: user,
        accessToken: result.access_token,
        provider: result.provider
      };
      emitEvent && this.emit("signin", details.user);
      return this.user;
    }
    /**
     * Cria uma nova conta de usuário associada ao endereço de e-mail e senha especificados.
     * @param email O endereço de e-mail do usuário.
     * @param password A senha escolhida pelo usuário.
     * @param signIn Se deve ou não fazer login após a criação do usuário
     * @returns Uma promise que é resolvida com as informações do novo usuário criado.
     * @throws auth/email-already-in-use Lançado se já existir uma conta com o endereço de e-mail fornecido.
     * @throws auth/invalid-email Lançado se o endereço de e-mail não for válido.
     * @throws auth/operation-not-allowed Lançado se contas de e-mail/senha não estiverem habilitadas. Habilite contas de e-mail/senha no Console do Firebase, na aba Auth.
     * @throws auth/weak-password Lançado se a senha não for forte o suficiente.
     */
  }, {
    key: "createUserWithEmailAndPassword",
    value: (function () {
      var _createUserWithEmailAndPassword = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(email, password) {
        var signIn,
          result,
          _args12 = arguments;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              signIn = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : true;
              _context12.next = 3;
              return this.app.request({
                method: "POST",
                route: "/auth/".concat(this.database, "/signup"),
                data: {
                  username: (0, utils_1.sanitizeEmailPrefix)(email),
                  email: email,
                  password: password,
                  displayName: email,
                  display_name: email,
                  settings: {}
                }
              });
            case 3:
              result = _context12.sent;
              if (!signIn) {
                _context12.next = 6;
                break;
              }
              return _context12.abrupt("return", this.handleSignInResult(result));
            case 6:
              return _context12.abrupt("return", new AuthUser(this, result.user, result.access_token));
            case 7:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function createUserWithEmailAndPassword(_x9, _x10) {
        return _createUserWithEmailAndPassword.apply(this, arguments);
      }
      return createUserWithEmailAndPassword;
    }()
    /**
     * Cria uma nova conta de usuário associada ao nome de usuário e senha especificados.
     * @param username O nome de usuário do usuário.
     * @param email O endereço de e-mail do usuário.
     * @param password A senha escolhida pelo usuário.
     * @param signIn Se deve ou não fazer login após a criação do usuário
     * @returns Uma promise que é resolvida com as informações do novo usuário criado.
     * @throws auth/email-already-in-use Lançado se já existir uma conta com o endereço de e-mail fornecido.
     * @throws auth/invalid-email Lançado se o endereço de e-mail não for válido.
     * @throws auth/operation-not-allowed Lançado se contas de e-mail/senha não estiverem habilitadas. Habilite contas de e-mail/senha no Console do Firebase, na aba Auth.
     * @throws auth/weak-password Lançado se a senha não for forte o suficiente.
     * @throws auth/username-already-in-use Lançado se já existir uma conta com o nome de usuário fornecido.
     * @throws auth/invalid-username Lançado se o nome de usuário não for válido.
     * @throws auth/operation-not-allowed Lançado se contas de nome de usuário/senha não estiverem habilitadas. Habilite contas de nome de usuário/senha no Console do Firebase, na aba Auth.
     * @throws auth/weak-username Lançado se o nome de usuário não for forte o suficiente.
     * @throws auth/username-not-allowed Lançado se o nome de usuário não for permitido.
     * @throws auth/username-not-found Lançado se não houver usuário correspondente ao nome de usuário fornecido.
     * @throws auth/username-required Lançado se o nome de usuário não for fornecido.
     * @throws auth/email-required Lançado se o endereço de e-mail não for fornecido.
     * @throws auth/password-required Lançado se a senha não for fornecida.
     * @throws auth/username-email-mismatch Lançado se o nome de usuário e o endereço de e-mail não corresponderem.
     * @throws auth/username-email-already-in-use Lançado se já existir uma conta com o nome de usuário ou endereço de e-mail fornecido.
     * @throws auth/username-email-not-found Lançado se não houver usuário correspondente ao nome de usuário ou endereço de e-mail fornecido.
     * @throws auth/username-email-required Lançado se o nome de usuário e o endereço de e-mail não forem fornecidos.
     * @throws auth/username-email-require-recent-login Lançado se o último tempo de login do usuário não atender ao limite de segurança. Use reauthenticateWithCredential para resolver. Isso não se aplica se o usuário for anônimo.
     */
    )
  }, {
    key: "createUserWithUsernameAndPassword",
    value: (function () {
      var _createUserWithUsernameAndPassword = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(username, email, password) {
        var signIn,
          result,
          _args13 = arguments;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              signIn = _args13.length > 3 && _args13[3] !== undefined ? _args13[3] : true;
              _context13.next = 3;
              return this.app.request({
                method: "POST",
                route: "/auth/".concat(this.database, "/signup"),
                data: {
                  username: username,
                  email: email,
                  password: password,
                  displayName: email,
                  display_name: email,
                  settings: {}
                }
              });
            case 3:
              result = _context13.sent;
              if (!signIn) {
                _context13.next = 6;
                break;
              }
              return _context13.abrupt("return", this.handleSignInResult(result));
            case 6:
              return _context13.abrupt("return", new AuthUser(this, result.user, result.access_token));
            case 7:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function createUserWithUsernameAndPassword(_x11, _x12, _x13) {
        return _createUserWithUsernameAndPassword.apply(this, arguments);
      }
      return createUserWithUsernameAndPassword;
    }()
    /**
     * Loga de forma assíncrona usando um email e senha.
     * @param email O endereço de e-mail do usuário.
     * @param password A senha do usuário.
     * @returns Uma promise que é resolvida com as informações do usuário recém-criado.
     * @throws auth/desconnect Lançado se o servidor não estiver conectado.
     * @throws auth/system-error Lançado se ocorrer um erro interno no servidor.
     * @throws auth/invalid-email Lançado se o endereço de e-mail não for válido.
     * @throws auth/user-disabled Lançado se o usuário correspondente ao e-mail fornecido foi desativado.
     * @throws auth/user-not-found Lançado se não houver usuário correspondente ao e-mail fornecido.
     * @throws auth/wrong-password Lançado se a senha for inválida para o e-mail fornecido, ou se a conta correspondente ao e-mail não tiver uma senha definida.
     */
    )
  }, {
    key: "signInWithEmailAndPassword",
    value: (function () {
      var _signInWithEmailAndPassword = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(email, password) {
        var _a, result, access_token;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _context14.prev = 0;
              _context14.next = 3;
              return this.app.request({
                method: "POST",
                route: "/auth/".concat(this.database, "/signin"),
                data: {
                  method: "email",
                  email: email,
                  password: password,
                  client_id: this.app.socket && this.app.socket.id
                }
              })["catch"](function (e) {});
            case 3:
              result = _context14.sent;
              return _context14.abrupt("return", this.handleSignInResult(result));
            case 7:
              _context14.prev = 7;
              _context14.t0 = _context14["catch"](0);
              access_token = (_a = this.user) === null || _a === void 0 ? void 0 : _a.accessToken;
              this.user = null;
              this.emit("signout", access_token);
              throw _context14.t0;
            case 13:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this, [[0, 7]]);
      }));
      function signInWithEmailAndPassword(_x14, _x15) {
        return _signInWithEmailAndPassword.apply(this, arguments);
      }
      return signInWithEmailAndPassword;
    }()
    /**
     * Loga de forma assíncrona usando um nome de usuário e senha.
     * @param username O nome de usuário do usuário.
     * @param password A senha do usuário.
     * @returns Uma promise que é resolvida com as informações do usuário recém-criado.
     * @throws auth/invalid-username Lançado se o nome de usuário não for válido.
     * @throws auth/user-disabled Lançado se o usuário correspondente ao nome de usuário fornecido foi desativado.
     * @throws auth/user-not-found Lançado se não houver usuário correspondente ao nome de usuário fornecido.
     * @throws auth/wrong-password Lançado se a senha for inválida para o nome de usuário fornecido, ou se a conta correspondente ao nome de usuário não tiver uma senha definida.
     */
    )
  }, {
    key: "signInWithUsernameAndPassword",
    value: (function () {
      var _signInWithUsernameAndPassword = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(username, password) {
        var _a, result, access_token;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              _context15.prev = 0;
              _context15.next = 3;
              return this.app.request({
                method: "POST",
                route: "/auth/".concat(this.database, "/signin"),
                data: {
                  method: "account",
                  username: username,
                  password: password,
                  client_id: this.app.socket && this.app.socket.id
                }
              });
            case 3:
              result = _context15.sent;
              return _context15.abrupt("return", this.handleSignInResult(result));
            case 7:
              _context15.prev = 7;
              _context15.t0 = _context15["catch"](0);
              access_token = (_a = this.user) === null || _a === void 0 ? void 0 : _a.accessToken;
              this.user = null;
              this.emit("signout", access_token);
              throw _context15.t0;
            case 13:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this, [[0, 7]]);
      }));
      function signInWithUsernameAndPassword(_x16, _x17) {
        return _signInWithUsernameAndPassword.apply(this, arguments);
      }
      return signInWithUsernameAndPassword;
    }()
    /**
     * Loga de forma assíncrona usando um token de acesso.
     * @param token O token de acesso do usuário.
     * @param emitEvent Se deve ou não emitir o evento de login
     * @returns Uma promise que é resolvida com as informações do usuário recém-criado.
     * @throws auth/invalid-token Lançado se o token de acesso não for válido.
     * @throws auth/user-disabled Lançado se o usuário correspondente ao token de acesso fornecido foi desativado.
     * @throws auth/user-not-found Lançado se não houver usuário correspondente ao token de acesso fornecido.
     * @throws auth/wrong-token Lançado se o token de acesso for inválido para o usuário fornecido.
     */
    )
  }, {
    key: "signInWithToken",
    value: (function () {
      var _signInWithToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(token) {
        var emitEvent,
          _a,
          result,
          access_token,
          _args16 = arguments;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              emitEvent = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : true;
              _context16.prev = 1;
              _context16.next = 4;
              return this.app.request({
                method: "POST",
                route: "/auth/".concat(this.database, "/signin"),
                data: {
                  method: "token",
                  access_token: token,
                  client_id: this.app.socket && this.app.socket.id
                }
              });
            case 4:
              result = _context16.sent;
              return _context16.abrupt("return", this.handleSignInResult(result, emitEvent));
            case 8:
              _context16.prev = 8;
              _context16.t0 = _context16["catch"](1);
              access_token = (_a = this.user) === null || _a === void 0 ? void 0 : _a.accessToken;
              this.user = null;
              this.emit("signout", access_token);
              throw _context16.t0;
            case 14:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this, [[1, 8]]);
      }));
      function signInWithToken(_x18) {
        return _signInWithToken.apply(this, arguments);
      }
      return signInWithToken;
    }()
    /**
     * Desconecta o usuário atual.
     * @returns Uma promise que é resolvida quando a operação de desconexão for concluída.
     */
    )
  }, {
    key: "signOut",
    value: (function () {
      var _signOut = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
        var result, access_token;
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              if (!(!this.user || !this.user.accessToken)) {
                _context17.next = 2;
                break;
              }
              return _context17.abrupt("return", Promise.resolve());
            case 2:
              _context17.next = 4;
              return this.app.request({
                method: "POST",
                route: "/auth/".concat(this.database, "/signout"),
                data: {
                  client_id: this.app.socket && this.app.socket.id
                }
              });
            case 4:
              result = _context17.sent;
              access_token = this.user.accessToken;
              this.user = null;
              localStorage_1["default"].removeItem("[".concat(this.database, "][auth_user]"));
              this.emit("signout", access_token);
            case 9:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));
      function signOut() {
        return _signOut.apply(this, arguments);
      }
      return signOut;
    }()
    /**
     * Adiciona um observador para mudanças no estado de login do usuário.
     * @param callback Uma função observadora do usuário. Esta função recebe o usuário atual como parâmetro. Se o usuário estiver conectado, o parâmetro é as informações do usuário; caso contrário, é null.
     * @returns Uma função que remove o observador.
     */
    )
  }, {
    key: "onAuthStateChanged",
    value: function onAuthStateChanged(callback) {
      var _this4 = this;
      var byCallback = function byCallback(user) {
        callback(user instanceof AuthUser ? user : null);
      };
      this.on("signin", byCallback);
      this.on("signout", byCallback);
      var stop = function stop() {
        _this4.off("signin", byCallback);
        _this4.off("signout", byCallback);
      };
      return {
        stop: stop
      };
    }
    /**
     * Adiciona um observador para mudanças no token de ID do usuário conectado, que inclui eventos de login, logout e atualização de token.
     * @param callback Uma função observadora do usuário. Esta função recebe o usuário atual como parâmetro. Se o usuário estiver conectado, o parâmetro é as informações do usuário; caso contrário, é null.
     * @returns Uma função que remove o observador.
     */
  }, {
    key: "onIdTokenChanged",
    value: function onIdTokenChanged(callback) {
      var _this5 = this;
      var byCallback = function byCallback(user) {
        var _a;
        callback(user instanceof AuthUser ? (_a = user === null || user === void 0 ? void 0 : user.accessToken) !== null && _a !== void 0 ? _a : null : null);
      };
      this.on("signin", byCallback);
      this.on("signout", byCallback);
      var stop = function stop() {
        _this5.off("signin", byCallback);
        _this5.off("signout", byCallback);
      };
      return {
        stop: stop
      };
    }
    /**
     * Define de forma assíncrona o usuário fornecido como currentUser na instância de Auth atual. Será feita uma cópia da instância do usuário fornecido e definida como currentUser.
     * @param user Um usuário a ser definido como currentUser na instância de Auth atual.
     * @returns Uma promise que é resolvida quando o usuário é definido como currentUser na instância de Auth atual.
     * @throws auth/invalid-user-token Lançado se o token do usuário fornecido for inválido.
     * @throws auth/user-token-expired Lançado se o token do usuário fornecido estiver expirado.
     * @throws auth/null-user Lançado se o usuário fornecido for nulo.
     * @throws auth/tenant-id-mismatch Lançado se o ID do locatário do usuário fornecido não corresponder ao ID do locatário da instância de Auth.
     */
  }, {
    key: "updateCurrentUser",
    value: function updateCurrentUser(user) {
      this.user = user;
    }
    /**
     * Envia um e-mail de redefinição de senha para o endereço de e-mail fornecido.
     * @param email O endereço de e-mail do usuário.
     * @returns Uma promise que é resolvida quando o e-mail de redefinição de senha é enviado.
     * @throws auth/invalid-email Lançado se o endereço de e-mail não for válido.
     * @throws auth/missing-android-pkg-name Lançado se o nome do pacote Android estiver ausente quando o aplicativo Android for necessário.
     * @throws auth/missing-continue-uri Lançado se a URL de continuação estiver ausente quando o widget da web for necessário.
     * @throws auth/missing-ios-bundle-id Lançado se o ID do pacote iOS estiver ausente quando o aplicativo iOS for necessário.
     * @throws auth/invalid-continue-uri Lançado se a URL de continuação for inválida.
     * @throws auth/unauthorized-continue-uri Lançado se o domínio da URL de continuação não estiver na lista de permissões. Coloque o domínio na lista de permissões no console do Firebase.
     * @throws auth/user-not-found Lançado se não houver usuário correspondente ao endereço de e-mail.
     */
  }, {
    key: "sendPasswordResetEmail",
    value: (function () {
      var _sendPasswordResetEmail = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(email) {
        var result;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              _context18.next = 2;
              return this.app.request({
                method: "POST",
                route: "/auth/".concat(this.database, "/forgot_password"),
                data: {
                  email: email
                }
              });
            case 2:
              result = _context18.sent;
            case 3:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function sendPasswordResetEmail(_x19) {
        return _sendPasswordResetEmail.apply(this, arguments);
      }
      return sendPasswordResetEmail;
    }()
    /**
     * Aplica um código de verificação enviado ao usuário por e-mail ou outro mecanismo fora de banda.
     * @param code Código de verificação enviado ao usuário.
     * @returns Uma promise que é resolvida com o endereço de e-mail do usuário se o código de verificação for válido.
     * @throws auth/expired-action-code Lançado se o código de ação expirou.
     * @throws auth/invalid-action-code Lançado se o código de ação for inválido.
     * @throws auth/user-disabled Lançado se o usuário correspondente ao código de ação estiver desativado.
     * @throws auth/user-not-found Lançado se o usuário correspondente ao código de ação não for encontrado.
     */
    )
  }, {
    key: "applyActionCode",
    value: (function () {
      var _applyActionCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(code) {
        var result;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              _context19.next = 2;
              return this.app.request({
                method: "POST",
                route: "/auth/".concat(this.database, "/verify_email"),
                data: {
                  code: code
                }
              });
            case 2:
              result = _context19.sent;
              return _context19.abrupt("return", result.email);
            case 4:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));
      function applyActionCode(_x20) {
        return _applyActionCode.apply(this, arguments);
      }
      return applyActionCode;
    }()
    /**
     * Verifica um código de verificação enviado ao usuário por e-mail ou outro mecanismo fora de banda.
     * @param code Código de verificação enviado ao usuário.
     * @returns Uma promise que é resolvida com o endereço de e-mail do usuário se o código de verificação for válido.
     * @throws auth/expired-action-code Lançado se o código de ação expirou.
     * @throws auth/invalid-action-code Lançado se o código de ação for inválido.
     * @throws auth/user-disabled Lançado se o usuário correspondente ao código de ação estiver desativado.
     * @throws auth/user-not-found Lançado se o usuário correspondente ao código de ação não for encontrado.
     */
    )
  }, {
    key: "checkActionCode",
    value: function checkActionCode(code) {
      throw new Error("Method not implemented.");
    }
    /**
     * Confirma o novo endereço de e-mail do usuário usando um código de verificação.
     * @param code O código de verificação de e-mail enviado ao usuário.
     * @returns Uma promise que é resolvida com o endereço de e-mail do usuário se o novo e-mail for verificado com sucesso.
     * @throws auth/expired-action-code Lançado se o código de ação expirou.
     * @throws auth/invalid-action-code Lançado se o código de ação for inválido.
     * @throws auth/user-disabled Lançado se o usuário correspondente ao código de ação estiver desativado.
     * @throws auth/user-not-found Lançado se o usuário correspondente ao código de ação não for encontrado.
     * @throws auth/weak-password Lançado se o novo e-mail for inválido.
     */
  }, {
    key: "confirmPasswordReset",
    value: (function () {
      var _confirmPasswordReset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(code, newPassword) {
        var result;
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return this.app.request({
                method: "POST",
                route: "/auth/".concat(this.database, "/reset_password"),
                data: {
                  code: code,
                  password: newPassword
                }
              });
            case 2:
              result = _context20.sent;
            case 3:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function confirmPasswordReset(_x21, _x22) {
        return _confirmPasswordReset.apply(this, arguments);
      }
      return confirmPasswordReset;
    }()
    /**
     * Verifica um código de redefinição de senha enviado ao usuário por e-mail ou outro mecanismo fora de banda.
     * @param code Código de redefinição de senha enviado ao usuário.
     * @returns Uma promise que é resolvida com o endereço de e-mail do usuário se o código de redefinição de senha for válido.
     * @throws auth/expired-action-code Lançado se o código de ação expirou.
     * @throws auth/invalid-action-code Lançado se o código de ação for inválido.
     * @throws auth/user-disabled Lançado se o usuário correspondente ao código de ação estiver desativado.
     * @throws auth/user-not-found Lançado se o usuário correspondente ao código de ação não for encontrado.
     */
    )
  }, {
    key: "verifyPasswordResetCode",
    value: function verifyPasswordResetCode(code) {
      throw new Error("Method not implemented.");
    }
  }]);
}(ivipbase_core_1.SimpleEventEmitter);
exports.Auth = Auth;
function getAuth() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var app = args.find(function (a) {
      return a instanceof app_1.IvipBaseApp;
    }),
    dbName;
  var appNames = (0, app_1.getAppsName)();
  if (!app) {
    var name = appNames.find(function (n) {
      return args.includes(n);
    });
    app = name ? (0, app_1.getApp)(name) : (0, app_1.getFirstApp)();
  }
  var database = args.find(function (d) {
    return typeof d === "string" && appNames.includes(d) !== true;
  });
  if (typeof database !== "string") {
    database = app.settings.dbname;
  }
  dbName = (Array.isArray(database) ? database : [database])[0];
  if (!(0, database_1.hasDatabase)(dbName)) {
    throw new Error("Database \"".concat(dbName, "\" does not exist"));
  }
  if (app.auth.has(dbName)) {
    return app.auth.get(dbName);
  }
  var auth = new Auth(dbName, app);
  app.auth.set(dbName, auth);
  return auth;
}
exports.getAuth = getAuth;

},{"../app":1,"../database":23,"../utils":37,"../utils/base64":36,"../utils/localStorage":38,"ivipbase-core":152}],6:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypeMappings = exports.EventSubscription = exports.EventPublisher = exports.EventStream = exports.MutationsDataSnapshot = exports.DataSnapshot = exports.DataReferencesArray = exports.DataSnapshotsArray = exports.QueryDataRetrievalOptions = exports.DataRetrievalOptions = exports.DataReferenceQuery = exports.DataReference = exports.ObjectCollection = exports.PartialArray = exports.SimpleObservable = exports.SchemaDefinition = exports.ID = exports.ascii85 = exports.Utils = exports.SimpleCache = exports.SimpleEventEmitter = exports.PathReference = exports.PathInfo = exports.DataStorageSettings = exports.CustomStorage = void 0;
var storage_1 = require("./controller/storage");
Object.defineProperty(exports, "CustomStorage", {
  enumerable: true,
  get: function get() {
    return storage_1.CustomStorage;
  }
});
Object.defineProperty(exports, "DataStorageSettings", {
  enumerable: true,
  get: function get() {
    return storage_1.DataStorageSettings;
  }
});
__exportStar(require("./app"), exports);
__exportStar(require("./database"), exports);
__exportStar(require("./auth"), exports);
__exportStar(require("./storage"), exports);
__exportStar(require("./ipc"), exports);
var ivipbase_core_1 = require("ivipbase-core");
Object.defineProperty(exports, "PathInfo", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_1.PathInfo;
  }
});
Object.defineProperty(exports, "PathReference", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_1.PathReference;
  }
});
Object.defineProperty(exports, "SimpleEventEmitter", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_1.SimpleEventEmitter;
  }
});
Object.defineProperty(exports, "SimpleCache", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_1.SimpleCache;
  }
});
Object.defineProperty(exports, "Utils", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_1.Utils;
  }
});
Object.defineProperty(exports, "ascii85", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_1.ascii85;
  }
});
Object.defineProperty(exports, "ID", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_1.ID;
  }
});
Object.defineProperty(exports, "SchemaDefinition", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_1.SchemaDefinition;
  }
});
Object.defineProperty(exports, "SimpleObservable", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_1.SimpleObservable;
  }
});
Object.defineProperty(exports, "PartialArray", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_1.PartialArray;
  }
});
Object.defineProperty(exports, "ObjectCollection", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_1.ObjectCollection;
  }
});
var ivipbase_core_2 = require("ivipbase-core");
Object.defineProperty(exports, "DataReference", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_2.DataReference;
  }
});
Object.defineProperty(exports, "DataReferenceQuery", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_2.DataReferenceQuery;
  }
});
Object.defineProperty(exports, "DataRetrievalOptions", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_2.DataRetrievalOptions;
  }
});
Object.defineProperty(exports, "QueryDataRetrievalOptions", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_2.QueryDataRetrievalOptions;
  }
});
Object.defineProperty(exports, "DataSnapshotsArray", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_2.DataSnapshotsArray;
  }
});
Object.defineProperty(exports, "DataReferencesArray", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_2.DataReferencesArray;
  }
});
var ivipbase_core_3 = require("ivipbase-core");
Object.defineProperty(exports, "DataSnapshot", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_3.DataSnapshot;
  }
});
Object.defineProperty(exports, "MutationsDataSnapshot", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_3.MutationsDataSnapshot;
  }
});
var ivipbase_core_4 = require("ivipbase-core");
Object.defineProperty(exports, "EventStream", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_4.EventStream;
  }
});
Object.defineProperty(exports, "EventPublisher", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_4.EventPublisher;
  }
});
Object.defineProperty(exports, "EventSubscription", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_4.EventSubscription;
  }
});
var ivipbase_core_5 = require("ivipbase-core");
Object.defineProperty(exports, "TypeMappings", {
  enumerable: true,
  get: function get() {
    return ivipbase_core_5.TypeMappings;
  }
});

},{"./app":1,"./auth":5,"./controller/storage":19,"./database":23,"./ipc":27,"./storage":32,"ivipbase-core":152}],7:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ERROR_FACTORY = void 0;
var util_1 = require("./util");
var ERRORS = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "no-app" /* AppError.NO_APP */, "Nenhum aplicativo iVipBase '{$appName}' foi criado - " + "chame inicializeApp() primeiro"), "bad-app-name" /* AppError.BAD_APP_NAME */, "Nome de aplicativo ilegal: '{$appName}"), "duplicate-app" /* AppError.DUPLICATE_APP */, "O aplicativo Firebase chamado '{$appName}' já existe com diferentes opções ou configurações"), "app-deleted" /* AppError.APP_DELETED */, "Aplicativo iVipBase chamado '{$appName}' já excluído"), "db-disconnected" /* AppError.DB_DISCONNECTED */, "Banco de dados '{$dbName}' desconectado"), "db-connection-error" /* AppError.DB_CONNECTION_ERROR */, "Database connection error: {$error}"), "db-not-found" /* AppError.DB_NOT_FOUND */, "Banco de dados '{$dbName}' não encontrado"), "invalid-argument" /* AppError.INVALID_ARGUMENT */, "Invalid argument: {$message}");
exports.ERROR_FACTORY = new util_1.ErrorFactory("app", "iVipBase", ERRORS);

},{"./util":8}],8:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ErrorFactory = exports.MainError = void 0;
var ERROR_NAME = "iVipBaseError";
var MainError = /*#__PURE__*/function (_Error) {
  function MainError( /** O código de erro para este erro. */
  code, message, /** Dados personalizados para este erro. */
  customData) {
    var _this;
    _classCallCheck(this, MainError);
    _this = _callSuper(this, MainError, [message]);
    _this.code = code;
    _this.customData = customData;
    /** O nome personalizado para todos os iVipBaseError. */
    _this.name = ERROR_NAME;
    // Fix For ES5
    // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
    Object.setPrototypeOf(_this, MainError.prototype);
    // Mantém o rastreamento de pilha adequado para onde nosso erro foi gerado.
    // Disponível apenas no V8.
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_this, ErrorFactory.prototype.create);
    }
    return _this;
  }
  _inherits(MainError, _Error);
  return _createClass(MainError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.MainError = MainError;
var PATTERN = /\{\$([^}]+)}/g;
function replaceTemplate(template, data) {
  return template.replace(PATTERN, function (_, key) {
    var value = data[key];
    return value != null ? String(value) : "<".concat(key, "?>");
  });
}
var ErrorFactory = /*#__PURE__*/function () {
  function ErrorFactory(service, serviceName, errors) {
    _classCallCheck(this, ErrorFactory);
    this.service = service;
    this.serviceName = serviceName;
    this.errors = errors;
  }
  return _createClass(ErrorFactory, [{
    key: "create",
    value: function create(code) {
      var customData = (arguments.length <= 1 ? undefined : arguments[1]) || {};
      var fullCode = "".concat(this.service, "/").concat(code);
      var template = this.errors[code];
      var message = template ? replaceTemplate(template, customData) : "Error";
      // Nome do serviço: Mensagem de erro (serviço/código).
      var fullMessage = "".concat(this.serviceName, ": ").concat(message, " (").concat(fullCode, ").");
      var error = new MainError(fullCode, fullMessage, customData);
      return error;
    }
  }]);
}();
exports.ErrorFactory = ErrorFactory;

},{}],9:[function(require,module,exports){
"use strict";

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.executeQuery = exports.executeQueryRealtime = exports.executeFilters = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var utils_1 = require("../utils");
var structureNodes_1 = __importStar(require("./storage/MDE/structureNodes"));
var noop = function noop() {};
var executeFilters = function executeFilters(mainPath, currentPath, value, queryFilters) {
  var params = ivipbase_core_1.PathInfo.extractVariables(mainPath, currentPath);
  var filters = queryFilters.filter(function (f) {
    return ["<", "<=", "==", "!=", ">=", ">", "like", "!like", "in", "!in", "exists", "!exists", "between", "!between", "matches", "!matches", "has", "!has", "contains", "!contains"].includes(f.op);
  });
  value = ["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(value)) ? value : {};
  return filters.every(function (f) {
    var _a, _b;
    var val = (_b = (_a = value[f.key]) !== null && _a !== void 0 ? _a : params[f.key]) !== null && _b !== void 0 ? _b : null;
    val = (0, utils_1.isDate)(val) ? new Date(val).getTime() : val;
    var op = f.op;
    var compare = (0, utils_1.isDate)(f.compare) ? new Date(f.compare).getTime() : f.compare;
    switch (op) {
      case "<":
        return val < compare;
      case "<=":
        return val <= compare;
      case "==":
        return val === compare;
      case "!=":
        return val !== compare;
      case ">=":
        return val >= compare;
      case ">":
        return val > compare;
      case "in":
      case "!in":
        {
          if (!(f.compare instanceof Array)) {
            return op === "!in";
          }
          var isIn = f.compare instanceof Array && f.compare.includes(val);
          return op === "in" ? isIn : !isIn;
        }
      case "exists":
      case "!exists":
        {
          var isExists = val !== undefined && val !== null;
          return op === "exists" ? isExists : !isExists;
        }
      case "between":
      case "!between":
        {
          if (!(f.compare instanceof Array)) {
            return op === "!between";
          }
          var isBetween = f.compare instanceof Array && val >= f.compare[0] && val <= f.compare[1];
          return op === "between" ? isBetween : !isBetween;
        }
      case "like":
      case "!like":
        {
          if (typeof compare !== "string") {
            return op === "!like";
          }
          var pattern = "^" + compare.replace(/\*/g, ".*").replace(/\?/g, ".") + "$";
          var re = new RegExp(pattern, "i");
          var isLike = re.test(val);
          return op === "like" ? isLike : !isLike;
        }
      case "matches":
      case "!matches":
        {
          if (typeof compare !== "string") {
            return op === "!matches";
          }
          var _re = new RegExp(compare, "i");
          var isMatch = _re.test(val);
          return op === "matches" ? isMatch : !isMatch;
        }
      case "has":
      case "!has":
        {
          if (_typeof(val) !== "object") {
            return op === "!has";
          }
          var hasKey = Object.keys(val).includes(compare);
          return op === "has" ? hasKey : !hasKey;
        }
      case "contains":
      case "!contains":
        {
          if (!(val instanceof Array)) {
            return op === "!contains";
          }
          var contains = val.includes(compare);
          return op === "contains" ? contains : !contains;
        }
    }
    return false;
  });
};
exports.executeFilters = executeFilters;
var executeQueryRealtime = function executeQueryRealtime(db, path, query, options, matchedPaths) {
  var _a, _b, _c, _d;
  if ((options === null || options === void 0 ? void 0 : options.monitor) === true) {
    options.monitor = {
      add: true,
      change: true,
      remove: true
    };
  }
  var isRealtime = _typeof(options.monitor) === "object" && [(_a = options.monitor) === null || _a === void 0 ? void 0 : _a.add, (_b = options.monitor) === null || _b === void 0 ? void 0 : _b.change, (_c = options.monitor) === null || _c === void 0 ? void 0 : _c.remove].some(function (val) {
    return val === true;
  });
  if (isRealtime && typeof (options === null || options === void 0 ? void 0 : options.eventHandler) === "function") {
    var queryFilters = (_d = query.filters) !== null && _d !== void 0 ? _d : [];
    var ref = db.ref(path);
    var originalPath = ref.path;
    var removeMatch = function removeMatch(path) {
      var index = matchedPaths.indexOf(path);
      if (index < 0) {
        return;
      }
      matchedPaths.splice(index, 1);
    };
    var addMatch = function addMatch(path) {
      if (matchedPaths.includes(path)) {
        return;
      }
      matchedPaths.push(path);
    };
    var getMainPathChild = function getMainPathChild(path) {
      var main_path = ivipbase_core_1.PathInfo.get(path);
      while (!(main_path === null || main_path === void 0 ? void 0 : main_path.isChildOf(originalPath)) && main_path.parent !== null) {
        main_path = main_path.parent;
      }
      return main_path;
    };
    var childChangedCallback = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(err, path, newValue, oldValue) {
        var _a, _b, _c, _d, _e, _f, _g, wasMatch, keepMonitoring, main_path, isMatch, isChange, isAdd, isRemove;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              wasMatch = matchedPaths.includes(path);
              keepMonitoring = true;
              if (!(typeof (options === null || options === void 0 ? void 0 : options.eventHandler) !== "function" || newValue === null || newValue === undefined)) {
                _context.next = 4;
                break;
              }
              return _context.abrupt("return");
            case 4:
              main_path = getMainPathChild(path);
              if (main_path === null || main_path === void 0 ? void 0 : main_path.isChildOf(originalPath)) {
                _context.next = 7;
                break;
              }
              return _context.abrupt("return");
            case 7:
              isMatch = ["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(newValue)) && (0, exports.executeFilters)(originalPath, path, newValue, queryFilters);
              if (options.snapshots) {
                newValue = ["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(newValue)) ? (_a = (0, utils_1.removeNulls)((0, structureNodes_1.resolveObjetByIncluded)(path, newValue, {
                  include: options.include,
                  exclude: options.exclude,
                  main_path: main_path.path
                }))) !== null && _a !== void 0 ? _a : null : newValue;
              }
              isChange = typeof (options === null || options === void 0 ? void 0 : options.monitor) === "boolean" ? options.monitor : (_c = (_b = options === null || options === void 0 ? void 0 : options.monitor) === null || _b === void 0 ? void 0 : _b.change) !== null && _c !== void 0 ? _c : false;
              isAdd = typeof (options === null || options === void 0 ? void 0 : options.monitor) === "boolean" ? options.monitor : (_e = (_d = options === null || options === void 0 ? void 0 : options.monitor) === null || _d === void 0 ? void 0 : _d.add) !== null && _e !== void 0 ? _e : false;
              isRemove = typeof (options === null || options === void 0 ? void 0 : options.monitor) === "boolean" ? options.monitor : (_g = (_f = options === null || options === void 0 ? void 0 : options.monitor) === null || _f === void 0 ? void 0 : _f.remove) !== null && _g !== void 0 ? _g : false;
              if (isMatch) {
                if (!wasMatch) {
                  addMatch(path);
                }
                if (wasMatch && isChange) {
                  keepMonitoring = options.eventHandler({
                    name: "change",
                    path: path,
                    value: newValue
                  }) !== false;
                } else if (!wasMatch && isAdd) {
                  keepMonitoring = options.eventHandler({
                    name: "add",
                    path: path,
                    value: newValue
                  }) !== false;
                }
              } else if (wasMatch) {
                removeMatch(path);
                if (isRemove) {
                  keepMonitoring = options.eventHandler({
                    name: "remove",
                    path: path,
                    value: oldValue
                  }) !== false;
                }
              }
              if (keepMonitoring === false) {
                stopMonitoring();
              }
            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function childChangedCallback(_x, _x2, _x3, _x4) {
        return _ref.apply(this, arguments);
      };
    }();
    var childAddedCallback = function childAddedCallback(err, path, newValue) {
      var _a, _b, _c;
      var wasMatch = ["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(newValue)) && (0, exports.executeFilters)(originalPath, path, newValue, queryFilters);
      if (typeof (options === null || options === void 0 ? void 0 : options.eventHandler) !== "function" || !wasMatch || newValue === null || newValue === undefined) {
        return;
      }
      var main_path = getMainPathChild(path);
      if (!(main_path === null || main_path === void 0 ? void 0 : main_path.isChildOf(originalPath))) {
        return;
      }
      var keepMonitoring = true;
      addMatch(path);
      var isAdd = typeof (options === null || options === void 0 ? void 0 : options.monitor) === "boolean" ? options.monitor : (_b = (_a = options === null || options === void 0 ? void 0 : options.monitor) === null || _a === void 0 ? void 0 : _a.add) !== null && _b !== void 0 ? _b : false;
      if (isAdd) {
        if (options.snapshots) {
          newValue = ["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(newValue)) ? (_c = (0, utils_1.removeNulls)((0, structureNodes_1.resolveObjetByIncluded)(path, newValue, {
            include: options.include,
            exclude: options.exclude,
            main_path: main_path.path
          }))) !== null && _c !== void 0 ? _c : null : newValue;
        }
        keepMonitoring = options.eventHandler({
          name: "add",
          path: path,
          value: options.snapshots ? newValue : null
        }) !== false;
      }
      if (keepMonitoring === false) {
        stopMonitoring();
      }
    };
    var childRemovedCallback = function childRemovedCallback(err, path, newValue, oldValue) {
      var _a, _b;
      var keepMonitoring = true;
      if (typeof (options === null || options === void 0 ? void 0 : options.eventHandler) !== "function") {
        return;
      }
      removeMatch(path);
      var isRemove = typeof (options === null || options === void 0 ? void 0 : options.monitor) === "boolean" ? options.monitor : (_b = (_a = options === null || options === void 0 ? void 0 : options.monitor) === null || _a === void 0 ? void 0 : _a.remove) !== null && _b !== void 0 ? _b : false;
      if (isRemove) {
        keepMonitoring = options.eventHandler({
          name: "remove",
          path: path,
          value: options.snapshots ? oldValue : null
        }) !== false;
      }
      if (keepMonitoring === false) {
        stopMonitoring();
      }
    };
    if (_typeof(options.monitor) === "object" && (options.monitor.add || options.monitor.change || options.monitor.remove)) {
      db.storage.subscribe(ref.path, "child_changed", childChangedCallback);
    }
    if (_typeof(options.monitor) === "object" && options.monitor.remove) {
      db.storage.subscribe(ref.path, "notify_child_removed", childRemovedCallback);
    }
    if (_typeof(options.monitor) === "object" && options.monitor.add) {
      db.storage.subscribe(ref.path, "child_added", childAddedCallback);
    }
    var stopMonitoring = function stopMonitoring() {
      db.storage.unsubscribe(ref.path, "child_changed", childChangedCallback);
      db.storage.unsubscribe(ref.path, "child_added", childAddedCallback);
      db.storage.unsubscribe(ref.path, "notify_child_removed", childRemovedCallback);
    };
    return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            stopMonitoring();
          case 1:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
  }
  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
};
exports.executeQueryRealtime = executeQueryRealtime;
/**
 *
 * @param storage Instância de armazenamento de destino
 * @param dbName Nome do banco de dados
 * @param path Caminho da coleção de objetos para executar a consulta
 * @param query Consulta a ser executada
 * @param options Opções adicionais
 * @returns Retorna uma promise que resolve com os dados ou caminhos correspondentes em `results`
 */
function executeQuery(_x5, _x6, _x7) {
  return _executeQuery.apply(this, arguments);
}
function _executeQuery() {
  _executeQuery = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(db, path, query) {
    var options,
      _a,
      _b,
      api,
      database,
      stop,
      originalPath,
      pathInfo,
      context,
      queryFilters,
      querySort,
      compare,
      nodes,
      mainNodesPaths,
      results,
      _iterator,
      _step,
      _loop,
      take,
      totalLength,
      isMore,
      i,
      _results$i,
      _path,
      val,
      node_path,
      paths,
      _args6 = arguments;
    return _regeneratorRuntime().wrap(function _callee5$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          options = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : {
            snapshots: false,
            include: undefined,
            exclude: undefined,
            child_objects: undefined,
            eventHandler: noop
          };
          if (_typeof(options) !== "object") {
            options = {};
          }
          if (typeof options.snapshots === "undefined") {
            options.snapshots = false;
          }
          api = db.app;
          database = db.database;
          stop = /*#__PURE__*/function () {
            var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
              return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                while (1) switch (_context4.prev = _context4.next) {
                  case 0:
                  case "end":
                    return _context4.stop();
                }
              }, _callee4);
            }));
            return function stop() {
              return _ref4.apply(this, arguments);
            };
          }();
          originalPath = path;
          path = ivipbase_core_1.PathInfo.get([api.storage.settings.prefix, originalPath]).path;
          pathInfo = ivipbase_core_1.PathInfo.get(path);
          context = {};
          context.database_cursor = ivipbase_core_1.ID.generate();
          queryFilters = (_a = query.filters) !== null && _a !== void 0 ? _a : [];
          querySort = (_b = query.order) !== null && _b !== void 0 ? _b : [];
          compare = function compare(a, b, i) {
            var o = querySort[i];
            if (!o) {
              return 0;
            }
            var trailKeys = ivipbase_core_1.PathInfo.get(typeof o.key === "number" ? "[".concat(o.key, "]") : o.key).keys;
            var left = trailKeys.reduce(function (val, key) {
              return val !== null && _typeof(val) === "object" && key && key in val ? val[key] : null;
            }, a.val);
            var right = trailKeys.reduce(function (val, key) {
              return val !== null && _typeof(val) === "object" && key && key in val ? val[key] : null;
            }, b.val);
            left = (0, utils_1.isDate)(left) ? new Date(left).getTime() : left;
            right = (0, utils_1.isDate)(right) ? new Date(right).getTime() : right;
            if (left === null) {
              return right === null ? 0 : o.ascending ? -1 : 1;
            }
            if (right === null) {
              return o.ascending ? 1 : -1;
            }
            if (left == right) {
              if (i < querySort.length - 1) {
                return compare(a, b, i + 1);
              } else {
                return a.path < b.path ? -1 : 1;
              }
            } else if (left < right) {
              return o.ascending ? -1 : 1;
            }
            // else if (left > right) {
            return o.ascending ? 1 : -1;
            // }
          };
          _context6.next = 16;
          return api.storage.getNodesBy(database, path, false, options.snapshots ? true : 2, false)["catch"](function () {
            return Promise.resolve([]);
          });
        case 16:
          nodes = _context6.sent;
          // .then((nodes) => nodes.filter((n) => PathInfo.get(n.path).isChildOf(path) || PathInfo.get(n.path).isDescendantOf(path)));
          mainNodesPaths = nodes.filter(function (_ref5) {
            var path = _ref5.path;
            return pathInfo.equals(path);
          }).map(function (p) {
            return p.path;
          });
          results = [];
          _iterator = _createForOfIteratorHelper(mainNodesPaths);
          _context6.prev = 20;
          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
            var path, json;
            return _regeneratorRuntime().wrap(function _loop$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  path = _step.value;
                  _context5.next = 3;
                  return new Promise(function (resolve) {
                    return setTimeout(resolve, 0);
                  });
                case 3:
                  json = (0, structureNodes_1["default"])(path, nodes);
                  results = results.concat(Object.entries(json).map(function (_ref7) {
                    var _ref8 = _slicedToArray(_ref7, 2),
                      k = _ref8[0],
                      val = _ref8[1];
                    var p = ivipbase_core_1.PathInfo.get([path, k]).path;
                    return {
                      path: p,
                      val: val
                    };
                  }));
                case 5:
                case "end":
                  return _context5.stop();
              }
            }, _loop);
          });
          _iterator.s();
        case 23:
          if ((_step = _iterator.n()).done) {
            _context6.next = 27;
            break;
          }
          return _context6.delegateYield(_loop(), "t0", 25);
        case 25:
          _context6.next = 23;
          break;
        case 27:
          _context6.next = 32;
          break;
        case 29:
          _context6.prev = 29;
          _context6.t1 = _context6["catch"](20);
          _iterator.e(_context6.t1);
        case 32:
          _context6.prev = 32;
          _iterator.f();
          return _context6.finish(32);
        case 35:
          results = results.filter(function (node) {
            return (0, exports.executeFilters)(path, node.path, node.val, queryFilters);
          }).sort(function (a, b) {
            return compare(a, b, 0);
          });
          take = query.take > 0 ? query.take : results.length;
          totalLength = results.length;
          results = results.slice(query.skip * take, query.skip * take + take);
          isMore = totalLength > query.skip * take + take;
          if (!options.snapshots) {
            _context6.next = 52;
            break;
          }
          i = 0;
        case 42:
          if (!(i < results.length)) {
            _context6.next = 52;
            break;
          }
          _context6.next = 45;
          return new Promise(function (resolve) {
            return setTimeout(resolve, 0);
          });
        case 45:
          _results$i = results[i], _path = _results$i.path, val = _results$i.val;
          val = (0, utils_1.removeNulls)(["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(val)) ? (0, structureNodes_1.resolveObjetByIncluded)(_path, val, {
            include: options.include,
            exclude: options.exclude,
            main_path: _path
          }) : val);
          node_path = _path.replace(new RegExp("^".concat(api.storage.settings.prefix.replace(/\//gi, "\\/"))), "").replace(/^(\/)+/gi, "");
          results[i] = {
            path: node_path,
            val: val
          };
        case 49:
          i++;
          _context6.next = 42;
          break;
        case 52:
          paths = results.map(function (_ref6) {
            var path = _ref6.path;
            return path.replace(new RegExp("^".concat(api.storage.settings.prefix.replace(/\//gi, "\\/"))), "").replace(/^(\/)+/gi, "");
          });
          stop = (0, exports.executeQueryRealtime)(db, originalPath, query, options, paths);
          return _context6.abrupt("return", {
            results: options.snapshots ? results : paths,
            context: context,
            stop: stop,
            isMore: isMore
          });
        case 55:
        case "end":
          return _context6.stop();
      }
    }, _callee5, null, [[20, 29, 32, 35]]);
  }));
  return _executeQuery.apply(this, arguments);
}
exports.executeQuery = executeQuery;
exports["default"] = executeQuery;

},{"../utils":37,"./storage/MDE/structureNodes":17,"ivipbase-core":152}],10:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NOT_CONNECTED_ERROR_MESSAGE = exports.RequestError = void 0;
var RequestError = /*#__PURE__*/function (_Error) {
  function RequestError(request, response, code) {
    var _this;
    var message = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "unknown error";
    _classCallCheck(this, RequestError);
    _this = _callSuper(this, RequestError, [message]);
    _this.request = request;
    _this.response = response;
    _this.code = code;
    _this.message = message;
    return _this;
  }
  _inherits(RequestError, _Error);
  return _createClass(RequestError, [{
    key: "isNetworkError",
    get: function get() {
      return this.response === null;
    }
  }]);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.RequestError = RequestError;
exports.NOT_CONNECTED_ERROR_MESSAGE = "remote database is not connected"; //'DataBaseClient is not connected';

},{}],11:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ivip_utils_1 = require("ivip-utils");
var error_1 = require("./error");
var axios_1 = __importDefault(require("axios"));
/**
 * @returns returns a promise that resolves with an object containing data and an optionally returned context
 */
function request(_x, _x2) {
  return _request.apply(this, arguments);
}
function _request() {
  _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(method, url) {
    var options,
      _a,
      _b,
      _c,
      postData,
      headers,
      request,
      chunkSize,
      chunk,
      res,
      data,
      isJSON,
      response,
      code,
      message,
      err,
      contextHeader,
      context,
      _args = arguments;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {
            accessToken: null,
            data: null,
            dataReceivedCallback: null,
            dataRequestCallback: null,
            context: null
          };
          postData = options.data;
          if (typeof postData === "undefined" || postData === null) {
            postData = "";
          } else if (["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(postData))) {
            postData = JSON.stringify(postData);
          }
          headers = {
            "DataBase-Context": JSON.stringify(options.context || null)
          };
          request = {
            url: url,
            method: method,
            headers: headers,
            data: undefined,
            onUploadProgress: options.onUploadProgress,
            onDownloadProgress: options.onDownloadProgress,
            responseType: options.dataReceivedCallback ? "arraybuffer" : "text"
          };
          if (!(typeof options.dataRequestCallback === "function")) {
            _context.next = 18;
            break;
          }
          // Stream data to the server instead of posting all from memory at once
          headers["Content-Type"] = "application/octet-stream"; // Prevent server middleware parsing the content as JSON
          postData = "";
          chunkSize = 1024 * 512; // Use large chunk size, we have to store everything in memory anyway.
        case 9:
          _context.next = 11;
          return options.dataRequestCallback(chunkSize);
        case 11:
          if (!(chunk = _context.sent)) {
            _context.next = 15;
            break;
          }
          postData += chunk;
          _context.next = 9;
          break;
        case 15:
          request.data = Uint8Array.from(unescape(encodeURIComponent(postData)), function (x) {
            return x.charCodeAt(0);
          });
          _context.next = 19;
          break;
        case 18:
          if ((0, ivip_utils_1.isJson)(postData)) {
            headers["Content-Type"] = "application/json";
            request.data = typeof postData === "string" ? JSON.parse(postData) : postData;
          } else {
            headers["Content-Type"] = "application/octet-stream";
            // headers["Content-Length"] = postData.length;
            request.data = postData;
          }
        case 19:
          if (options.accessToken) {
            headers["Authorization"] = "Bearer ".concat(options.accessToken);
            //request.params["auth_token"] = options.accessToken;
          }
          _context.next = 22;
          return (0, axios_1["default"])(request)["catch"](function (err) {
            // console.error(err);
            throw new error_1.RequestError(request, null, "fetch_failed", err.message);
          });
        case 22:
          res = _context.sent;
          // const res = await fetch(request.url, request).catch((err) => {
          // 	// console.error(err);
          // 	throw new RequestError(request, null, "fetch_failed", err.message);
          // });
          data = res.data;
          if (typeof options.dataReceivedCallback === "function") {
            options.dataReceivedCallback(res.data);
          }
          isJSON = data[0] === "{" || data[0] === "["; // || (res.headers['content-type'] || '').startsWith('application/json')
          if (!(res.status !== 200)) {
            _context.next = 31;
            break;
          }
          response = {
            statusCode: res.status,
            statusMessage: res.statusText,
            headers: res.headers,
            body: data
          };
          code = res.status, message = res.statusText;
          if (isJSON) {
            err = JSON.parse(data);
            if (err.code) {
              code = err.code;
            }
            if (err.message) {
              message = err.message;
            }
          } else if ("code" in data || "message" in data) {
            code = (_a = data.code) !== null && _a !== void 0 ? _a : res.status;
            message = (_b = data.message) !== null && _b !== void 0 ? _b : res.statusText;
          }
          throw new error_1.RequestError(Object.assign(Object.assign({}, request), {
            body: postData
          }), response, code, message);
        case 31:
          contextHeader = (_c = res.headers["DataBase-Context"]) !== null && _c !== void 0 ? _c : res.headers["database-context"];
          if (contextHeader && contextHeader[0] === "{") {
            context = JSON.parse(contextHeader);
          } else {
            context = {};
          }
          if (isJSON) {
            data = JSON.parse(data);
          }
          return _context.abrupt("return", {
            context: context,
            data: data
          });
        case 35:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _request.apply(this, arguments);
}
exports["default"] = request;

},{"./error":10,"axios":40,"ivip-utils":125}],12:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomStorage = exports.CustomStorageSettings = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var erros_1 = require("../erros");
var MDE_1 = __importStar(require("./MDE"));
var CustomStorageSettings = /*#__PURE__*/function (_MDE_1$MDESettings) {
  function CustomStorageSettings() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, CustomStorageSettings);
    return _callSuper(this, CustomStorageSettings, [options]);
  }
  _inherits(CustomStorageSettings, _MDE_1$MDESettings);
  return _createClass(CustomStorageSettings);
}(MDE_1.MDESettings);
exports.CustomStorageSettings = CustomStorageSettings;
var CustomStorage = /*#__PURE__*/function (_MDE_1$default) {
  function CustomStorage() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var app = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, CustomStorage);
    var logLevel = options.logLevel,
      _options = __rest(options, ["logLevel"]);
    _this = _callSuper(this, CustomStorage, [Object.assign(Object.assign({}, _options), {
      getMultiple: function getMultiple(database, e) {
        if (!_this.ready) {
          throw erros_1.ERROR_FACTORY.create("db-disconnected" /* AppError.DB_DISCONNECTED */, {
            dbName: _this.dbName
          });
        }
        return _this.getMultiple(database, e);
      },
      setNode: function setNode(database, path, content, node) {
        if (!_this.ready) {
          throw erros_1.ERROR_FACTORY.create("db-disconnected" /* AppError.DB_DISCONNECTED */, {
            dbName: _this.dbName
          });
        }
        return _this.setNode(database, path, content, node);
      },
      removeNode: function removeNode(database, path, content, node) {
        if (!_this.ready) {
          throw erros_1.ERROR_FACTORY.create("db-disconnected" /* AppError.DB_DISCONNECTED */, {
            dbName: _this.dbName
          });
        }
        return _this.removeNode(database, path, content, node);
      }
    })]);
    _this.app = app;
    _this._dbName = "CustomStorage";
    _this.logLevel = "log";
    _this.logLevel = logLevel || "log";
    _this._debug = new ivipbase_core_1.DebugLogger(_this.logLevel, "[".concat(_this.dbName, "]"));
    return _this;
  }
  _inherits(CustomStorage, _MDE_1$default);
  return _createClass(CustomStorage, [{
    key: "dbName",
    get: function get() {
      return this._dbName;
    },
    set: function set(value) {
      this._dbName = value;
      this._debug = new ivipbase_core_1.DebugLogger(this.logLevel, "[".concat(this._dbName, "]"));
    }
  }, {
    key: "debug",
    get: function get() {
      return this._debug;
    }
  }]);
}(MDE_1["default"]);
exports.CustomStorage = CustomStorage;

},{"../erros":7,"./MDE":16,"ivipbase-core":152}],13:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataStorage = exports.DataStorageSettings = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var erros_1 = require("../erros");
var CustomStorage_1 = require("./CustomStorage");
var DataStorageSettings = /*#__PURE__*/function (_CustomStorage_1$Cust) {
  function DataStorageSettings() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, DataStorageSettings);
    return _callSuper(this, DataStorageSettings, [options]);
  }
  _inherits(DataStorageSettings, _CustomStorage_1$Cust);
  return _createClass(DataStorageSettings);
}(CustomStorage_1.CustomStorageSettings);
exports.DataStorageSettings = DataStorageSettings;
var DataStorage = /*#__PURE__*/function (_CustomStorage_1$Cust2) {
  function DataStorage(database) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var app = arguments.length > 2 ? arguments[2] : undefined;
    _classCallCheck(this, DataStorage);
    _this = _callSuper(this, DataStorage, [options, app]);
    _this.data = {};
    _this.dbName = "TempStorage";
    (Array.isArray(database) ? database : [database]).filter(function (name) {
      return typeof name === "string" && name.trim() !== "";
    }).forEach(function (name) {
      _this.data[name] = new Map();
    });
    _this.emit("ready");
    return _this;
  }
  _inherits(DataStorage, _CustomStorage_1$Cust2);
  return _createClass(DataStorage, [{
    key: "getMultiple",
    value: function () {
      var _getMultiple = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(database, _ref) {
        var regex, list;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              regex = _ref.regex;
              if (this.data[database]) {
                _context.next = 3;
                break;
              }
              throw erros_1.ERROR_FACTORY.create("db-not-found" /* AppError.DB_NOT_FOUND */, {
                dbName: database
              });
            case 3:
              list = [];
              this.data[database].forEach(function (content, path) {
                if (regex.test(path)) {
                  if (content) {
                    list.push(ivipbase_core_1.Utils.cloneObject({
                      path: path,
                      content: content
                    }));
                  }
                }
              });
              return _context.abrupt("return", list);
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getMultiple(_x, _x2) {
        return _getMultiple.apply(this, arguments);
      }
      return getMultiple;
    }()
  }, {
    key: "setNode",
    value: function () {
      var _setNode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(database, path, content) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (this.data[database]) {
                _context2.next = 2;
                break;
              }
              throw erros_1.ERROR_FACTORY.create("db-not-found" /* AppError.DB_NOT_FOUND */, {
                dbName: database
              });
            case 2:
              this.data[database].set(path, content);
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function setNode(_x3, _x4, _x5) {
        return _setNode.apply(this, arguments);
      }
      return setNode;
    }()
  }, {
    key: "removeNode",
    value: function () {
      var _removeNode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(database, path) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (this.data[database]) {
                _context3.next = 2;
                break;
              }
              throw erros_1.ERROR_FACTORY.create("db-not-found" /* AppError.DB_NOT_FOUND */, {
                dbName: database
              });
            case 2:
              this.data[database]["delete"](path);
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function removeNode(_x6, _x7) {
        return _removeNode.apply(this, arguments);
      }
      return removeNode;
    }()
  }]);
}(CustomStorage_1.CustomStorage);
exports.DataStorage = DataStorage;

},{"../erros":7,"./CustomStorage":12,"ivipbase-core":152}],14:[function(require,module,exports){
"use strict";

function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomStorageNodeInfo = exports.NodeInfo = exports.NodeAddress = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var utils_1 = require("./utils");
var NodeAddress = /*#__PURE__*/function () {
  function NodeAddress(path) {
    _classCallCheck(this, NodeAddress);
    this.path = path;
  }
  return _createClass(NodeAddress, [{
    key: "toString",
    value: function toString() {
      return "\"/".concat(this.path, "\"");
    }
    /**
     * Compares this address to another address
     */
  }, {
    key: "equals",
    value: function equals(address) {
      return ivipbase_core_1.PathInfo.get(this.path).equals(address.path);
    }
  }]);
}();
exports.NodeAddress = NodeAddress;
var NodeInfo = /*#__PURE__*/function () {
  function NodeInfo(info) {
    _classCallCheck(this, NodeInfo);
    this.path = info.path;
    this.type = info.type;
    this.index = info.index;
    this.key = info.key;
    this.exists = info.exists;
    this.address = info.address;
    this.value = info.value;
    this.childCount = info.childCount;
    if (typeof this.path === "string" && typeof this.key === "undefined" && typeof this.index === "undefined") {
      var pathInfo = ivipbase_core_1.PathInfo.get(this.path);
      if (typeof pathInfo.key === "number") {
        this.index = pathInfo.key;
      } else {
        this.key = pathInfo.key;
      }
    }
    if (typeof this.exists === "undefined") {
      this.exists = true;
    }
  }
  return _createClass(NodeInfo, [{
    key: "valueType",
    get: function get() {
      var _a;
      return (_a = this.type) !== null && _a !== void 0 ? _a : -1;
    }
  }, {
    key: "valueTypeName",
    get: function get() {
      return (0, utils_1.getValueTypeName)(this.valueType);
    }
  }, {
    key: "toString",
    value: function toString() {
      if (!this.exists) {
        return "\"".concat(this.path, "\" doesn't exist");
      }
      if (this.address) {
        return "\"".concat(this.path, "\" is ").concat(this.valueTypeName, " stored at ").concat(this.address.toString());
      } else {
        return "\"".concat(this.path, "\" is ").concat(this.valueTypeName, " with value ").concat(this.value);
      }
    }
  }]);
}();
exports.NodeInfo = NodeInfo;
var CustomStorageNodeInfo = /*#__PURE__*/function (_NodeInfo) {
  function CustomStorageNodeInfo(info) {
    var _this;
    _classCallCheck(this, CustomStorageNodeInfo);
    _this = _callSuper(this, CustomStorageNodeInfo, [info]);
    _this.revision = info.revision;
    _this.revision_nr = info.revision_nr;
    _this.created = info.created;
    _this.modified = info.modified;
    return _this;
  }
  _inherits(CustomStorageNodeInfo, _NodeInfo);
  return _createClass(CustomStorageNodeInfo);
}(NodeInfo);
exports.CustomStorageNodeInfo = CustomStorageNodeInfo;

},{"./utils":18,"ivipbase-core":152}],15:[function(require,module,exports){
"use strict";

function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var ivipbase_core_1 = require("ivipbase-core");
var utils_1 = require("./utils");
var modifyRevision = function modifyRevision(revision) {
  revision = revision !== null && revision !== void 0 ? revision : ivipbase_core_1.ID.generate();
  return function (node) {
    if (node.previous_content) {
      node.content.created = node.previous_content.created;
      node.content.revision_nr = node.previous_content.revision_nr;
    }
    if (node.type === "SET" || node.type === "UPDATE") {
      node.content.modified = Date.now();
    }
    node.content.revision = revision;
    node.content.revision_nr = node.content.revision_nr + 1;
    return node;
  };
};
var extactNodes = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(type, obj) {
    var path,
      controllers,
      options,
      parentValue,
      _a,
      revision,
      pathInfo,
      fitsInline,
      currentNode,
      k,
      _fitsInline,
      value,
      _args = arguments;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          path = _args.length > 2 && _args[2] !== undefined ? _args[2] : [];
          controllers = _args.length > 3 ? _args[3] : undefined;
          options = _args.length > 4 ? _args[4] : undefined;
          parentValue = _args.length > 5 && _args[5] !== undefined ? _args[5] : undefined;
          if (!(Math.random() > 0.4)) {
            _context.next = 7;
            break;
          }
          _context.next = 7;
          return new Promise(function (resolve) {
            return setTimeout(resolve, 0);
          });
        case 7:
          revision = (_a = options === null || options === void 0 ? void 0 : options.assert_revision) !== null && _a !== void 0 ? _a : ivipbase_core_1.ID.generate();
          pathInfo = ivipbase_core_1.PathInfo.get(path);
          fitsInline = (0, utils_1.valueFitsInline)(obj, options);
          if (parentValue) {
            parentValue.type = parentValue.type === "VERIFY" ? "UPDATE" : type;
            if (parentValue.content.value === null) {
              parentValue.content.value = parentValue.content.type === utils_1.nodeValueTypes.ARRAY ? [] : {};
            }
            parentValue.content.value[pathInfo.key] = fitsInline ? (0, utils_1.getTypedChildValue)(obj) : null;
          }
          currentNode = {
            path: pathInfo.path,
            type: type,
            content: {
              type: (0, utils_1.getValueType)(obj),
              value: _typeof(obj) === "object" ? Array.isArray(obj) ? [] : {} : obj,
              revision: revision,
              revision_nr: 1,
              created: Date.now(),
              modified: Date.now()
            }
          };
          _context.t0 = _regeneratorRuntime().keys(obj);
        case 13:
          if ((_context.t1 = _context.t0()).done) {
            _context.next = 26;
            break;
          }
          k = _context.t1.value;
          _fitsInline = (0, utils_1.valueFitsInline)(obj[k], options);
          if (currentNode && _fitsInline) {
            if (currentNode.type === "VERIFY") {
              currentNode.type = "UPDATE";
            }
            if (currentNode.content.value === null) {
              currentNode.content.value = {};
            }
            currentNode.content.value[k] = (0, utils_1.getTypedChildValue)(obj[k]);
          }
          if (!(["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(obj[k])) && !_fitsInline)) {
            _context.next = 22;
            break;
          }
          _context.next = 20;
          return extactNodes(type, obj[k], [].concat(_toConsumableArray(path), [k]), controllers, options, currentNode);
        case 20:
          _context.next = 24;
          break;
        case 22:
          value = _fitsInline ? null : _typeof(obj[k]) === "object" ? Array.isArray(obj[k]) ? [] : {} : obj[k];
          controllers.resolveNodesConflict([{
            path: ivipbase_core_1.PathInfo.get([].concat(_toConsumableArray(path), [k])).path,
            type: type,
            content: {
              type: (0, utils_1.getValueType)(value),
              value: value,
              revision: revision,
              revision_nr: 1,
              created: Date.now(),
              modified: Date.now()
            }
          }]);
        case 24:
          _context.next = 13;
          break;
        case 26:
          controllers.resolveNodesConflict([currentNode]);
        case 27:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function extactNodes(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
function destructureData(_x3, _x4, _x5) {
  return _destructureData.apply(this, arguments);
}
function _destructureData() {
  _destructureData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(type, path, data) {
    var options,
      byNodes,
      _a,
      _b,
      result,
      pathInfo,
      revision,
      added,
      modified,
      removed,
      editedNodes,
      removeNodes,
      controllers,
      parentPath,
      node,
      currentNode,
      _loop,
      i,
      sortNodes,
      _args6 = arguments;
    return _regeneratorRuntime().wrap(function _callee5$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          options = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : {
            maxInlineValueSize: 200
          };
          byNodes = _args6.length > 4 ? _args6[4] : undefined;
          result = (_a = options === null || options === void 0 ? void 0 : options.previous_result) !== null && _a !== void 0 ? _a : [];
          pathInfo = ivipbase_core_1.PathInfo.get(path);
          revision = (_b = options === null || options === void 0 ? void 0 : options.assert_revision) !== null && _b !== void 0 ? _b : ivipbase_core_1.ID.generate();
          options.assert_revision = revision;
          options.include_checks = typeof options.include_checks === "boolean" ? options.include_checks : true;
          added = [];
          modified = [];
          removed = [];
          byNodes = byNodes.map(function (node) {
            node.path = node.path.replace(/\/+$/g, "");
            return node;
          });
          if (["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(data)) !== true) {
            type = "UPDATE";
            data = _defineProperty({}, pathInfo.key, data);
            pathInfo = pathInfo.parent;
          }
          editedNodes = [];
          removeNodes = [];
          controllers = {
            appendEditedNode: function appendEditedNode(path) {
              var p = path instanceof ivipbase_core_1.PathInfo ? path : ivipbase_core_1.PathInfo.get(path);
              editedNodes.push(p);
              editedNodes = editedNodes.filter(function (p) {
                return !(p.isChildOf(path) || p.isDescendantOf(path));
              });
            },
            appendRemoveNode: function appendRemoveNode(path) {
              var p = path instanceof ivipbase_core_1.PathInfo ? path : ivipbase_core_1.PathInfo.get(path);
              removeNodes.push(p);
              removeNodes = removeNodes.filter(function (p) {
                return !(p.isChildOf(path) || p.isDescendantOf(path));
              });
            },
            findNode: function findNode(path) {
              if (!path) {
                return undefined;
              }
              var p = path instanceof ivipbase_core_1.PathInfo ? path : ivipbase_core_1.PathInfo.get(path);
              var isRemove = editedNodes.findIndex(function (path) {
                return p.isChildOf(path) || p.isDescendantOf(path);
              }) >= 0 || removeNodes.findIndex(function (path) {
                return p.equals(path) || p.isChildOf(path) || p.isDescendantOf(path);
              }) >= 0;
              var index = isRemove ? -1 : byNodes.findIndex(function (_ref2) {
                var path = _ref2.path;
                return p.equals(path);
              });
              return index >= 0 ? byNodes[index] : undefined;
            },
            pushAddedNode: function pushAddedNode(node) {
              return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                  while (1) switch (_context2.prev = _context2.next) {
                    case 0:
                      result.push(node);
                      added.push(node);
                    case 2:
                    case "end":
                      return _context2.stop();
                  }
                }, _callee2);
              }))();
            },
            pushRemovedNode: function pushRemovedNode(node) {
              var _this = this;
              return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      _this.appendRemoveNode(node.path);
                    case 1:
                    case "end":
                      return _context3.stop();
                  }
                }, _callee3);
              }))();
            },
            pushModifiedNode: function pushModifiedNode(node) {
              var _arguments = arguments;
              return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
                var isModified;
                return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                  while (1) switch (_context4.prev = _context4.next) {
                    case 0:
                      isModified = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : true;
                      if (isModified) {
                        modified.push(node);
                      }
                      result.push(node);
                    case 3:
                    case "end":
                      return _context4.stop();
                  }
                }, _callee4);
              }))();
            },
            resolveNodesConflict: function resolveNodesConflict(nodes) {
              var _a, _b, _c;
              for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                if (node.type !== "VERIFY" && (node.content.type === utils_1.nodeValueTypes.EMPTY || node.content.value === null || node.content.value === undefined)) {
                  removeNodes.push(ivipbase_core_1.PathInfo.get(node.path));
                  removeNodes = removeNodes.filter(function (p) {
                    return !(p.isChildOf(path) || p.isDescendantOf(path));
                  });
                  continue;
                }
                if (node.type === "SET") {
                  editedNodes.push(ivipbase_core_1.PathInfo.get(node.path));
                  editedNodes = editedNodes.filter(function (p) {
                    return !(p.isChildOf(path) || p.isDescendantOf(path));
                  });
                }
                var currentNode = this.findNode(node.path);
                if (node.type === "VERIFY") {
                  if (!currentNode) {
                    this.pushAddedNode(node);
                  }
                  continue;
                } else {
                  if (currentNode) {
                    var n = void 0;
                    if (node.type === "SET") {
                      n = Object.assign(Object.assign({}, node), {
                        previous_content: currentNode.content
                      });
                    } else {
                      n = {
                        path: node.path,
                        type: "UPDATE",
                        content: {
                          type: node.content.type,
                          value: null,
                          created: node.content.created,
                          modified: Date.now(),
                          revision: revision,
                          revision_nr: node.content.revision_nr + 1
                        },
                        previous_content: currentNode.content
                      };
                      if (n.content.type === utils_1.nodeValueTypes.OBJECT || n.content.type === utils_1.nodeValueTypes.ARRAY) {
                        n.content.value = Object.assign(Object.assign({}, _typeof(currentNode.content.value) === "object" ? (_a = currentNode.content.value) !== null && _a !== void 0 ? _a : {} : {}), _typeof(node.content.value) === "object" ? (_b = node.content.value) !== null && _b !== void 0 ? _b : {} : {});
                      } else {
                        n.content.value = node.content.value;
                      }
                    }
                    if (n) {
                      this.pushModifiedNode(n, JSON.stringify(n.content.value) !== JSON.stringify((_c = n.previous_content) === null || _c === void 0 ? void 0 : _c.value));
                    }
                  } else {
                    this.pushAddedNode(node);
                  }
                }
              }
            }
          };
          if (options.include_checks) {
            parentPath = pathInfo.parent;
            while (parentPath && parentPath.path.trim() !== "") {
              node = {
                path: parentPath.path,
                type: "VERIFY",
                content: {
                  type: typeof parentPath.key === "number" ? utils_1.nodeValueTypes.ARRAY : utils_1.nodeValueTypes.OBJECT,
                  value: {},
                  revision: revision,
                  revision_nr: 1,
                  created: Date.now(),
                  modified: Date.now()
                }
              };
              currentNode = controllers.findNode(node.path);
              if (!currentNode) {
                controllers.resolveNodesConflict([node]);
              }
              parentPath = parentPath.parent;
            }
          }
          _context6.next = 18;
          return extactNodes(type, data, pathInfo.keys, controllers, options, controllers.findNode(pathInfo.parent));
        case 18:
          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
            var node, p, isRemove;
            return _regeneratorRuntime().wrap(function _loop$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  node = byNodes[i];
                  p = ivipbase_core_1.PathInfo.get(node.path);
                  isRemove = editedNodes.findIndex(function (path) {
                    return p.isChildOf(path) || p.isDescendantOf(path);
                  }) >= 0 || removeNodes.findIndex(function (path) {
                    return p.equals(path) || p.isChildOf(path) || p.isDescendantOf(path);
                  }) >= 0;
                  if (!isRemove) {
                    _context5.next = 7;
                    break;
                  }
                  _context5.next = 6;
                  return new Promise(function (resolve) {
                    return setTimeout(resolve, 0);
                  });
                case 6:
                  removed.push(node);
                case 7:
                case "end":
                  return _context5.stop();
              }
            }, _loop);
          });
          i = 0;
        case 20:
          if (!(i < byNodes.length)) {
            _context6.next = 25;
            break;
          }
          return _context6.delegateYield(_loop(), "t0", 22);
        case 22:
          i++;
          _context6.next = 20;
          break;
        case 25:
          sortNodes = function sortNodes(a, b) {
            var aPath = ivipbase_core_1.PathInfo.get(a.path);
            var bPath = ivipbase_core_1.PathInfo.get(b.path);
            return aPath.isAncestorOf(bPath) || aPath.isParentOf(bPath) ? -1 : aPath.isDescendantOf(bPath) || aPath.isChildOf(bPath) ? 1 : 0;
          };
          result = result
          // .filter((n, i, l) => l.findIndex(({ path: p }) => PathInfo.get(p).equals(n.path)) === i)
          .map(modifyRevision(revision)).sort(sortNodes);
          added = added
          // .filter((n, i, l) => l.findIndex(({ path: p }) => PathInfo.get(p).equals(n.path)) === i)
          .map(modifyRevision(revision)).sort(sortNodes);
          modified = modified
          // .filter((n, i, l) => l.findIndex(({ path: p }) => PathInfo.get(p).equals(n.path)) === i)
          .map(modifyRevision(revision)).sort(sortNodes);
          removed = removed
          // .filter((n, i, l) => l.findIndex(({ path: p }) => PathInfo.get(p).equals(n.path)) === i)
          .map(modifyRevision(revision)).sort(sortNodes);
          // console.log("removed:", JSON.stringify(removed, null, 4));
          // console.log("RESULT:", path, JSON.stringify(result, null, 4));
          // console.log(path, JSON.stringify({ result, added, modified, removed }, null, 4));
          return _context6.abrupt("return", {
            result: result,
            added: added,
            modified: modified,
            removed: removed
          });
        case 31:
        case "end":
          return _context6.stop();
      }
    }, _callee5);
  }));
  return _destructureData.apply(this, arguments);
}
exports["default"] = destructureData;

},{"./utils":18,"ivipbase-core":152}],16:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MDESettings = exports.VALUE_TYPES = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var NodeInfo_1 = require("./NodeInfo");
var utils_1 = require("./utils");
Object.defineProperty(exports, "VALUE_TYPES", {
  enumerable: true,
  get: function get() {
    return utils_1.VALUE_TYPES;
  }
});
var structureNodes_1 = __importDefault(require("./structureNodes"));
var destructureData_1 = __importDefault(require("./destructureData"));
var utils_2 = require("../../../utils");
var DEBUG_MODE = false;
var NOOP = function NOOP() {};
/**
 * Representa as configurações de um MDE.
 */
var MDESettings = /*#__PURE__*/_createClass(
/**
 * Cria uma instância de MDESettings com as opções fornecidas.
 * @param options - Opções para configurar o node.
 */
function MDESettings(options) {
  _classCallCheck(this, MDESettings);
  /**
   * O prefixo associado ao armazenamento de dados. Por padrão, é "root".
   * @type {string}
   * @default "root"
   */
  this.prefix = "root";
  /**
   * Tamanho máximo, em bytes, dos dados filhos a serem armazenados em um registro pai
   * antes de serem movidos para um registro dedicado. O valor padrão é 50.
   * @type {number}
   * @default 50
   */
  this.maxInlineValueSize = 50;
  /**
   * Em vez de lançar erros em propriedades não definidas, esta opção permite
   * remover automaticamente as propriedades não definidas. O valor padrão é false.
   * @type {boolean}
   * @default false
   */
  this.removeVoidProperties = false;
  /**
   * @returns {Promise<any>}
   */
  this.commit = function () {};
  /**
   * @param reason
   */
  this.rollback = function () {};
  /**
   * Uma função que realiza um get/pesquisa de dados na base de dados com base em uma expressão regular resultada da propriedade pathToRegex em MDE.
   *
   * @type {((database: database: string, expression: {regex: RegExp, query: string[] }, simplifyValues?: boolean) => Promise<StorageNodeInfo[]> | StorageNodeInfo[]) | undefined}
   * @default undefined
   */
  this.getMultiple = function () {
    return [];
  };
  /**
   * Uma função que realiza um set de um node na base de dados com base em um path especificado.
   *
   * @type {(((path:string, content: StorageNode, node: StorageNodeInfo) => Promise<void> | void) | undefined}
   * @default undefined
   */
  this.setNode = function () {};
  /**
   * Uma função que realiza um remove de um node na base de dados com base em um path especificado.
   *
   * @type {(((path:string, content: StorageNode, node: StorageNodeInfo) => Promise<void> | void) | undefined}
   * @default undefined
   */
  this.removeNode = function () {};
  if (typeof options.prefix === "string" && options.prefix.trim() !== "") {
    this.prefix = options.prefix;
  }
  if (typeof options.maxInlineValueSize === "number") {
    this.maxInlineValueSize = options.maxInlineValueSize;
  }
  if (typeof options.removeVoidProperties === "boolean") {
    this.removeVoidProperties = options.removeVoidProperties;
  }
  if (typeof options.removeVoidProperties === "boolean") {
    this.removeVoidProperties = options.removeVoidProperties;
  }
  if (typeof options.commit === "function") {
    this.commit = options.commit;
  }
  if (typeof options.rollback === "function") {
    this.rollback = options.rollback;
  }
  this.getMultiple = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(database, reg) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof options.getMultiple === "function")) {
              _context.next = 4;
              break;
            }
            _context.next = 3;
            return Promise.race([options.getMultiple(database, reg)]).then(function (response) {
              return Promise.resolve(response !== null && response !== void 0 ? response : []);
            });
          case 3:
            return _context.abrupt("return", _context.sent);
          case 4:
            return _context.abrupt("return", []);
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  this.setNode = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(database, path, content, node) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            if (!(typeof options.setNode === "function")) {
              _context2.next = 3;
              break;
            }
            _context2.next = 3;
            return Promise.race([options.setNode(database, path, (0, utils_2.removeNulls)(content), (0, utils_2.removeNulls)(node))]);
          case 3:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function (_x3, _x4, _x5, _x6) {
      return _ref2.apply(this, arguments);
    };
  }();
  this.removeNode = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(database, path, content, node) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if (!(typeof options.removeNode === "function")) {
              _context3.next = 3;
              break;
            }
            _context3.next = 3;
            return Promise.race([options.removeNode(database, path, (0, utils_2.removeNulls)(content), (0, utils_2.removeNulls)(node))]);
          case 3:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return function (_x7, _x8, _x9, _x10) {
      return _ref3.apply(this, arguments);
    };
  }();
  if (typeof options.init === "function") {
    this.init = options.init;
  }
});
exports.MDESettings = MDESettings;
var MDE = /*#__PURE__*/function (_ivipbase_core_1$Simp) {
  function MDE() {
    var _this;
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, MDE);
    _this = _callSuper(this, MDE);
    _this._ready = false;
    _this.schemas = {};
    _this.settings = new MDESettings(options);
    _this._lastTid = 0;
    _this.on("ready", function () {
      _this._ready = true;
    });
    _this.init();
    return _this;
  }
  _inherits(MDE, _ivipbase_core_1$Simp);
  return _createClass(MDE, [{
    key: "createTid",
    value: function createTid() {
      return DEBUG_MODE ? ++this._lastTid : ivipbase_core_1.ID.generate();
    }
  }, {
    key: "debug",
    get: function get() {
      return new ivipbase_core_1.DebugLogger(undefined, "MDE");
    }
  }, {
    key: "init",
    value: function init() {
      if (typeof this.settings.init === "function") {
        this.settings.init.apply(this, []);
      }
    }
    /**
     * Aguarda o serviço estar pronto antes de executar o seu callback.
     * @param callback (opcional) função de retorno chamada quando o serviço estiver pronto para ser usado. Você também pode usar a promise retornada.
     * @returns retorna uma promise que resolve quando estiver pronto
     */
  }, {
    key: "ready",
    value: (function () {
      var _ready = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(callback) {
        var _this2 = this;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (this._ready) {
                _context4.next = 3;
                break;
              }
              _context4.next = 3;
              return new Promise(function (resolve) {
                return _this2.once("ready", resolve);
              });
            case 3:
              callback === null || callback === void 0 ? void 0 : callback();
            case 4:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function ready(_x11) {
        return _ready.apply(this, arguments);
      }
      return ready;
    }()
    /**
     * Converte um caminho em uma consulta de expressão regular e SQL LIKE pattern.
     *
     * @param {string} path - O caminho a ser convertido.
     * @param {boolean} [onlyChildren=false] - Se verdadeiro, exporta apenas os filhos do node especificado.
     * @param {boolean} [allHeirs=false] - Se verdadeiro, exporta todos os descendentes em relação ao path especificado.
     * @returns {{regex: RegExp, query: string[]}} - O objeto contendo a expressão regular e a query resultante.
     */
    )
  }, {
    key: "preparePathQuery",
    value: function preparePathQuery(path) {
      var onlyChildren = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var allHeirs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var includeAncestor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var pathsRegex = [];
      var querys = [];
      var pathsLike = [];
      path = path.replace(/(\/+)$/, "");
      /**
       * Substitui o caminho por uma expressão regular.
       * @param path - O caminho a ser convertido em expressão regular.
       * @returns {string} O caminho convertido em expressão regular.
       */
      var replasePathToRegex = function replasePathToRegex(path) {
        path = path.replace(/\/((\*)|(\$[^/\$]*))/g, "/([^/]*)");
        path = path.replace(/\[\*\]/g, "\\[(\\d+)\\]");
        path = path.replace(/\[(\d+)\]/g, "\\[$1\\]");
        return path;
      };
      /**
       * Substitui o caminho por um padrão SQL LIKE.
       * @param path - O caminho a ser convertido em um padrão SQL LIKE.
       * @returns {string} O caminho convertido em um padrão SQL LIKE.
       */
      var replacePathToLike = function replacePathToLike(path) {
        path = path.replace(/\/((\*)|(\$[^/\$]*))/g, "/%");
        path = path.replace(/\[\*\]/g, "[%]");
        path = path.replace(/\[(\d+)\]/g, "[$1]");
        return path;
      };
      // Adiciona a expressão regular do caminho principal ao array.
      pathsRegex.push(replasePathToRegex(path));
      // Adiciona o padrão SQL LIKE do caminho principal ao array.
      pathsLike.push(replacePathToLike(path).replace(/\/$/gi, ""));
      querys.push("LIKE '".concat(replacePathToLike(path).replace(/\/$/gi, ""), "'"));
      if (onlyChildren) {
        pathsRegex.forEach(function (exp) {
          return pathsRegex.push("".concat(exp, "(((/([^\\/\\[\\]]*))|(\\[([0-9]*)\\])){1})"));
        });
        pathsLike.forEach(function (exp) {
          return querys.push("LIKE '".concat(exp, "/%'"));
        });
        pathsLike.forEach(function (exp) {
          return pathsLike.push("".concat(exp, "/%"));
        });
      } else if (allHeirs === true) {
        pathsRegex.forEach(function (exp) {
          return pathsRegex.push("".concat(exp, "(((/([^\\/\\[\\]]*))|(\\[([0-9]*)\\])){1,})"));
        });
        pathsLike.forEach(function (exp) {
          return querys.push("LIKE '".concat(exp, "/%'"));
        });
        pathsLike.forEach(function (exp) {
          return pathsLike.push("".concat(exp, "/%"));
        });
      } else if (typeof allHeirs === "number") {
        pathsRegex.forEach(function (exp) {
          return pathsRegex.push("".concat(exp, "(((/([^\\/\\[\\]]*))|(\\[([0-9]*)\\])){1,").concat(allHeirs, "})"));
        });
        // pathsLike.forEach((exp) => querys.push(`LIKE '${exp}/%'`));
        // pathsLike.forEach((exp) => pathsLike.push(`${exp}/%`));
        var p = pathsLike;
        var m = "/%";
        for (var i = 0; i < allHeirs; i++) {
          p.forEach(function (exp) {
            return querys.push("LIKE '".concat(exp).concat(m, "'"));
          });
          p.forEach(function (exp) {
            return pathsLike.push("".concat(exp).concat(m));
          });
          m += "/%";
        }
      }
      var parent = ivipbase_core_1.PathInfo.get(path).parent;
      // Obtém o caminho pai e adiciona a expressão regular correspondente ao array.
      if (includeAncestor) {
        while (parent && parent.path.trim() !== "") {
          pathsRegex.push(replasePathToRegex(parent.path));
          pathsLike.push(replacePathToLike(parent.path).replace(/\/$/gi, ""));
          querys.push("LIKE '".concat(replacePathToLike(parent.path).replace(/\/$/gi, ""), "'"));
          parent = parent.parent;
        }
      } else if (parent) {
        pathsRegex.push(replasePathToRegex(parent.path));
        pathsLike.push(replacePathToLike(parent.path).replace(/\/$/gi, ""));
        querys.push("LIKE '".concat(replacePathToLike(parent.path).replace(/\/$/gi, ""), "'"));
      }
      // Cria a expressão regular completa combinando as expressões individuais no array.
      var fullRegex = new RegExp("^(".concat(pathsRegex.filter(function (p) {
        return p.trim() !== "";
      }).map(function (e) {
        return e.replace(/\/$/gi, "/?");
      }).join("$)|("), "$)"));
      return {
        regex: fullRegex,
        query: querys.filter(function (e, i, l) {
          return l.indexOf(e) === i && e !== "";
        })
      };
    }
    /**
     * Verifica se um caminho específico existe no nó.
     * @param {string} database - Nome do banco de dados.
     * @param path - O caminho a ser verificado.
     * @returns {Promise<boolean>} `true` se o caminho existir no nó, `false` caso contrário.
     */
  }, {
    key: "isPathExists",
    value: (function () {
      var _isPathExists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(database, path) {
        var nodeList, nodeSelected, key;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              path = ivipbase_core_1.PathInfo.get([this.settings.prefix, path]).path;
              _context5.next = 3;
              return this.getNodesBy(database, path, false, false).then(function (nodes) {
                return Promise.resolve(nodes.sort(function (_ref4, _ref5) {
                  var aM = _ref4.content.modified;
                  var bM = _ref5.content.modified;
                  return aM > bM ? -1 : aM < bM ? 1 : 0;
                }).filter(function (_ref6, i, l) {
                  var path = _ref6.path,
                    modified = _ref6.content.modified;
                  var indexRecent = l.findIndex(function (_ref7) {
                    var p = _ref7.path,
                      m = _ref7.content.modified;
                    return p === path && m > modified;
                  });
                  return indexRecent < 0 || indexRecent === i;
                }));
              });
            case 3:
              nodeList = _context5.sent;
              nodeSelected = nodeList.find(function (_ref8) {
                var p = _ref8.path;
                return ivipbase_core_1.PathInfo.get(p).equals(path) || ivipbase_core_1.PathInfo.get(p).isParentOf(path);
              });
              if (nodeSelected) {
                _context5.next = 9;
                break;
              }
              return _context5.abrupt("return", false);
            case 9:
              if (!ivipbase_core_1.PathInfo.get(nodeSelected.path).isParentOf(path)) {
                _context5.next = 12;
                break;
              }
              key = ivipbase_core_1.PathInfo.get(path).key;
              return _context5.abrupt("return", key !== null && nodeSelected.content.type === utils_1.nodeValueTypes.OBJECT && Object.keys(nodeSelected.content.value).includes(key));
            case 12:
              return _context5.abrupt("return", ivipbase_core_1.PathInfo.get(nodeSelected.path).equals(path));
            case 13:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function isPathExists(_x12, _x13) {
        return _isPathExists.apply(this, arguments);
      }
      return isPathExists;
    }()
    /**
     * Obtém uma lista de nodes com base em um caminho e opções adicionais.
     *
     * @param {string} database - Nome do banco de dados.
     * @param {string} path - O caminho a ser usado para filtrar os nodes.
     * @param {boolean} [onlyChildren=false] - Se verdadeiro, exporta apenas os filhos do node especificado.
     * @param {boolean} [allHeirs=false] - Se verdadeiro, exporta todos os descendentes em relação ao path especificado.
     * @returns {Promise<StorageNodeInfo[]>} - Uma Promise que resolve para uma lista de informações sobre os nodes.
     * @throws {Error} - Lança um erro se ocorrer algum problema durante a busca assíncrona.
     */
    )
  }, {
    key: "getNodesBy",
    value: (function () {
      var _getNodesBy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(database, path) {
        var onlyChildren,
          allHeirs,
          includeAncestor,
          simplifyValues,
          expression,
          result,
          pathInfo,
          mainNode,
          parentNode,
          isMainChild,
          _args6 = arguments;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              onlyChildren = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : false;
              allHeirs = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : false;
              includeAncestor = _args6.length > 4 && _args6[4] !== undefined ? _args6[4] : false;
              simplifyValues = _args6.length > 5 && _args6[5] !== undefined ? _args6[5] : false;
              expression = this.preparePathQuery(path, onlyChildren, allHeirs, includeAncestor); // console.log("getNodesBy::1::", reg.source);
              result = [];
              _context6.prev = 6;
              _context6.next = 9;
              return this.settings.getMultiple(database, expression, simplifyValues);
            case 9:
              result = _context6.sent;
              _context6.next = 14;
              break;
            case 12:
              _context6.prev = 12;
              _context6.t0 = _context6["catch"](6);
            case 14:
              // console.log("getNodesBy::2::", JSON.stringify(result, null, 4));
              pathInfo = ivipbase_core_1.PathInfo.get(path);
              mainNode = result.find(function (_ref9) {
                var p = _ref9.path;
                return ivipbase_core_1.PathInfo.get(p).equals(path);
              });
              parentNode = result.find(function (_ref10) {
                var p = _ref10.path;
                return ivipbase_core_1.PathInfo.get(p).isParentOf(path);
              });
              isMainChild = !mainNode && parentNode;
              return _context6.abrupt("return", result.filter(function (_ref11) {
                var p = _ref11.path,
                  content = _ref11.content;
                var path = ivipbase_core_1.PathInfo.get(p);
                var includes = true;
                if (isMainChild) {
                  includes = path.isParentOf(pathInfo);
                } else if (onlyChildren) {
                  includes = pathInfo.equals(p) || pathInfo.isParentOf(p);
                } else if (allHeirs === true || typeof allHeirs === "number") {
                  includes = pathInfo.equals(p) || pathInfo.isParentOf(p) || pathInfo.isAncestorOf(p);
                }
                if (!includes && includeAncestor) {
                  includes = path.isParentOf(pathInfo) || path.isAncestorOf(pathInfo);
                }
                return includes && content.type !== utils_1.nodeValueTypes.EMPTY && content.value !== null && content.value !== undefined;
              }));
            case 19:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[6, 12]]);
      }));
      function getNodesBy(_x14, _x15) {
        return _getNodesBy.apply(this, arguments);
      }
      return getNodesBy;
    }()
    /**
     * Obtém o node pai de um caminho específico.
     * @param {string} database - Nome do banco de dados.
     * @param path - O caminho para o qual o node pai deve ser obtido.
     * @returns {Promise<StorageNodeInfo | undefined>} O node pai correspondente ao caminho ou `undefined` se não for encontrado.
     */
    )
  }, {
    key: "getNodeParentBy",
    value: (function () {
      var _getNodeParentBy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(database, path) {
        var pathInfo, nodes;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              pathInfo = ivipbase_core_1.PathInfo.get(path);
              _context7.next = 3;
              return this.getNodesBy(database, path, false);
            case 3:
              nodes = _context7.sent;
              return _context7.abrupt("return", nodes.filter(function (node) {
                var nodePath = ivipbase_core_1.PathInfo.get(node.path);
                return nodePath.path === "" || pathInfo.path === nodePath.path || nodePath.isParentOf(pathInfo);
              }).sort(function (a, b) {
                var pathA = ivipbase_core_1.PathInfo.get(a.path);
                var pathB = ivipbase_core_1.PathInfo.get(b.path);
                return pathA.isDescendantOf(pathB.path) ? -1 : pathB.isDescendantOf(pathA.path) ? 1 : 0;
              }).shift());
            case 5:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function getNodeParentBy(_x16, _x17) {
        return _getNodeParentBy.apply(this, arguments);
      }
      return getNodeParentBy;
    }()
    /**
     * Obtém informações personalizadas sobre um node com base no caminho especificado.
     *
     * @param {string} database - Nome do banco de dados.
     * @param {string} path - O caminho do node para o qual as informações devem ser obtidas.
     * @returns {CustomStorageNodeInfo} - Informações personalizadas sobre o node especificado.
     */
    )
  }, {
    key: "getInfoBy",
    value: (function () {
      var _getInfoBy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(database, path) {
        var options,
          _a,
          _b,
          _c,
          _d,
          _options$include_chil,
          include_child_count,
          _options$include_pref,
          include_prefix,
          cache_nodes,
          pathInfo,
          mainPath,
          nodes,
          egualsNode,
          parentNode,
          mainNode,
          defaultNode,
          content,
          value,
          containsChild,
          isArrayChild,
          info,
          _args8 = arguments;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              options = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : {};
              _options$include_chil = options.include_child_count, include_child_count = _options$include_chil === void 0 ? true : _options$include_chil, _options$include_pref = options.include_prefix, include_prefix = _options$include_pref === void 0 ? true : _options$include_pref, cache_nodes = options.cache_nodes;
              pathInfo = include_prefix ? ivipbase_core_1.PathInfo.get([this.settings.prefix, path]) : ivipbase_core_1.PathInfo.get(path);
              mainPath = include_prefix ? pathInfo.path.replace(this.settings.prefix + "/", "") : pathInfo.path;
              _context8.next = 6;
              return this.getNodesBy(database, pathInfo.path, true, false);
            case 6:
              nodes = _context8.sent;
              egualsNode = nodes.find(function (_ref12) {
                var p = _ref12.path;
                return ivipbase_core_1.PathInfo.get(p).equals(pathInfo.path);
              });
              parentNode = nodes.find(function (_ref13) {
                var p = _ref13.path;
                return ivipbase_core_1.PathInfo.get(p).isParentOf(pathInfo.path);
              });
              mainNode = egualsNode !== null && egualsNode !== void 0 ? egualsNode : parentNode;
              defaultNode = new NodeInfo_1.CustomStorageNodeInfo({
                path: mainPath,
                key: typeof pathInfo.key === "string" ? pathInfo.key : undefined,
                index: typeof pathInfo.key === "number" ? pathInfo.key : undefined,
                type: 0,
                exists: false,
                address: undefined,
                created: new Date(),
                modified: new Date(),
                revision: "",
                revision_nr: 0
              });
              if (mainNode) {
                _context8.next = 13;
                break;
              }
              return _context8.abrupt("return", defaultNode);
            case 13:
              content = (0, utils_1.processReadNodeValue)(mainNode.content);
              value = content.value;
              if (pathInfo.isChildOf(mainNode.path) && pathInfo.key) {
                if ([utils_1.nodeValueTypes.OBJECT, utils_1.nodeValueTypes.ARRAY].includes(mainNode.content.type)) {
                  if (Object.keys(value).includes(pathInfo.key)) {
                    value = value[pathInfo.key];
                  } else {
                    value = null;
                  }
                } else {
                  value = null;
                }
              }
              containsChild = nodes.findIndex(function (_ref14) {
                var p = _ref14.path;
                return pathInfo.isParentOf(p);
              }) >= 0;
              isArrayChild = !containsChild && mainNode.content.type === utils_1.nodeValueTypes.ARRAY;
              info = new NodeInfo_1.CustomStorageNodeInfo({
                path: mainPath,
                key: typeof pathInfo.key === "string" ? pathInfo.key : typeof pathInfo.key !== "number" ? "" : undefined,
                index: typeof pathInfo.key === "number" ? pathInfo.key : undefined,
                type: value !== null ? (0, utils_1.getValueType)(value) : containsChild ? isArrayChild ? utils_1.VALUE_TYPES.ARRAY : utils_1.VALUE_TYPES.OBJECT : 0,
                exists: value !== null || containsChild,
                address: new NodeInfo_1.NodeAddress(mainPath),
                created: (_a = new Date(content.created)) !== null && _a !== void 0 ? _a : new Date(),
                modified: (_b = new Date(content.modified)) !== null && _b !== void 0 ? _b : new Date(),
                revision: (_c = content.revision) !== null && _c !== void 0 ? _c : "",
                revision_nr: (_d = content.revision_nr) !== null && _d !== void 0 ? _d : 0
              });
              info.value = value !== null || value !== undefined ? value : null;
              // if (!PathInfo.get(mainNode.path).equals(pathInfo.path)) {
              // 	info.value = (typeof info.key === "string" ? info.value[info.key] : typeof info.index === "number" ? info.value[info.index] : null) ?? null;
              // }
              if (include_child_count && (containsChild || isArrayChild)) {
                info.childCount = nodes.reduce(function (c, _ref15) {
                  var p = _ref15.path;
                  return c + (pathInfo.isParentOf(p) ? 1 : 0);
                }, Object.keys(info.value).length);
              }
              if (info.value !== null && ["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(info.value))) {
                info.value = Object.fromEntries(Object.entries(info.value).sort(function (a, b) {
                  var key1 = a[0].toString();
                  var key2 = b[0].toString();
                  return key1.startsWith("__") && !key2.startsWith("__") ? 1 : !key1.startsWith("__") && key2.startsWith("__") ? -1 : key1 > key2 ? 1 : key1 < key2 ? -1 : 0;
                }));
              }
              return _context8.abrupt("return", info);
            case 23:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function getInfoBy(_x18, _x19) {
        return _getInfoBy.apply(this, arguments);
      }
      return getInfoBy;
    }())
  }, {
    key: "getChildren",
    value: function getChildren(database, path) {
      var _this3 = this;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var pathInfo = ivipbase_core_1.PathInfo.get([this.settings.prefix, path]);
      var next = /*#__PURE__*/function () {
        var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(callback) {
          var _a, _b, _c, nodes, mainNode, isContinue, isArray, value, keys, childNodes, _iterator, _step, node, _key, key, info;
          return _regeneratorRuntime().wrap(function _callee9$(_context9) {
            while (1) switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return _this3.getNodesBy(database, pathInfo.path, true, false);
              case 2:
                nodes = _context9.sent;
                mainNode = nodes.find(function (_ref17) {
                  var p = _ref17.path;
                  return ivipbase_core_1.PathInfo.get(p).equals(pathInfo.path);
                });
                isContinue = true;
                if (!(!mainNode || ![utils_1.VALUE_TYPES.OBJECT, utils_1.VALUE_TYPES.ARRAY].includes((_a = mainNode.content.type) !== null && _a !== void 0 ? _a : -1))) {
                  _context9.next = 7;
                  break;
                }
                return _context9.abrupt("return");
              case 7:
                isArray = mainNode.content.type === utils_1.VALUE_TYPES.ARRAY;
                value = mainNode.content.value;
                keys = Object.keys(value).map(function (key) {
                  return isArray ? parseInt(key) : key;
                });
                if (options.keyFilter) {
                  keys = keys.filter(function (key) {
                    return options.keyFilter.includes(key);
                  });
                }
                keys.length > 0 && keys.every(function (key) {
                  var _a;
                  var child = (0, utils_1.getTypeFromStoredValue)(value[key]);
                  var info = new NodeInfo_1.CustomStorageNodeInfo({
                    path: pathInfo.childPath(key).replace(_this3.settings.prefix + "/", ""),
                    key: isArray ? undefined : key,
                    index: isArray ? key : undefined,
                    type: child.type,
                    address: null,
                    exists: true,
                    value: child.value,
                    revision: mainNode.content.revision,
                    revision_nr: mainNode.content.revision_nr,
                    created: new Date(mainNode.content.created),
                    modified: new Date(mainNode.content.modified)
                  });
                  isContinue = (_a = callback(info)) !== null && _a !== void 0 ? _a : true;
                  return isContinue; // stop .every loop if canceled
                });
                if (isContinue) {
                  _context9.next = 14;
                  break;
                }
                return _context9.abrupt("return");
              case 14:
                childNodes = nodes.filter(function (node) {
                  return !(pathInfo.equals(node.path) || !pathInfo.isParentOf(node.path));
                }).sort(function (a, b) {
                  var _a, _b;
                  var key1 = ((_a = ivipbase_core_1.PathInfo.get(a.path).key) !== null && _a !== void 0 ? _a : a.path).toString();
                  var key2 = ((_b = ivipbase_core_1.PathInfo.get(b.path).key) !== null && _b !== void 0 ? _b : b.path).toString();
                  return key1.startsWith("__") && !key2.startsWith("__") ? 1 : !key1.startsWith("__") && key2.startsWith("__") ? -1 : key1 > key2 ? 1 : key1 < key2 ? -1 : 0;
                });
                _iterator = _createForOfIteratorHelper(childNodes);
                _context9.prev = 16;
                _iterator.s();
              case 18:
                if ((_step = _iterator.n()).done) {
                  _context9.next = 33;
                  break;
                }
                node = _step.value;
                if (isContinue) {
                  _context9.next = 22;
                  break;
                }
                return _context9.abrupt("break", 33);
              case 22:
                if (!(pathInfo.equals(node.path) || !pathInfo.isParentOf(node.path))) {
                  _context9.next = 24;
                  break;
                }
                return _context9.abrupt("continue", 31);
              case 24:
                if (!options.keyFilter) {
                  _context9.next = 28;
                  break;
                }
                _key = ivipbase_core_1.PathInfo.get(node.path).key;
                if (!options.keyFilter.includes(_key !== null && _key !== void 0 ? _key : "")) {
                  _context9.next = 28;
                  break;
                }
                return _context9.abrupt("continue", 31);
              case 28:
                key = ivipbase_core_1.PathInfo.get(node.path).key;
                info = new NodeInfo_1.CustomStorageNodeInfo({
                  path: node.path.replace(_this3.settings.prefix + "/", ""),
                  type: node.content.type,
                  key: isArray ? undefined : (_b = key) !== null && _b !== void 0 ? _b : "",
                  index: isArray ? key : undefined,
                  address: new NodeInfo_1.NodeAddress(node.path),
                  exists: true,
                  value: null,
                  // not loaded
                  revision: node.content.revision,
                  revision_nr: node.content.revision_nr,
                  created: new Date(node.content.created),
                  modified: new Date(node.content.modified)
                });
                isContinue = (_c = callback(info)) !== null && _c !== void 0 ? _c : true;
              case 31:
                _context9.next = 18;
                break;
              case 33:
                _context9.next = 38;
                break;
              case 35:
                _context9.prev = 35;
                _context9.t0 = _context9["catch"](16);
                _iterator.e(_context9.t0);
              case 38:
                _context9.prev = 38;
                _iterator.f();
                return _context9.finish(38);
              case 41:
              case "end":
                return _context9.stop();
            }
          }, _callee9, null, [[16, 35, 38, 41]]);
        }));
        return function next(_x20) {
          return _ref16.apply(this, arguments);
        };
      }();
      return {
        next: next
      };
    }
  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(database, path, options) {
        var _a, _b, include_info_node, onlyChildren, _options, nodes, main_node, value;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _b = options !== null && options !== void 0 ? options : {}, include_info_node = _b.include_info_node, onlyChildren = _b.onlyChildren, _options = __rest(_b, ["include_info_node", "onlyChildren"]);
              path = ivipbase_core_1.PathInfo.get([this.settings.prefix, path]).path;
              _context10.next = 4;
              return this.getNodesBy(database, path, onlyChildren, true);
            case 4:
              nodes = _context10.sent;
              main_node = nodes.find(function (_ref18) {
                var p = _ref18.path;
                return ivipbase_core_1.PathInfo.get(p).equals(path) || ivipbase_core_1.PathInfo.get(p).isParentOf(path);
              });
              if (main_node) {
                _context10.next = 8;
                break;
              }
              return _context10.abrupt("return", undefined);
            case 8:
              // console.log(JSON.stringify(nodes, null, 4));
              value = (_a = (0, utils_2.removeNulls)((0, structureNodes_1["default"])(path, nodes, _options))) !== null && _a !== void 0 ? _a : null;
              return _context10.abrupt("return", !include_info_node ? value : Object.assign(Object.assign({}, main_node.content), {
                value: value
              }));
            case 10:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function get(_x21, _x22, _x23) {
        return _get.apply(this, arguments);
      }
      return get;
    }()
    /**
     * Define um valor no armazenamento com o caminho especificado.
     *
     * @param {string} database - Nome do banco de dados.
     * @param {string} path - O caminho do node a ser definido.
     * @param {any} value - O valor a ser armazenado em nodes.
     * @param {Object} [options] - Opções adicionais para controlar o comportamento da definição.
     * @param {string} [options.assert_revision] - Uma string que representa a revisão associada ao node, se necessário.
     * @returns {Promise<void>}
     */
  }, {
    key: "set",
    value: (function () {
      var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(database, path, value) {
        var _this4 = this;
        var options,
          type,
          _a,
          suppress_events,
          batchError,
          promises,
          byNodes,
          _yield,
          added,
          modified,
          removed,
          result,
          _iterator2,
          _step2,
          _loop,
          _iterator3,
          _step3,
          _loop2,
          _iterator4,
          _step4,
          _loop3,
          _i,
          _promises,
          p,
          _args17 = arguments;
        return _regeneratorRuntime().wrap(function _callee14$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              options = _args17.length > 3 && _args17[3] !== undefined ? _args17[3] : {};
              type = _args17.length > 4 && _args17[4] !== undefined ? _args17[4] : "SET";
              type = _typeof(value) !== "object" || value instanceof Array || value instanceof ArrayBuffer || value instanceof Date ? "UPDATE" : type;
              path = ivipbase_core_1.PathInfo.get([this.settings.prefix, path]).path;
              suppress_events = options.suppress_events === true;
              batchError = [];
              promises = [];
              _context17.next = 9;
              return this.getNodesBy(database, path, false, true, true);
            case 9:
              byNodes = _context17.sent;
              _context17.next = 12;
              return (0, destructureData_1["default"])(type, path, value, Object.assign(Object.assign({}, options !== null && options !== void 0 ? options : {}), this.settings), byNodes);
            case 12:
              _yield = _context17.sent;
              added = _yield.added;
              modified = _yield.modified;
              removed = _yield.removed;
              result = _yield.result;
              //console.log("now", JSON.stringify(nodes.find((node) => node.path === "root/test") ?? {}, null, 4));
              // const { added, modified, removed } = await prepareMergeNodes(path, byNodes, nodes);
              // console.log(JSON.stringify(modified, null, 4));
              // console.log(type, JSON.stringify(result, null, 4));
              // console.log("set-added", JSON.stringify(added, null, 4));
              // console.log("set-modified", JSON.stringify(modified, null, 4));
              // console.log("set-removed", JSON.stringify(removed, null, 4));
              _iterator2 = _createForOfIteratorHelper(removed);
              _context17.prev = 18;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var node;
                return _regeneratorRuntime().wrap(function _loop$(_context12) {
                  while (1) switch (_context12.prev = _context12.next) {
                    case 0:
                      node = _step2.value;
                      if (!suppress_events) {
                        _this4.emit("remove", {
                          dbName: database,
                          name: "remove",
                          path: ivipbase_core_1.PathInfo.get(ivipbase_core_1.PathInfo.get(node.path).keys.slice(1)).path,
                          value: (0, utils_2.removeNulls)(node.content.value)
                        });
                      }
                      promises.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
                        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                          while (1) switch (_context11.prev = _context11.next) {
                            case 0:
                              _context11.prev = 0;
                              _context11.next = 3;
                              return Promise.race([_this4.settings.removeNode(database, node.path, node.content, node)])["catch"](function (e) {
                                batchError.push({
                                  path: node.path,
                                  content: Object.assign(Object.assign({}, node.content), {
                                    type: 0,
                                    value: null
                                  })
                                });
                              });
                            case 3:
                              _context11.next = 7;
                              break;
                            case 5:
                              _context11.prev = 5;
                              _context11.t0 = _context11["catch"](0);
                            case 7:
                            case "end":
                              return _context11.stop();
                          }
                        }, _callee11, null, [[0, 5]]);
                      })));
                    case 3:
                    case "end":
                      return _context12.stop();
                  }
                }, _loop);
              });
              _iterator2.s();
            case 21:
              if ((_step2 = _iterator2.n()).done) {
                _context17.next = 25;
                break;
              }
              return _context17.delegateYield(_loop(), "t0", 23);
            case 23:
              _context17.next = 21;
              break;
            case 25:
              _context17.next = 30;
              break;
            case 27:
              _context17.prev = 27;
              _context17.t1 = _context17["catch"](18);
              _iterator2.e(_context17.t1);
            case 30:
              _context17.prev = 30;
              _iterator2.f();
              return _context17.finish(30);
            case 33:
              _iterator3 = _createForOfIteratorHelper(modified);
              _context17.prev = 34;
              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
                var node;
                return _regeneratorRuntime().wrap(function _loop2$(_context14) {
                  while (1) switch (_context14.prev = _context14.next) {
                    case 0:
                      node = _step3.value;
                      if (!suppress_events) {
                        _this4.emit("change", {
                          dbName: database,
                          name: "change",
                          path: ivipbase_core_1.PathInfo.get(ivipbase_core_1.PathInfo.get(node.path).keys.slice(1)).path,
                          value: (0, utils_2.removeNulls)(node.content.value),
                          previous: (0, utils_2.removeNulls)((_a = node.previous_content) === null || _a === void 0 ? void 0 : _a.value)
                        });
                      }
                      promises.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
                        return _regeneratorRuntime().wrap(function _callee12$(_context13) {
                          while (1) switch (_context13.prev = _context13.next) {
                            case 0:
                              _context13.prev = 0;
                              _context13.next = 3;
                              return Promise.race([_this4.settings.setNode(database, node.path, (0, utils_2.removeNulls)(node.content), (0, utils_2.removeNulls)(node))])["catch"](function (e) {
                                batchError.push(node);
                              });
                            case 3:
                              _context13.next = 7;
                              break;
                            case 5:
                              _context13.prev = 5;
                              _context13.t0 = _context13["catch"](0);
                            case 7:
                            case "end":
                              return _context13.stop();
                          }
                        }, _callee12, null, [[0, 5]]);
                      })));
                    case 3:
                    case "end":
                      return _context14.stop();
                  }
                }, _loop2);
              });
              _iterator3.s();
            case 37:
              if ((_step3 = _iterator3.n()).done) {
                _context17.next = 41;
                break;
              }
              return _context17.delegateYield(_loop2(), "t2", 39);
            case 39:
              _context17.next = 37;
              break;
            case 41:
              _context17.next = 46;
              break;
            case 43:
              _context17.prev = 43;
              _context17.t3 = _context17["catch"](34);
              _iterator3.e(_context17.t3);
            case 46:
              _context17.prev = 46;
              _iterator3.f();
              return _context17.finish(46);
            case 49:
              _iterator4 = _createForOfIteratorHelper(added);
              _context17.prev = 50;
              _loop3 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop3() {
                var node;
                return _regeneratorRuntime().wrap(function _loop3$(_context16) {
                  while (1) switch (_context16.prev = _context16.next) {
                    case 0:
                      node = _step4.value;
                      if (!suppress_events) {
                        _this4.emit("add", {
                          dbName: database,
                          name: "add",
                          path: ivipbase_core_1.PathInfo.get(ivipbase_core_1.PathInfo.get(node.path).keys.slice(1)).path,
                          value: (0, utils_2.removeNulls)(node.content.value)
                        });
                      }
                      promises.push( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
                        return _regeneratorRuntime().wrap(function _callee13$(_context15) {
                          while (1) switch (_context15.prev = _context15.next) {
                            case 0:
                              _context15.prev = 0;
                              _context15.next = 3;
                              return Promise.race([_this4.settings.setNode(database, node.path, (0, utils_2.removeNulls)(node.content), (0, utils_2.removeNulls)(node))])["catch"](function (e) {
                                batchError.push(node);
                              });
                            case 3:
                              _context15.next = 7;
                              break;
                            case 5:
                              _context15.prev = 5;
                              _context15.t0 = _context15["catch"](0);
                            case 7:
                            case "end":
                              return _context15.stop();
                          }
                        }, _callee13, null, [[0, 5]]);
                      })));
                    case 3:
                    case "end":
                      return _context16.stop();
                  }
                }, _loop3);
              });
              _iterator4.s();
            case 53:
              if ((_step4 = _iterator4.n()).done) {
                _context17.next = 57;
                break;
              }
              return _context17.delegateYield(_loop3(), "t4", 55);
            case 55:
              _context17.next = 53;
              break;
            case 57:
              _context17.next = 62;
              break;
            case 59:
              _context17.prev = 59;
              _context17.t5 = _context17["catch"](50);
              _iterator4.e(_context17.t5);
            case 62:
              _context17.prev = 62;
              _iterator4.f();
              return _context17.finish(62);
            case 65:
              _i = 0, _promises = promises;
            case 66:
              if (!(_i < _promises.length)) {
                _context17.next = 80;
                break;
              }
              p = _promises[_i];
              _context17.next = 70;
              return new Promise(function (resolve) {
                return setTimeout(resolve, 0);
              });
            case 70:
              _context17.prev = 70;
              _context17.next = 73;
              return p();
            case 73:
              _context17.next = 77;
              break;
            case 75:
              _context17.prev = 75;
              _context17.t6 = _context17["catch"](70);
            case 77:
              _i++;
              _context17.next = 66;
              break;
            case 80:
            case "end":
              return _context17.stop();
          }
        }, _callee14, this, [[18, 27, 30, 33], [34, 43, 46, 49], [50, 59, 62, 65], [70, 75]]);
      }));
      function set(_x24, _x25, _x26) {
        return _set.apply(this, arguments);
      }
      return set;
    }())
  }, {
    key: "update",
    value: function () {
      var _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(database, path, value) {
        var options,
          _args18 = arguments;
        return _regeneratorRuntime().wrap(function _callee15$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              options = _args18.length > 3 && _args18[3] !== undefined ? _args18[3] : {};
              _context18.next = 3;
              return this.set(database, path, value, options, "UPDATE");
            case 3:
            case "end":
              return _context18.stop();
          }
        }, _callee15, this);
      }));
      function update(_x27, _x28, _x29) {
        return _update.apply(this, arguments);
      }
      return update;
    }()
    /**
     * Atualiza um nó obtendo seu valor, executando uma função de retorno de chamada que transforma
     * o valor atual e retorna o novo valor a ser armazenado. Garante que o valor lido
     * não mude enquanto a função de retorno de chamada é executada, ou executa a função de retorno de chamada novamente se isso acontecer.
     * @param database nome do banco de dados
     * @param path caminho
     * @param callback função que transforma o valor atual e retorna o novo valor a ser armazenado. Pode retornar uma Promise
     * @param options opções opcionais usadas pela implementação para chamadas recursivas
     * @returns Retorna um novo cursor se o registro de transação estiver habilitado
     */
  }, {
    key: "transact",
    value: (function () {
      var _transact = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(database, path, callback) {
        var _this5 = this;
        var options,
          _a,
          _b,
          useFakeLock,
          tid,
          lock,
          node,
          checkRevision,
          newValue,
          cursor,
          _args19 = arguments;
        return _regeneratorRuntime().wrap(function _callee16$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              options = _args19.length > 3 && _args19[3] !== undefined ? _args19[3] : {
                no_lock: false,
                suppress_events: false,
                context: undefined
              };
              useFakeLock = options && options.no_lock === true;
              tid = this.createTid(); // const lock = useFakeLock
              //     ? { tid, release: NOOP } // Trava falsa, vamos usar verificação de revisão e tentativas novamente em vez disso
              //     : await this.nodeLocker.lock(path, tid, true, 'transactNode');
              lock = {
                tid: tid,
                release: NOOP
              };
              _context19.prev = 4;
              _context19.next = 7;
              return this.get(database, path, {
                include_info_node: true
              });
            case 7:
              node = _context19.sent;
              checkRevision = (_a = node === null || node === void 0 ? void 0 : node.revision) !== null && _a !== void 0 ? _a : ivipbase_core_1.ID.generate();
              _context19.prev = 9;
              _context19.next = 12;
              return Promise.race([callback((_b = node === null || node === void 0 ? void 0 : node.value) !== null && _b !== void 0 ? _b : null)])["catch"](function (err) {
                _this5.debug.error("Error in transaction callback: ".concat(err.message));
              });
            case 12:
              newValue = _context19.sent;
              _context19.next = 18;
              break;
            case 15:
              _context19.prev = 15;
              _context19.t0 = _context19["catch"](9);
              this.debug.error("Error in transaction callback: ".concat(_context19.t0.message));
            case 18:
              if (!(typeof newValue === "undefined")) {
                _context19.next = 20;
                break;
              }
              return _context19.abrupt("return");
            case 20:
              _context19.next = 22;
              return this.update(database, path, newValue, {
                assert_revision: checkRevision,
                tid: lock.tid,
                suppress_events: options.suppress_events,
                context: options.context
              });
            case 22:
              cursor = _context19.sent;
              return _context19.abrupt("return", cursor);
            case 26:
              _context19.prev = 26;
              _context19.t1 = _context19["catch"](4);
              throw _context19.t1;
            case 29:
              _context19.prev = 29;
              lock.release();
              return _context19.finish(29);
            case 32:
            case "end":
              return _context19.stop();
          }
        }, _callee16, this, [[4, 26, 29, 32], [9, 15]]);
      }));
      function transact(_x30, _x31, _x32) {
        return _transact.apply(this, arguments);
      }
      return transact;
    }())
  }, {
    key: "byPrefix",
    value: function byPrefix(prefix) {
      return Object.assign(Object.assign({}, this), {
        prefix: prefix
      });
    }
    /**
     * Adiciona, atualiza ou remove uma definição de esquema para validar os valores do nó antes que sejam armazenados no caminho especificado
     * @param database nome do banco de dados
     * @param path caminho de destino para impor o esquema, pode incluir curingas. Ex: 'users/*\/posts/*' ou 'users/$uid/posts/$postid'
     * @param schema definições de tipo de esquema. Quando um valor nulo é passado, um esquema previamente definido é removido.
     */
  }, {
    key: "setSchema",
    value: function setSchema(database, path, schema) {
      var _this6 = this;
      var warnOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var _a;
      var schemas = (_a = this.schemas[database]) !== null && _a !== void 0 ? _a : this.schemas[database] = [];
      if (typeof schema === "undefined") {
        throw new TypeError("schema argument must be given");
      }
      if (schema === null) {
        // Remove o esquema previamente definido no caminho
        var i = schemas.findIndex(function (s) {
          return s.path === path;
        });
        i >= 0 && schemas.splice(i, 1);
        return;
      }
      // Analise o esquema, adicione ou atualize-o
      var definition = new ivipbase_core_1.SchemaDefinition(schema, {
        warnOnly: warnOnly,
        warnCallback: function warnCallback(message) {
          return _this6.debug.warn(message);
        }
      });
      var item = schemas.find(function (s) {
        return s.path === path;
      });
      if (item) {
        item.schema = definition;
      } else {
        schemas.push({
          path: path,
          schema: definition
        });
        schemas.sort(function (a, b) {
          var ka = ivipbase_core_1.PathInfo.getPathKeys(a.path),
            kb = ivipbase_core_1.PathInfo.getPathKeys(b.path);
          if (ka.length === kb.length) {
            return 0;
          }
          return ka.length < kb.length ? -1 : 1;
        });
      }
      this.schemas[database] = schemas;
    }
    /**
     * Obtém a definição de esquema atualmente ativa para o caminho especificado
     */
  }, {
    key: "getSchema",
    value: function getSchema(database, path) {
      var _a;
      var schemas = (_a = this.schemas[database]) !== null && _a !== void 0 ? _a : this.schemas[database] = [];
      var item = schemas.find(function (item) {
        return item.path === path;
      });
      return item ? {
        path: path,
        schema: item.schema.source,
        text: item.schema.text
      } : {
        path: path,
        schema: {},
        text: ""
      };
    }
    /**
     * Obtém todas as definições de esquema atualmente ativas
     */
  }, {
    key: "getSchemas",
    value: function getSchemas(database) {
      var _a;
      var schemas = (_a = this.schemas[database]) !== null && _a !== void 0 ? _a : this.schemas[database] = [];
      return schemas.map(function (item) {
        return {
          path: item.path,
          schema: item.schema.source,
          text: item.schema.text
        };
      });
    }
    /**
     * Valida os esquemas do nó que está sendo atualizado e de seus filhos
     * @param database nome do banco de dados
     * @param path caminho sendo gravado
     * @param value o novo valor, ou atualizações para o valor atual
     * @example
     * // defina o esquema para cada tag de cada post do usuário:
     * db.schema.set(
     *  'root',
     *  'users/$uid/posts/$postId/tags/$tagId',
     *  { name: 'string', 'link_id?': 'number' }
     * );
     *
     * // Inserção que falhará:
     * db.ref('users/352352/posts/572245').set({
     *  text: 'this is my post',
     *  tags: { sometag: 'negue isso' } // <-- sometag deve ser do tipo objeto
     * });
     *
     * // Inserção que falhará:
     * db.ref('users/352352/posts/572245').set({
     *  text: 'this is my post',
     *  tags: {
     *      tag1: { name: 'firstpost', link_id: 234 },
     *      tag2: { name: 'novato' },
     *      tag3: { title: 'Não permitido' } // <-- propriedade title não permitida
     *  }
     * });
     *
     * // Atualização que falha se o post não existir:
     * db.ref('users/352352/posts/572245/tags/tag1').update({
     *  name: 'firstpost'
     * }); // <-- o post está faltando a propriedade text
     */
  }, {
    key: "validateSchema",
    value: function validateSchema(database, path, value) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        updates: false
      };
      var _a;
      var schemas = (_a = this.schemas[database]) !== null && _a !== void 0 ? _a : this.schemas[database] = [];
      var result = {
        ok: true
      };
      var pathInfo = ivipbase_core_1.PathInfo.get(path);
      schemas.filter(function (s) {
        return pathInfo.isOnTrailOf(s.path);
      }).every(function (s) {
        if (pathInfo.isDescendantOf(s.path)) {
          // Dado que o caminho de verificação é um descendente do caminho de definição de esquema
          var ancestorPath = ivipbase_core_1.PathInfo.fillVariables(s.path, path);
          var _trailKeys = pathInfo.keys.slice(ivipbase_core_1.PathInfo.getPathKeys(s.path).length);
          result = s.schema.check(ancestorPath, value, options.updates, _trailKeys);
          return result.ok;
        }
        // Dado que o caminho de verificação está no caminho de definição de esquema ou em um caminho superior
        var trailKeys = ivipbase_core_1.PathInfo.getPathKeys(s.path).slice(pathInfo.keys.length);
        if (options.updates === true && trailKeys.length > 0 && !(trailKeys[0] in value)) {
          // Corrige #217: esta atualização em um caminho superior não afeta nenhum dado no caminho alvo do esquema
          return result.ok;
        }
        var partial = options.updates === true && trailKeys.length === 0;
        var check = function check(path, value, trailKeys) {
          if (trailKeys.length === 0) {
            // Check this node
            return s.schema.check(path, value, partial);
          } else if (value === null) {
            return {
              ok: true
            }; // Não no final do caminho, mas não há mais nada para verificar
          }
          var key = trailKeys[0];
          if (typeof key === "string" && (key === "*" || key[0] === "$")) {
            // Curinga. Verifique cada chave em valor recursivamente
            if (value === null || _typeof(value) !== "object") {
              // Não é possível verificar os filhos, porque não há nenhum. Isso é
              // possível se outra regra permitir que o valor no caminho atual
              // seja algo diferente de um objeto.
              return {
                ok: true
              };
            }
            var _result;
            Object.keys(value).every(function (childKey) {
              var childPath = ivipbase_core_1.PathInfo.getChildPath(path, childKey);
              var childValue = value[childKey];
              _result = check(childPath, childValue, trailKeys.slice(1));
              return _result.ok;
            });
            return _result;
          } else {
            var childPath = ivipbase_core_1.PathInfo.getChildPath(path, key);
            var childValue = value[key];
            return check(childPath, childValue, trailKeys.slice(1));
          }
        };
        result = check(path, value, trailKeys);
        return result.ok;
      });
      return result;
    }
  }]);
}(ivipbase_core_1.SimpleEventEmitter);
exports["default"] = MDE;

},{"../../../utils":37,"./NodeInfo":14,"./destructureData":15,"./structureNodes":17,"./utils":18,"ivipbase-core":152}],17:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveObjetByIncluded = exports.checkIncludedPath = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var utils_1 = require("./utils");
var checkIncludedPath = function checkIncludedPath(from, options) {
  var _a, _b;
  var include = ((_a = options === null || options === void 0 ? void 0 : options.include) !== null && _a !== void 0 ? _a : []).map(function (p) {
    return ivipbase_core_1.PathInfo.get([options.main_path, p]);
  });
  var exclude = ((_b = options === null || options === void 0 ? void 0 : options.exclude) !== null && _b !== void 0 ? _b : []).map(function (p) {
    return ivipbase_core_1.PathInfo.get([options.main_path, p]);
  });
  var p = ivipbase_core_1.PathInfo.get(from);
  var isInclude = include.length > 0 ? include.findIndex(function (path) {
    return p.isParentOf(path) || p.equals(path) || p.isDescendantOf(path);
  }) >= 0 : true;
  return exclude.findIndex(function (path) {
    return p.equals(path) || p.isDescendantOf(path);
  }) < 0 && isInclude;
};
exports.checkIncludedPath = checkIncludedPath;
var resolveObjetByIncluded = function resolveObjetByIncluded(path, obj, options) {
  return Array.isArray(obj) ? obj.filter(function (_, k) {
    var p = ivipbase_core_1.PathInfo.get([path, k]);
    return (0, exports.checkIncludedPath)(p.path, options);
  }).map(function (v, k) {
    if (["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(v))) {
      return (0, exports.resolveObjetByIncluded)(ivipbase_core_1.PathInfo.get([path, k]).path, v, options);
    }
    return v;
  }) : Object.fromEntries(Object.entries(obj).filter(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      k = _ref2[0],
      v = _ref2[1];
    var p = ivipbase_core_1.PathInfo.get([path, k]);
    return (0, exports.checkIncludedPath)(p.path, options);
  }).map(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
      k = _ref4[0],
      v = _ref4[1];
    if (["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(v))) {
      return [k, (0, exports.resolveObjetByIncluded)(ivipbase_core_1.PathInfo.get([path, k]).path, v, options)];
    }
    return [k, v];
  }));
};
exports.resolveObjetByIncluded = resolveObjetByIncluded;
function structureNodes(path, nodes) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _a;
  options.main_path = !options.main_path ? path : options.main_path;
  var pathInfo = ivipbase_core_1.PathInfo.get(path);
  var mainNode = nodes.find(function (_ref5) {
    var p = _ref5.path;
    return pathInfo.equals(p);
  });
  var parentNode = nodes.find(function (_ref6) {
    var p = _ref6.path;
    return pathInfo.isChildOf(p);
  });
  var nodeInfo = mainNode !== null && mainNode !== void 0 ? mainNode : parentNode;
  if (!nodeInfo) {
    return undefined;
  }
  var value = undefined;
  var nodePath = nodeInfo.path,
    content = nodeInfo.content;
  content = (0, utils_1.processReadNodeValue)(content);
  if (pathInfo.isChildOf(nodePath)) {
    if ((content.type === utils_1.nodeValueTypes.OBJECT || content.type === utils_1.nodeValueTypes.ARRAY) && _typeof(content.value) === "object" && content.value !== null && pathInfo.key && pathInfo.key in content.value) {
      value = (_a = content.value[pathInfo.key]) !== null && _a !== void 0 ? _a : undefined;
    }
    return value;
  }
  if (content.type === utils_1.nodeValueTypes.OBJECT || content.type === utils_1.nodeValueTypes.ARRAY) {
    var val = content.type === utils_1.nodeValueTypes.ARRAY ? Array.isArray(content.value) ? content.value : [] : content.value;
    return nodes.filter(function (_ref7) {
      var p = _ref7.path;
      return pathInfo.isParentOf(p) || pathInfo.isAncestorOf(p);
    }).sort(function (a, b) {
      var aPath = ivipbase_core_1.PathInfo.get(a.path);
      var bPath = ivipbase_core_1.PathInfo.get(b.path);
      return aPath.isAncestorOf(bPath) || aPath.isParentOf(bPath) ? -1 : aPath.isDescendantOf(bPath) || aPath.isChildOf(bPath) ? 1 : 0;
    }).reduce(function (acc, _ref8) {
      var path = _ref8.path,
        content = _ref8.content;
      var pathInfo = ivipbase_core_1.PathInfo.get(path);
      if (pathInfo.key !== null && (0, exports.checkIncludedPath)(path, options)) {
        content = (0, utils_1.processReadNodeValue)(content);
        var propertyTrail = ivipbase_core_1.PathInfo.getPathKeys(path.slice(nodePath.length + 1));
        var targetObject = acc;
        var targetProperty = propertyTrail.slice(-1)[0];
        var _iterator = _createForOfIteratorHelper(propertyTrail.slice(0, -1)),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var p = _step.value;
            if (!(p in targetObject)) {
              targetObject[p] = typeof p === "number" ? [] : {};
            }
            targetObject = targetObject[p];
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        if (content.type === utils_1.nodeValueTypes.OBJECT || content.type === utils_1.nodeValueTypes.ARRAY) {
          var _val = content.type === utils_1.nodeValueTypes.ARRAY ? Array.isArray(content.value) ? content.value : [] : content.value;
          targetObject[targetProperty] = (0, exports.resolveObjetByIncluded)(path, _val, options);
        } else {
          targetObject[targetProperty] = content.value;
        }
      }
      return acc;
    }, (0, exports.resolveObjetByIncluded)(nodePath, val, options));
  }
  return content.value;
}
exports["default"] = structureNodes;

},{"./utils":18,"ivipbase-core":152}],18:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTypeFromStoredValue = exports.processReadNodeValue = exports.getTypedChildValue = exports.valueFitsInline = exports.promiseState = exports.getValueType = exports.getNodeValueType = exports.getValueTypeDefault = exports.getValueTypeName = exports.VALUE_TYPES = exports.nodeValueTypes = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var ivip_utils_1 = require("ivip-utils");
var utils_1 = require("../../../utils");
var assert = ivipbase_core_1.Lib.assert;
exports.nodeValueTypes = {
  EMPTY: 0,
  // Native types:
  OBJECT: 1,
  ARRAY: 2,
  NUMBER: 3,
  BOOLEAN: 4,
  STRING: 5,
  BIGINT: 7,
  // Custom types:
  DATETIME: 6,
  BINARY: 8,
  REFERENCE: 9,
  DEDICATED_RECORD: 99
};
exports.VALUE_TYPES = exports.nodeValueTypes;
/**
 * Retorna o nome descritivo de um tipo de valor com base no código do tipo.
 *
 * @param {number} valueType - O código do tipo de valor.
 * @returns {string} - O nome descritivo do tipo de valor correspondente.
 * @throws {Error} - Se o código do tipo de valor fornecido for desconhecido.
 *
 * @example
 * const typeName = getValueTypeName(VALUE_TYPES.STRING);
 * // Retorna: "string"
 *
 * @example
 * const typeName = getValueTypeName(99);
 * // Retorna: "dedicated_record"
 */
function getValueTypeName(valueType) {
  switch (valueType) {
    case exports.VALUE_TYPES.ARRAY:
      return "array";
    case exports.VALUE_TYPES.BINARY:
      return "binary";
    case exports.VALUE_TYPES.BOOLEAN:
      return "boolean";
    case exports.VALUE_TYPES.DATETIME:
      return "date";
    case exports.VALUE_TYPES.NUMBER:
      return "number";
    case exports.VALUE_TYPES.OBJECT:
      return "object";
    case exports.VALUE_TYPES.REFERENCE:
      return "reference";
    case exports.VALUE_TYPES.STRING:
      return "string";
    case exports.VALUE_TYPES.BIGINT:
      return "bigint";
    case exports.VALUE_TYPES.DEDICATED_RECORD:
      return "dedicated_record";
    default:
      return "unknown";
  }
}
exports.getValueTypeName = getValueTypeName;
/**
 * Retorna um valor padrão para um tipo de valor com base no código do tipo.
 *
 * @param {number} valueType - O código do tipo de valor.
 * @returns {any} - Um valor padrão correspondente ao tipo de valor especificado.
 *
 * @example
 * const defaultValue = getValueTypeDefault(VALUE_TYPES.STRING);
 * // Retorna: ""
 *
 * @example
 * const defaultValue = getValueTypeDefault(VALUE_TYPES.NUMBER);
 * // Retorna: 0
 */
function getValueTypeDefault(valueType) {
  switch (valueType) {
    case exports.VALUE_TYPES.ARRAY:
      return [];
    case exports.VALUE_TYPES.OBJECT:
      return {};
    case exports.VALUE_TYPES.NUMBER:
      return 0;
    case exports.VALUE_TYPES.BOOLEAN:
      return false;
    case exports.VALUE_TYPES.STRING:
      return "";
    case exports.VALUE_TYPES.BIGINT:
      return BigInt(0);
    case exports.VALUE_TYPES.DATETIME:
      return new Date().toISOString();
    case exports.VALUE_TYPES.BINARY:
      return new Uint8Array();
    case exports.VALUE_TYPES.REFERENCE:
      return null;
    default:
      return undefined;
    // Or any other default value you prefer
  }
}
exports.getValueTypeDefault = getValueTypeDefault;
/**
 * Determina o tipo de valor de um node com base no valor fornecido.
 *
 * @param {unknown} value - O valor a ser avaliado.
 * @returns {number} - O código do tipo de valor correspondente.
 *
 * @example
 * const valueType = getNodeValueType([1, 2, 3]);
 * // Retorna: VALUE_TYPES.ARRAY
 *
 * @example
 * const valueType = getNodeValueType(new PathReference());
 * // Retorna: VALUE_TYPES.REFERENCE
 */
function getNodeValueType(value) {
  if (value instanceof Array) {
    return exports.VALUE_TYPES.ARRAY;
  } else if (value instanceof ivipbase_core_1.PathReference) {
    return exports.VALUE_TYPES.REFERENCE;
  } else if (value instanceof ArrayBuffer) {
    return exports.VALUE_TYPES.BINARY;
  } else if ((0, utils_1.isDate)(value)) {
    return exports.VALUE_TYPES.DATETIME;
  }
  // TODO else if (value instanceof DataDocument) { return VALUE_TYPES.DOCUMENT; }
  else if (typeof value === "string") {
    return exports.VALUE_TYPES.STRING;
  } else if (_typeof(value) === "object") {
    return exports.VALUE_TYPES.OBJECT;
  } else if (typeof value === "bigint") {
    return exports.VALUE_TYPES.BIGINT;
  }
  return exports.VALUE_TYPES.EMPTY;
}
exports.getNodeValueType = getNodeValueType;
/**
 * Determina o tipo de valor de um dado com base no valor fornecido.
 *
 * @param {unknown} value - O valor a ser avaliado.
 * @returns {number} - O código do tipo de valor correspondente.
 *
 * @example
 * const valueType = getValueType([1, 2, 3]);
 * // Retorna: VALUE_TYPES.ARRAY
 *
 * @example
 * const valueType = getValueType(new PathReference());
 * // Retorna: VALUE_TYPES.REFERENCE
 */
function getValueType(value) {
  if (value instanceof Array) {
    return exports.VALUE_TYPES.ARRAY;
  } else if (value instanceof ivipbase_core_1.PathReference) {
    return exports.VALUE_TYPES.REFERENCE;
  } else if (value instanceof ArrayBuffer) {
    return exports.VALUE_TYPES.BINARY;
  } else if ((0, utils_1.isDate)(value)) {
    return exports.VALUE_TYPES.DATETIME;
  }
  // TODO else if (value instanceof DataDocument) { return VALUE_TYPES.DOCUMENT; }
  else if (typeof value === "string") {
    return exports.VALUE_TYPES.STRING;
  } else if (_typeof(value) === "object" && value !== null) {
    return exports.VALUE_TYPES.OBJECT;
  } else if (typeof value === "number") {
    return exports.VALUE_TYPES.NUMBER;
  } else if (typeof value === "boolean") {
    return exports.VALUE_TYPES.BOOLEAN;
  } else if (typeof value === "bigint") {
    return exports.VALUE_TYPES.BIGINT;
  }
  return exports.VALUE_TYPES.EMPTY;
}
exports.getValueType = getValueType;
var promiseState = function promiseState(p) {
  var t = {
    __timestamp__: Date.now()
  };
  return Promise.race([p, t]).then(function (v) {
    return v === t ? "pending" : "fulfilled";
  }, function () {
    return "rejected";
  });
};
exports.promiseState = promiseState;
/**
 * Verifica se um valor pode ser armazenado em um objeto pai ou se deve ser movido
 * para um registro dedicado com base nas configurações de tamanho máximo (`maxInlineValueSize`).
 * @param value - O valor a ser verificado.
 * @returns {boolean} `true` se o valor pode ser armazenado inline, `false` caso contrário.
 * @throws {TypeError} Lança um erro se o tipo do valor não for suportado.
 */
function valueFitsInline(value, settings) {
  value = value == undefined ? null : value;
  if (typeof value === "number" || typeof value === "boolean" || (0, utils_1.isDate)(value)) {
    return true;
  } else if (typeof value === "string") {
    if (value.length > settings.maxInlineValueSize) {
      return false;
    }
    // Se a string contém caracteres Unicode, o tamanho em bytes será maior do que `value.length`.
    var encoded = (0, ivip_utils_1.encodeString)(value);
    return encoded.length < settings.maxInlineValueSize;
  } else if (value instanceof ivipbase_core_1.PathReference) {
    if (value.path.length > settings.maxInlineValueSize) {
      return false;
    }
    // Se o caminho contém caracteres Unicode, o tamanho em bytes será maior do que `value.path.length`.
    var _encoded = (0, ivip_utils_1.encodeString)(value.path);
    return _encoded.length < settings.maxInlineValueSize;
  } else if (value instanceof ArrayBuffer) {
    return value.byteLength < settings.maxInlineValueSize;
  } else if (value instanceof Array) {
    return value.length === 0;
  } else if (_typeof(value) === "object") {
    return value === null || Object.keys(value).length === 0;
  } else {
    throw new TypeError("What else is there?");
  }
}
exports.valueFitsInline = valueFitsInline;
/**
 * Obtém um valor tipado apropriado para armazenamento com base no tipo do valor fornecido.
 * @param val - O valor a ser processado.
 * @returns {any} O valor processado.
 * @throws {Error} Lança um erro se o valor não for suportado ou se for nulo.
 */
function getTypedChildValue(val) {
  if (val === null || val === undefined) {
    return null;
    //throw new Error(`Not allowed to store null values. remove the property`);
  } else if ((0, utils_1.isDate)(val)) {
    return {
      type: exports.VALUE_TYPES.DATETIME,
      value: new Date(val).getTime()
    };
  } else if (["string", "number", "boolean"].includes(_typeof(val))) {
    return val;
  } else if (val instanceof ivipbase_core_1.PathReference) {
    return {
      type: exports.VALUE_TYPES.REFERENCE,
      value: val.path
    };
  } else if (val instanceof ArrayBuffer) {
    return {
      type: exports.VALUE_TYPES.BINARY,
      value: ivipbase_core_1.ascii85.encode(val)
    };
  } else if (_typeof(val) === "object") {
    assert(Object.keys(val).length === 0 || "type" in val && val.type === exports.VALUE_TYPES.DEDICATED_RECORD, "child object stored in parent can only be empty");
    return val;
  }
  return val;
}
exports.getTypedChildValue = getTypedChildValue;
/**
 * Processa o valor de um nó de armazenamento durante a leitura, convertendo valores tipados de volta ao formato original.
 * @param node - O nó de armazenamento a ser processado.
 * @returns {StorageNode} O nó de armazenamento processado.
 * @throws {Error} Lança um erro se o tipo de registro autônomo for inválido.
 */
function processReadNodeValue(node) {
  var getTypedChildValue = function getTypedChildValue(val) {
    // Valor tipado armazenado em um registro pai
    if (val.type === exports.VALUE_TYPES.BINARY) {
      // Binário armazenado em um registro pai como uma string
      return ivipbase_core_1.ascii85.decode(val.value);
    } else if (val.type === exports.VALUE_TYPES.DATETIME) {
      // Valor de data armazenado como número
      return new Date(val.value);
    } else if (val.type === exports.VALUE_TYPES.REFERENCE) {
      // Referência de caminho armazenada como string
      return new ivipbase_core_1.PathReference(val.value);
    } else if (val.type === exports.VALUE_TYPES.DEDICATED_RECORD) {
      return getValueTypeDefault(val.value);
    } else {
      throw new Error("Unhandled child value type ".concat(val.type));
    }
  };
  node = JSON.parse(JSON.stringify(node));
  switch (node.type) {
    case exports.VALUE_TYPES.ARRAY:
      {
        node.value = (Array.isArray(node.value) ? node.value : []).map(function (item) {
          if (item !== null && _typeof(item) === "object" && "type" in item) {
            return getTypedChildValue(item);
          }
          return item;
        });
        break;
      }
    case exports.VALUE_TYPES.OBJECT:
      {
        // Verifica se algum valor precisa ser convertido
        // NOTA: Arrays são armazenados com propriedades numéricas
        var obj = node.value;
        if (obj !== null) {
          Object.keys(obj).forEach(function (key) {
            var item = obj[key];
            if (item !== null && _typeof(item) === "object" && "type" in item) {
              obj[key] = getTypedChildValue(item);
            }
          });
        }
        node.value = obj;
        break;
      }
    case exports.VALUE_TYPES.BINARY:
      {
        node.value = ivipbase_core_1.ascii85.decode(node.value);
        break;
      }
    case exports.VALUE_TYPES.REFERENCE:
      {
        node.value = new ivipbase_core_1.PathReference(node.value);
        break;
      }
    case exports.VALUE_TYPES.STRING:
      {
        // Nenhuma ação necessária
        // node.value = node.value;
        break;
      }
    default:
      node.value = null;
    // throw new Error(`Invalid standalone record value type: ${node.type}`); // nunca deve acontecer
  }
  return node;
}
exports.processReadNodeValue = processReadNodeValue;
var getTypeFromStoredValue = function getTypeFromStoredValue(val) {
  var type;
  if (typeof val === "string") {
    type = exports.VALUE_TYPES.STRING;
  } else if (typeof val === "number") {
    type = exports.VALUE_TYPES.NUMBER;
  } else if (typeof val === "boolean") {
    type = exports.VALUE_TYPES.BOOLEAN;
  } else if (val instanceof Array) {
    type = exports.VALUE_TYPES.ARRAY;
  } else if (_typeof(val) === "object") {
    if (val && "type" in val) {
      var serialized = val;
      type = serialized.type;
      val = serialized.value;
      if (type === exports.VALUE_TYPES.DATETIME) {
        val = new Date(val);
      } else if (type === exports.VALUE_TYPES.REFERENCE) {
        val = new ivipbase_core_1.PathReference(val);
      }
    } else {
      type = exports.VALUE_TYPES.OBJECT;
    }
  } else {
    throw new Error("Unknown value type");
  }
  return {
    type: type,
    value: val
  };
};
exports.getTypeFromStoredValue = getTypeFromStoredValue;

},{"../../../utils":37,"ivip-utils":125,"ivipbase-core":152}],19:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
__exportStar(require("./DataStorage"), exports);
__exportStar(require("./CustomStorage"), exports);

},{"./CustomStorage":12,"./DataStorage":13}],20:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StorageDBClient = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var error_1 = require("../controller/request/error");
var auth_1 = require("../auth");
var PromiseTimeoutError = /*#__PURE__*/function (_Error) {
  function PromiseTimeoutError() {
    _classCallCheck(this, PromiseTimeoutError);
    return _callSuper(this, PromiseTimeoutError, arguments);
  }
  _inherits(PromiseTimeoutError, _Error);
  return _createClass(PromiseTimeoutError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
function promiseTimeout(promise, ms, comment) {
  return new Promise(function (resolve, reject) {
    var timeout = setTimeout(function () {
      return reject(new PromiseTimeoutError("Promise ".concat(comment ? "\"".concat(comment, "\" ") : "", "timed out after ").concat(ms, "ms")));
    }, ms);
    function success(result) {
      clearTimeout(timeout);
      resolve(result);
    }
    promise.then(success)["catch"](reject);
  });
}
var StorageDBClient = /*#__PURE__*/function (_ivipbase_core_1$Api) {
  function StorageDBClient(db) {
    var _this;
    _classCallCheck(this, StorageDBClient);
    _this = _callSuper(this, StorageDBClient);
    _this.db = db;
    _this._realtimeQueries = {};
    _this.app = db.app;
    _this.url = _this.app.url.replace(/\/+$/, "");
    _this.initialize();
    _this.app.onConnect( /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(socket) {
        var subscribePromises, _loop, query_id;
        return _regeneratorRuntime().wrap(function _callee3$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              subscribePromises = [];
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var subscribeQuery;
                return _regeneratorRuntime().wrap(function _loop$(_context3) {
                  while (1) switch (_context3.prev = _context3.next) {
                    case 0:
                      subscribeQuery = _this._realtimeQueries[query_id];
                      subscribePromises.push(new Promise( /*#__PURE__*/function () {
                        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(resolve, reject) {
                          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                            while (1) switch (_context2.prev = _context2.next) {
                              case 0:
                                _context2.prev = 0;
                                _context2.next = 3;
                                return _this.app.websocketRequest(socket, "query-subscribe", subscribeQuery, _this.db.name);
                              case 3:
                                _context2.next = 8;
                                break;
                              case 5:
                                _context2.prev = 5;
                                _context2.t0 = _context2["catch"](0);
                                if (_context2.t0.code === "access_denied" && !_this.db.accessToken) {
                                  _this.db.debug.error("Could not subscribe to event \"Query-Event\" on path \"".concat(subscribeQuery.path, "\" because you are not signed in. If you added this event while offline and have a user access token, you can prevent this by using getAuth().signInWithToken(token) to automatically try signing in after connecting"));
                                } else {
                                  _this.db.debug.error(_context2.t0);
                                }
                              case 8:
                              case "end":
                                return _context2.stop();
                            }
                          }, _callee2, null, [[0, 5]]);
                        }));
                        return function (_x4, _x5) {
                          return _ref3.apply(this, arguments);
                        };
                      }()));
                    case 2:
                    case "end":
                      return _context3.stop();
                  }
                }, _loop);
              });
              _context4.t0 = _regeneratorRuntime().keys(_this._realtimeQueries);
            case 3:
              if ((_context4.t1 = _context4.t0()).done) {
                _context4.next = 8;
                break;
              }
              query_id = _context4.t1.value;
              return _context4.delegateYield(_loop(), "t2", 6);
            case 6:
              _context4.next = 3;
              break;
            case 8:
              _this.db.subscriptions.forEach(function (event, path) {
                subscribePromises.push(new Promise( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(resolve, reject) {
                    return _regeneratorRuntime().wrap(function _callee$(_context) {
                      while (1) switch (_context.prev = _context.next) {
                        case 0:
                          _context.prev = 0;
                          _context.next = 3;
                          return _this.app.websocketRequest(socket, "subscribe", {
                            path: path,
                            event: event
                          }, _this.db.name);
                        case 3:
                          _context.next = 8;
                          break;
                        case 5:
                          _context.prev = 5;
                          _context.t0 = _context["catch"](0);
                          if (_context.t0.code === "access_denied" && !_this.db.accessToken) {
                            _this.db.debug.error("Could not subscribe to event \"".concat(event, "\" on path \"").concat(path, "\" because you are not signed in. If you added this event while offline and have a user access token, you can prevent this by using getAuth().signInWithToken(token) to automatically try signing in after connecting"));
                          } else {
                            _this.db.debug.error(_context.t0);
                          }
                        case 8:
                        case "end":
                          return _context.stop();
                      }
                    }, _callee, null, [[0, 5]]);
                  }));
                  return function (_x2, _x3) {
                    return _ref2.apply(this, arguments);
                  };
                }()));
              });
              _context4.next = 11;
              return Promise.all(subscribePromises);
            case 11:
            case "end":
              return _context4.stop();
          }
        }, _callee3);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    _this.app.ready(function () {
      var _a, _b;
      (_a = _this.app.socket) === null || _a === void 0 ? void 0 : _a.on("data-event", function (data) {
        var _a;
        var val = ivipbase_core_1.Transport.deserialize(data.val);
        var context = (_a = data.context) !== null && _a !== void 0 ? _a : {};
        context.acebase_event_source = "server";
        var isValid = _this.db.subscriptions.hasValueSubscribersForPath(data.subscr_path);
        if (!isValid) {
          return;
        }
        _this.db.subscriptions.trigger(data.event, data.subscr_path, data.path, val.previous, val.current, context);
      });
      (_b = _this.app.socket) === null || _b === void 0 ? void 0 : _b.on("query-event", function (data) {
        var _a, _b, _c;
        data = ivipbase_core_1.Transport.deserialize(data);
        var query = _this._realtimeQueries[data.query_id];
        if (!query) {
          return;
        }
        var keepMonitoring = true;
        try {
          keepMonitoring = ((_b = (_a = query.options) === null || _a === void 0 ? void 0 : _a.eventHandler) === null || _b === void 0 ? void 0 : _b.call(_a, data)) !== false;
        } catch (err) {
          keepMonitoring = false;
        }
        if (keepMonitoring === false) {
          delete _this._realtimeQueries[data.query_id];
          (_c = _this.app.socket) === null || _c === void 0 ? void 0 : _c.emit("query-unsubscribe", {
            dbName: _this.db.database,
            query_id: data.query_id
          });
        }
      });
    });
    return _this;
  }
  _inherits(StorageDBClient, _ivipbase_core_1$Api);
  return _createClass(StorageDBClient, [{
    key: "serverPingUrl",
    get: function get() {
      return "/ping/".concat(this.db.database);
    }
  }, {
    key: "initialize",
    value: function () {
      var _initialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var _this2 = this;
        return _regeneratorRuntime().wrap(function _callee5$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              this.app.onConnect( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
                return _regeneratorRuntime().wrap(function _callee4$(_context5) {
                  while (1) switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.next = 2;
                      return (0, auth_1.getAuth)(_this2.db.database).initialize();
                    case 2:
                      _context5.next = 4;
                      return _this2.app.request({
                        route: _this2.serverPingUrl
                      });
                    case 4:
                      _this2.db.emit("ready");
                    case 5:
                    case "end":
                      return _context5.stop();
                  }
                }, _callee4);
              })), true);
            case 1:
            case "end":
              return _context6.stop();
          }
        }, _callee5, this);
      }));
      function initialize() {
        return _initialize.apply(this, arguments);
      }
      return initialize;
    }()
  }, {
    key: "isConnected",
    get: function get() {
      return this.app.isConnected;
    }
  }, {
    key: "isConnecting",
    get: function get() {
      return this.app.isConnecting;
    }
  }, {
    key: "connectionState",
    get: function get() {
      return this.app.connectionState;
    }
  }, {
    key: "_request",
    value: function () {
      var _request2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(options) {
        var _this3 = this;
        var _a, _b, auth, accessToken, connectPromise;
        return _regeneratorRuntime().wrap(function _callee6$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              if (!(this.isConnected || options.ignoreConnectionState === true)) {
                _context7.next = 16;
                break;
              }
              auth = this.app.auth.get(this.db.database);
              _context7.prev = 2;
              accessToken = (_a = auth === null || auth === void 0 ? void 0 : auth.currentUser) === null || _a === void 0 ? void 0 : _a.accessToken;
              _context7.next = 6;
              return this.db.app.request(Object.assign(Object.assign({}, options), {
                accessToken: accessToken
              }));
            case 6:
              return _context7.abrupt("return", _context7.sent);
            case 9:
              _context7.prev = 9;
              _context7.t0 = _context7["catch"](2);
              (_b = auth === null || auth === void 0 ? void 0 : auth.currentUser) === null || _b === void 0 ? void 0 : _b.reload();
              if (this.isConnected && _context7.t0.isNetworkError) {
                // This is a network error, but the websocket thinks we are still connected.
                this.db.debug.warn("A network error occurred loading ".concat(options.route, " | Error: ").concat(_context7.t0.message));
                // Start reconnection flow
                // this._handleDetectedDisconnect(err);
              }
              // Rethrow the error
              throw _context7.t0;
            case 14:
              _context7.next = 22;
              break;
            case 16:
              if (this.isConnecting) {
                _context7.next = 18;
                break;
              }
              throw new Error(error_1.NOT_CONNECTED_ERROR_MESSAGE);
            case 18:
              connectPromise = new Promise(function (resolve) {
                var _a;
                return (_a = _this3.app.socket) === null || _a === void 0 ? void 0 : _a.once("connect", resolve);
              });
              _context7.next = 21;
              return promiseTimeout(connectPromise, 1000, "Waiting for connection")["catch"](function (err) {
                throw new Error(error_1.NOT_CONNECTED_ERROR_MESSAGE);
              });
            case 21:
              return _context7.abrupt("return", this._request(options));
            case 22:
            case "end":
              return _context7.stop();
          }
        }, _callee6, this, [[2, 9]]);
      }));
      function _request(_x6) {
        return _request2.apply(this, arguments);
      }
      return _request;
    }()
  }, {
    key: "connect",
    value: function connect() {
      var retry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    }
  }, {
    key: "disconnect",
    value: function disconnect() {}
  }, {
    key: "subscribe",
    value: function () {
      var _subscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(path, event, callback, settings) {
        return _regeneratorRuntime().wrap(function _callee7$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.prev = 0;
              this.db.subscriptions.add(path, event, callback);
              _context8.next = 4;
              return this.app.websocketRequest(this.app.socket, "subscribe", {
                path: path,
                event: event
              }, this.db.name);
            case 4:
              _context8.next = 9;
              break;
            case 6:
              _context8.prev = 6;
              _context8.t0 = _context8["catch"](0);
              this.db.debug.error(_context8.t0);
            case 9:
            case "end":
              return _context8.stop();
          }
        }, _callee7, this, [[0, 6]]);
      }));
      function subscribe(_x7, _x8, _x9, _x10) {
        return _subscribe.apply(this, arguments);
      }
      return subscribe;
    }()
  }, {
    key: "unsubscribe",
    value: function () {
      var _unsubscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(path, event, callback) {
        return _regeneratorRuntime().wrap(function _callee8$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _context9.prev = 0;
              this.db.subscriptions.remove(path, event, callback);
              _context9.next = 4;
              return this.app.websocketRequest(this.app.socket, "unsubscribe", {
                path: path,
                event: event
              }, this.db.name);
            case 4:
              _context9.next = 9;
              break;
            case 6:
              _context9.prev = 6;
              _context9.t0 = _context9["catch"](0);
              this.db.debug.error(_context9.t0);
            case 9:
            case "end":
              return _context9.stop();
          }
        }, _callee8, this, [[0, 6]]);
      }));
      function unsubscribe(_x11, _x12, _x13) {
        return _unsubscribe.apply(this, arguments);
      }
      return unsubscribe;
    }()
  }, {
    key: "getInfo",
    value: function () {
      var _getInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        return _regeneratorRuntime().wrap(function _callee9$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return this._request({
                route: "/info/".concat(this.db.database)
              });
            case 2:
              return _context10.abrupt("return", _context10.sent);
            case 3:
            case "end":
              return _context10.stop();
          }
        }, _callee9, this);
      }));
      function getInfo() {
        return _getInfo.apply(this, arguments);
      }
      return getInfo;
    }()
  }, {
    key: "stats",
    value: function () {
      var _stats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        return _regeneratorRuntime().wrap(function _callee10$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              return _context11.abrupt("return", this._request({
                route: "/stats/".concat(this.db.database)
              }));
            case 1:
            case "end":
              return _context11.stop();
          }
        }, _callee10, this);
      }));
      function stats() {
        return _stats.apply(this, arguments);
      }
      return stats;
    }()
  }, {
    key: "set",
    value: function () {
      var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(path, value) {
        var options,
          _a,
          data,
          _yield$this$_request,
          context,
          cursor,
          _args12 = arguments;
        return _regeneratorRuntime().wrap(function _callee11$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              options = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : {
                suppress_events: true,
                context: {}
              };
              data = JSON.stringify(ivipbase_core_1.Transport.serialize(value));
              _context12.next = 4;
              return this._request({
                method: "PUT",
                route: "/data/".concat(this.db.database, "/").concat(path),
                data: data,
                context: (_a = options.context) !== null && _a !== void 0 ? _a : {},
                includeContext: true
              });
            case 4:
              _yield$this$_request = _context12.sent;
              context = _yield$this$_request.context;
              cursor = context === null || context === void 0 ? void 0 : context.database_cursor;
              return _context12.abrupt("return", {
                cursor: cursor
              });
            case 8:
            case "end":
              return _context12.stop();
          }
        }, _callee11, this);
      }));
      function set(_x14, _x15) {
        return _set.apply(this, arguments);
      }
      return set;
    }()
  }, {
    key: "update",
    value: function () {
      var _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(path, updates) {
        var options,
          data,
          _yield$this$_request2,
          context,
          cursor,
          _args13 = arguments;
        return _regeneratorRuntime().wrap(function _callee12$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              options = _args13.length > 2 && _args13[2] !== undefined ? _args13[2] : {
                suppress_events: true,
                context: {}
              };
              data = JSON.stringify(ivipbase_core_1.Transport.serialize(updates));
              _context13.next = 4;
              return this._request({
                method: "POST",
                route: "/data/".concat(this.db.database, "/").concat(path),
                data: data,
                context: options.context,
                includeContext: true
              });
            case 4:
              _yield$this$_request2 = _context13.sent;
              context = _yield$this$_request2.context;
              cursor = context === null || context === void 0 ? void 0 : context.database_cursor;
              return _context13.abrupt("return", {
                cursor: cursor
              });
            case 8:
            case "end":
              return _context13.stop();
          }
        }, _callee12, this);
      }));
      function update(_x16, _x17) {
        return _update.apply(this, arguments);
      }
      return update;
    }()
  }, {
    key: "transaction",
    value: function () {
      var _transaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(path, callback) {
        var options,
          _yield$this$get,
          value,
          context,
          newValue,
          _args14 = arguments;
        return _regeneratorRuntime().wrap(function _callee13$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              options = _args14.length > 2 && _args14[2] !== undefined ? _args14[2] : {
                suppress_events: false,
                context: null
              };
              _context14.next = 3;
              return this.get(path, {
                child_objects: true
              });
            case 3:
              _yield$this$get = _context14.sent;
              value = _yield$this$get.value;
              context = _yield$this$get.context;
              _context14.next = 8;
              return Promise.race([callback(value !== null && value !== void 0 ? value : null)]);
            case 8:
              newValue = _context14.sent;
              return _context14.abrupt("return", this.update(path, newValue, {
                suppress_events: options.suppress_events,
                context: options.context
              }));
            case 10:
            case "end":
              return _context14.stop();
          }
        }, _callee13, this);
      }));
      function transaction(_x18, _x19) {
        return _transaction.apply(this, arguments);
      }
      return transaction;
    }()
  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(path, options) {
        var filtered, url, query, _yield$this$_request3, data, context;
        return _regeneratorRuntime().wrap(function _callee14$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              filtered = false, url = "";
              if (options) {
                query = [];
                if (options.exclude instanceof Array) {
                  query.push("exclude=".concat(options.exclude.join(",")));
                }
                if (options.include instanceof Array) {
                  query.push("include=".concat(options.include.join(",")));
                }
                if (typeof options.child_objects === "boolean") {
                  query.push("child_objects=".concat(options.child_objects));
                }
                if (query.length > 0) {
                  filtered = true;
                  url += "?".concat(query.join("&"));
                }
              }
              _context15.next = 4;
              return this._request({
                route: "/data/".concat(this.db.database, "/").concat(path).concat(url),
                context: options,
                includeContext: true
              });
            case 4:
              _yield$this$_request3 = _context15.sent;
              data = _yield$this$_request3.data;
              context = _yield$this$_request3.context;
              return _context15.abrupt("return", {
                value: ivipbase_core_1.Transport.deserialize(data),
                context: context,
                cursor: context === null || context === void 0 ? void 0 : context.database_cursor
              });
            case 8:
            case "end":
              return _context15.stop();
          }
        }, _callee14, this);
      }));
      function get(_x20, _x21) {
        return _get.apply(this, arguments);
      }
      return get;
    }()
  }, {
    key: "exists",
    value: function exists(path) {
      return this._request({
        route: "/exists/".concat(this.db.database, "/").concat(path)
      });
    }
  }, {
    key: "query",
    value: function () {
      var _query2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(path, _query) {
        var _this4 = this;
        var options,
          request,
          containsRealtime,
          reqData,
          _yield$this$_request4,
          data,
          context,
          _ivipbase_core_1$Tran,
          list,
          isMore,
          socketSend,
          stop,
          _args17 = arguments;
        return _regeneratorRuntime().wrap(function _callee16$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              options = _args17.length > 2 && _args17[2] !== undefined ? _args17[2] : {
                snapshots: false,
                monitor: {
                  add: false,
                  change: false,
                  remove: false
                }
              };
              request = {
                query: _query,
                options: options
              };
              containsRealtime = (options.monitor === true || _typeof(options.monitor) === "object" && (options.monitor.add || options.monitor.change || options.monitor.remove)) && typeof options.eventHandler === "function";
              if (!(options.monitor === true || _typeof(options.monitor) === "object" && (options.monitor.add || options.monitor.change || options.monitor.remove))) {
                _context17.next = 10;
                break;
              }
              console.assert(typeof options.eventHandler === "function", "no eventHandler specified to handle realtime changes");
              if (this.app.socket) {
                _context17.next = 7;
                break;
              }
              throw new Error("Cannot create realtime query because websocket is not connected. Check your AceBaseClient network.realtime setting");
            case 7:
              request.query_id = ivipbase_core_1.ID.generate();
              request.client_id = this.app.id;
              this._realtimeQueries[request.query_id] = {
                path: path,
                query_id: request.query_id,
                query: _query,
                options: Object.assign(Object.assign({}, options), {
                  eventHandler: undefined
                }),
                matchedPaths: []
              };
            case 10:
              reqData = JSON.stringify(ivipbase_core_1.Transport.serialize(request));
              _context17.prev = 11;
              _context17.next = 14;
              return this._request({
                method: "POST",
                route: "/query/".concat(this.db.database, "/").concat(path),
                data: reqData,
                includeContext: true
              });
            case 14:
              _yield$this$_request4 = _context17.sent;
              data = _yield$this$_request4.data;
              context = _yield$this$_request4.context;
              _ivipbase_core_1$Tran = ivipbase_core_1.Transport.deserialize(data), list = _ivipbase_core_1$Tran.list, isMore = _ivipbase_core_1$Tran.isMore;
              if (containsRealtime && typeof request.query_id === "string") {
                this._realtimeQueries[request.query_id].matchedPaths = list.map(function (n) {
                  return n.path;
                });
                socketSend = this.app.websocketRequest(this.app.socket, "query-subscribe", this._realtimeQueries[request.query_id], this.db.name);
              }
              stop = /*#__PURE__*/function () {
                var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
                  return _regeneratorRuntime().wrap(function _callee15$(_context16) {
                    while (1) switch (_context16.prev = _context16.next) {
                      case 0:
                        if (!(!containsRealtime && socketSend !== undefined)) {
                          _context16.next = 2;
                          break;
                        }
                        return _context16.abrupt("return");
                      case 2:
                        _context16.next = 4;
                        return socketSend;
                      case 4:
                        delete _this4._realtimeQueries[request.query_id];
                        _context16.next = 7;
                        return _this4.app.websocketRequest(_this4.app.socket, "query-unsubscribe", {
                          query_id: request.query_id
                        }, _this4.db.name);
                      case 7:
                      case "end":
                        return _context16.stop();
                    }
                  }, _callee15);
                }));
                return function stop() {
                  return _ref5.apply(this, arguments);
                };
              }();
              return _context17.abrupt("return", {
                results: list,
                context: context,
                stop: stop,
                isMore: isMore
              });
            case 23:
              _context17.prev = 23;
              _context17.t0 = _context17["catch"](11);
              if (typeof request.query_id === "string" && request.query_id in this._realtimeQueries) {
                delete this._realtimeQueries[request.query_id];
              }
              throw _context17.t0;
            case 27:
            case "end":
              return _context17.stop();
          }
        }, _callee16, this, [[11, 23]]);
      }));
      function query(_x22, _x23) {
        return _query2.apply(this, arguments);
      }
      return query;
    }()
  }, {
    key: "reflect",
    value: function reflect(path, type, args) {
      var route = "/reflect/".concat(this.db.database, "/").concat(path, "?type=").concat(type);
      if (_typeof(args) === "object") {
        var query = Object.keys(args).map(function (key) {
          return "".concat(key, "=").concat(args[key]);
        });
        if (query.length > 0) {
          route += "&".concat(query.join("&"));
        }
      }
      return this._request({
        route: route
      });
    }
  }, {
    key: "export",
    value: function _export(path, write) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        format: "json",
        type_safe: true
      };
      options.format = "json";
      options.type_safe = options.type_safe !== false;
      var route = "/export/".concat(this.db.database, "/").concat(path, "?format=").concat(options.format, "&type_safe=").concat(options.type_safe ? 1 : 0);
      return this._request({
        route: route,
        dataReceivedCallback: function dataReceivedCallback(chunk) {
          return write(chunk);
        }
      });
    }
  }, {
    key: "import",
    value: function _import(path, read) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        format: "json",
        suppress_events: false
      };
      options.format = "json";
      options.suppress_events = options.suppress_events === true;
      var route = "/import/".concat(this.db.database, "/").concat(path, "?format=").concat(options.format, "&suppress_events=").concat(options.suppress_events ? 1 : 0);
      return this._request({
        method: "POST",
        route: route,
        dataRequestCallback: function dataRequestCallback(length) {
          return read(length);
        }
      });
    }
  }, {
    key: "getServerInfo",
    value: function () {
      var _getServerInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
        var _this5 = this;
        var info;
        return _regeneratorRuntime().wrap(function _callee17$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              _context18.next = 2;
              return this._request({
                route: "/info/".concat(this.db.database)
              })["catch"](function (err) {
                // Prior to acebase-server v0.9.37, info was at /info (no dbname attached)
                if (!err.isNetworkError) {
                  _this5.db.debug.warn("Could not get server info, update your acebase server version");
                }
                return {
                  version: "unknown",
                  time: Date.now()
                };
              });
            case 2:
              info = _context18.sent;
              return _context18.abrupt("return", info);
            case 4:
            case "end":
              return _context18.stop();
          }
        }, _callee17, this);
      }));
      function getServerInfo() {
        return _getServerInfo.apply(this, arguments);
      }
      return getServerInfo;
    }()
  }, {
    key: "setSchema",
    value: function setSchema(path, schema) {
      var warnOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (schema !== null) {
        schema = new ivipbase_core_1.SchemaDefinition(schema).text;
      }
      var data = JSON.stringify({
        action: "set",
        path: path,
        schema: schema,
        warnOnly: warnOnly
      });
      return this._request({
        method: "POST",
        route: "/schema/".concat(this.db.database),
        data: data
      });
    }
  }, {
    key: "getSchema",
    value: function getSchema(path) {
      return this._request({
        route: "/schema/".concat(this.db.database, "/").concat(path)
      });
    }
  }, {
    key: "getSchemas",
    value: function getSchemas() {
      return this._request({
        route: "/schema/".concat(this.db.database)
      });
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "validateSchema",
    value: function () {
      var _validateSchema = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(path, value, isUpdate) {
        return _regeneratorRuntime().wrap(function _callee18$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              throw new Error("Manual schema validation can only be used on standalone databases");
            case 1:
            case "end":
              return _context19.stop();
          }
        }, _callee18);
      }));
      function validateSchema(_x24, _x25, _x26) {
        return _validateSchema.apply(this, arguments);
      }
      return validateSchema;
    }()
  }]);
}(ivipbase_core_1.Api);
exports.StorageDBClient = StorageDBClient;

},{"../auth":5,"../controller/request/error":10,"ivipbase-core":152}],21:[function(require,module,exports){
(function (process){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StorageDBServer = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var MDE_1 = require("../controller/storage/MDE");
var utils_1 = require("../utils");
var executeQuery_1 = __importDefault(require("../controller/executeQuery"));
var ivip_utils_1 = require("ivip-utils");
var StorageDBServer = /*#__PURE__*/function (_ivipbase_core_1$Api) {
  function StorageDBServer(db) {
    var _this;
    _classCallCheck(this, StorageDBServer);
    _this = _callSuper(this, StorageDBServer);
    _this.db = db;
    _this.cache = {};
    _this.db.app.storage.ready(function () {
      _this.db.emit("ready");
    });
    return _this;
  }
  _inherits(StorageDBServer, _ivipbase_core_1$Api);
  return _createClass(StorageDBServer, [{
    key: "getInfo",
    value: function () {
      var _getInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", {
                dbname: this.db.database,
                version: "",
                time: Date.now(),
                process: process.pid
              });
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getInfo() {
        return _getInfo.apply(this, arguments);
      }
      return getInfo;
    }()
  }, {
    key: "stats",
    value: function () {
      var _stats = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", {
                writes: 0,
                reads: 0,
                bytesRead: 0,
                bytesWritten: 0
              });
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function stats() {
        return _stats.apply(this, arguments);
      }
      return stats;
    }()
  }, {
    key: "subscribe",
    value: function subscribe(path, event, callback, settings) {
      this.db.subscriptions.add(path, event, callback);
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(path, event, callback) {
      this.db.subscriptions.remove(path, event, callback);
    }
  }, {
    key: "set",
    value: function () {
      var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(path, value, options) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.db.app.storage.set(this.db.database, path, value);
            case 2:
              return _context3.abrupt("return", {});
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function set(_x, _x2, _x3) {
        return _set.apply(this, arguments);
      }
      return set;
    }()
  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(path, options) {
        var value;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!options) {
                options = {};
              }
              if (!(typeof options.include !== "undefined" && !(options.include instanceof Array))) {
                _context4.next = 3;
                break;
              }
              throw new TypeError("options.include must be an array of key names");
            case 3:
              if (!(typeof options.exclude !== "undefined" && !(options.exclude instanceof Array))) {
                _context4.next = 5;
                break;
              }
              throw new TypeError("options.exclude must be an array of key names");
            case 5:
              _context4.next = 7;
              return this.db.app.storage.get(this.db.database, path, options);
            case 7:
              value = _context4.sent;
              return _context4.abrupt("return", {
                value: value,
                context: {
                  more: false
                }
              });
            case 9:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function get(_x4, _x5) {
        return _get.apply(this, arguments);
      }
      return get;
    }()
  }, {
    key: "update",
    value: function () {
      var _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(path, updates, options) {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.db.app.storage.update(this.db.database, path, updates);
            case 2:
              return _context5.abrupt("return", {});
            case 3:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function update(_x6, _x7, _x8) {
        return _update.apply(this, arguments);
      }
      return update;
    }()
  }, {
    key: "transaction",
    value: function () {
      var _transaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(path, callback) {
        var options,
          cursor,
          _args6 = arguments;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              options = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : {
                suppress_events: false,
                context: null
              };
              _context6.next = 3;
              return this.db.app.storage.transact(this.db.database, path, callback, {
                suppress_events: options.suppress_events,
                context: options.context
              });
            case 3:
              cursor = _context6.sent;
              return _context6.abrupt("return", Object.assign({}, cursor && {
                cursor: cursor
              }));
            case 5:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function transaction(_x9, _x10) {
        return _transaction.apply(this, arguments);
      }
      return transaction;
    }()
  }, {
    key: "exists",
    value: function () {
      var _exists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(path) {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.db.app.storage.isPathExists(this.db.database, path);
            case 2:
              return _context7.abrupt("return", _context7.sent);
            case 3:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function exists(_x11) {
        return _exists.apply(this, arguments);
      }
      return exists;
    }()
  }, {
    key: "query",
    value: function () {
      var _query2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(path, _query) {
        var options,
          results,
          _args8 = arguments;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              options = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : {
                snapshots: false
              };
              _context8.next = 3;
              return (0, executeQuery_1["default"])(this.db, path, _query, options);
            case 3:
              results = _context8.sent;
              return _context8.abrupt("return", results);
            case 5:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function query(_x12, _x13) {
        return _query2.apply(this, arguments);
      }
      return query;
    }()
  }, {
    key: "export",
    value: function () {
      var _export2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(path, stream, options) {
        var data, json, i;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              if (!((options === null || options === void 0 ? void 0 : options.format) !== "json")) {
                _context9.next = 2;
                break;
              }
              throw new Error("Only json output is currently supported");
            case 2:
              _context9.next = 4;
              return this.get(path);
            case 4:
              data = _context9.sent;
              json = JSON.stringify(data.value, null, 4);
              i = 0;
            case 7:
              if (!(i < json.length)) {
                _context9.next = 13;
                break;
              }
              _context9.next = 10;
              return stream(json.slice(i, i + 1000));
            case 10:
              i += 1000;
              _context9.next = 7;
              break;
            case 13:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function _export(_x14, _x15, _x16) {
        return _export2.apply(this, arguments);
      }
      return _export;
    }()
  }, {
    key: "import",
    value: function () {
      var _import2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(path, read, options) {
        var _this2 = this;
        var _a, chunkSize, json, method, value, resolveObject;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              chunkSize = 256 * 1024; // 256KB
              _context11.next = 3;
              return read(chunkSize);
            case 3:
              json = _context11.sent;
              method = (_a = options === null || options === void 0 ? void 0 : options.method) !== null && _a !== void 0 ? _a : "update";
              options = Object.assign(Object.assign({}, options || {}), {
                method: method
              });
              if (!(typeof json !== "string" || !(0, ivip_utils_1.isJson)(json))) {
                _context11.next = 8;
                break;
              }
              return _context11.abrupt("return");
            case 8:
              value = JSON.parse(json);
              if (method === "set") {
                this.db.app.storage.set(this.db.database, path, value, options);
              } else {
                this.db.app.storage.update(this.db.database, path, value, options);
              }
              return _context11.abrupt("return");
            case 15:
              _context11.next = 24;
              break;
            case 17:
              if (!(method === "set")) {
                _context11.next = 22;
                break;
              }
              _context11.next = 20;
              return this.db.app.storage.set(this.db.database, path, value, options);
            case 20:
              _context11.next = 24;
              break;
            case 22:
              _context11.next = 24;
              return this.db.app.storage.update(this.db.database, path, value, options);
            case 24:
              return _context11.abrupt("return");
            case 25:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function _import(_x17, _x18, _x19) {
        return _import2.apply(this, arguments);
      }
      return _import;
    }()
  }, {
    key: "reflect",
    value: function () {
      var _reflect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(path, type, args) {
        var _this3 = this;
        var _a, _b, _c, _d, _e, _f, getChildren, result, info, nodeInfo, isObjectOrArray;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              args = args || {};
              getChildren = /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(path) {
                  var limit,
                    skip,
                    from,
                    children,
                    n,
                    stop,
                    more,
                    _args12 = arguments;
                  return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                    while (1) switch (_context12.prev = _context12.next) {
                      case 0:
                        limit = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : 50;
                        skip = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : 0;
                        from = _args12.length > 3 && _args12[3] !== undefined ? _args12[3] : null;
                        if (typeof limit === "string") {
                          limit = parseInt(limit);
                        }
                        if (typeof skip === "string") {
                          skip = parseInt(skip);
                        }
                        if (["null", "undefined", null, undefined].includes(from)) {
                          from = null;
                        }
                        children = []; // Array<{ key: string | number; type: string; value: any; address?: any }>;
                        n = 0, stop = false, more = false; //stop = skip + limit,
                        _context12.next = 10;
                        return _this3.db.app.storage.getChildren(_this3.db.database, path).next(function (childInfo) {
                          var _a, _b, _c;
                          if (stop) {
                            // Stop 1 child too late on purpose to make sure there's more
                            more = true;
                            return false; // Stop iterating
                          }
                          n++;
                          var include = from !== null && childInfo.key ? childInfo.key > from : skip === 0 || n > skip;
                          if (include) {
                            children.push((0, utils_1.removeNulls)(Object.assign({
                              key: (_a = typeof childInfo.key === "string" ? childInfo.key : childInfo.index) !== null && _a !== void 0 ? _a : "",
                              type: (_b = childInfo.valueTypeName) !== null && _b !== void 0 ? _b : "unknown",
                              value: (_c = childInfo.value) !== null && _c !== void 0 ? _c : null
                            }, _typeof(childInfo.address) === "object" && {
                              address: childInfo.address
                            })));
                          }
                          stop = limit > 0 && children.length === limit;
                        })["catch"](function (err) {
                          throw err;
                        });
                      case 10:
                        return _context12.abrupt("return", {
                          more: more,
                          list: children
                        });
                      case 11:
                      case "end":
                        return _context12.stop();
                    }
                  }, _callee12);
                }));
                return function getChildren(_x25) {
                  return _ref2.apply(this, arguments);
                };
              }();
              _context13.t0 = type;
              _context13.next = _context13.t0 === "children" ? 5 : _context13.t0 === "info" ? 9 : 29;
              break;
            case 5:
              _context13.next = 7;
              return getChildren(path, args.limit, args.skip, args.from);
            case 7:
              result = _context13.sent;
              return _context13.abrupt("return", result);
            case 9:
              info = {
                key: "",
                exists: false,
                type: "unknown",
                value: undefined,
                address: undefined,
                children: {
                  count: 0,
                  more: false,
                  list: []
                }
              };
              _context13.next = 12;
              return this.db.app.storage.getInfoBy(this.db.database, path, {
                include_child_count: args.child_count === true
              });
            case 12:
              nodeInfo = _context13.sent;
              info.key = (_a = typeof nodeInfo.key !== "undefined" ? nodeInfo.key : nodeInfo.index) !== null && _a !== void 0 ? _a : "";
              info.exists = (_b = nodeInfo.exists) !== null && _b !== void 0 ? _b : false;
              info.type = (_c = nodeInfo.exists ? nodeInfo.valueTypeName : undefined) !== null && _c !== void 0 ? _c : "unknown";
              if (![MDE_1.VALUE_TYPES.OBJECT, MDE_1.VALUE_TYPES.ARRAY].includes((_d = nodeInfo.type) !== null && _d !== void 0 ? _d : 0)) {
                info.value = nodeInfo.value;
              }
              info.address = _typeof(nodeInfo.address) === "object" ? nodeInfo.address : undefined;
              isObjectOrArray = nodeInfo.exists && [MDE_1.VALUE_TYPES.OBJECT, MDE_1.VALUE_TYPES.ARRAY].includes((_e = nodeInfo.type) !== null && _e !== void 0 ? _e : 0);
              if (!(args.child_count === true)) {
                _context13.next = 23;
                break;
              }
              info.children = {
                count: isObjectOrArray ? (_f = nodeInfo.childCount) !== null && _f !== void 0 ? _f : 0 : 0
              };
              _context13.next = 28;
              break;
            case 23:
              if (!(typeof args.child_limit === "number" && args.child_limit > 0)) {
                _context13.next = 28;
                break;
              }
              if (!isObjectOrArray) {
                _context13.next = 28;
                break;
              }
              _context13.next = 27;
              return getChildren(path, args.child_limit, args.child_skip, args.child_from);
            case 27:
              info.children = _context13.sent;
            case 28:
              return _context13.abrupt("return", info);
            case 29:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function reflect(_x22, _x23, _x24) {
        return _reflect.apply(this, arguments);
      }
      return reflect;
    }()
  }, {
    key: "setSchema",
    value: function setSchema(path, schema, warnOnly) {
      var _this4 = this;
      return new Promise(function (resolve, reject) {
        resolve(_this4.db.app.storage.setSchema(_this4.db.database, path, schema, warnOnly));
      });
    }
  }, {
    key: "getSchema",
    value: function getSchema(path) {
      var _this5 = this;
      return new Promise(function (resolve, reject) {
        resolve(_this5.db.app.storage.getSchema(_this5.db.database, path));
      });
    }
  }, {
    key: "getSchemas",
    value: function () {
      var _getSchemas = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
        var _this6 = this;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              return _context14.abrupt("return", new Promise(function (resolve, reject) {
                resolve(_this6.db.app.storage.getSchemas(_this6.db.database));
              }));
            case 1:
            case "end":
              return _context14.stop();
          }
        }, _callee14);
      }));
      function getSchemas() {
        return _getSchemas.apply(this, arguments);
      }
      return getSchemas;
    }()
  }, {
    key: "validateSchema",
    value: function validateSchema(path, value, isUpdate) {
      var _this7 = this;
      return new Promise(function (resolve, reject) {
        resolve(_this7.db.app.storage.validateSchema(_this7.db.database, path, value, {
          updates: isUpdate
        }));
      });
    }
  }]);
}(ivipbase_core_1.Api);
exports.StorageDBServer = StorageDBServer;

}).call(this)}).call(this,require('_process'))
},{"../controller/executeQuery":9,"../controller/storage/MDE":16,"../utils":37,"_process":155,"ivip-utils":125,"ivipbase-core":152}],22:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Subscriptions = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var utils_1 = require("../utils");
var SUPPORTED_EVENTS = ["value", "child_added", "child_changed", "child_removed", "mutated", "mutations"];
SUPPORTED_EVENTS.push.apply(SUPPORTED_EVENTS, _toConsumableArray(SUPPORTED_EVENTS.map(function (event) {
  return "notify_".concat(event);
})));
var Subscriptions = /*#__PURE__*/function (_ivipbase_core_1$Simp) {
  function Subscriptions(dbName, app) {
    var _this;
    _classCallCheck(this, Subscriptions);
    _this = _callSuper(this, Subscriptions);
    _this.dbName = dbName;
    _this.app = app;
    _this._eventSubscriptions = {};
    return _this;
  }
  _inherits(Subscriptions, _ivipbase_core_1$Simp);
  return _createClass(Subscriptions, [{
    key: "initialize",
    value: function initialize() {
      var _this2 = this;
      var applyEvent = function applyEvent() {
        var _a;
        return (_a = _this2.app.ipc) === null || _a === void 0 ? void 0 : _a.on("triggerEvents", function (data) {
          var _a;
          if (data.dbName !== _this2.dbName) {
            return;
          }
          _this2.triggerAllEvents(data.path, data.oldValue, data.newValue, Object.assign(Object.assign({}, (_a = data.options) !== null && _a !== void 0 ? _a : {}), {
            emitIpc: false
          }));
        });
      };
      this.on("subscribe", function () {
        if (!_this2._event) {
          _this2._event = applyEvent();
        }
      });
      this._event = applyEvent();
    }
  }, {
    key: "forEach",
    value: function forEach(callback) {
      var _this3 = this;
      Object.keys(this._eventSubscriptions).forEach(function (path) {
        _this3._eventSubscriptions[path].forEach(function (sub) {
          callback(sub.type, path, sub.callback);
        });
      });
    }
  }, {
    key: "countByPath",
    value: function countByPath(path) {
      return (this._eventSubscriptions[path] || []).length;
    }
    /**
     * Adiciona uma assinatura a um nó
     * @param path Caminho para o nó ao qual adicionar a assinatura
     * @param type Tipo da assinatura
     * @param callback Função de retorno de chamada da assinatura
     */
  }, {
    key: "add",
    value: function add(path, type, callback) {
      if (SUPPORTED_EVENTS.indexOf(type) < 0) {
        throw new TypeError("Invalid event type \"".concat(type, "\""));
      }
      var pathSubs = this._eventSubscriptions[path];
      if (!pathSubs) {
        pathSubs = this._eventSubscriptions[path] = [];
      }
      // if (pathSubs.findIndex(ps => ps.type === type && ps.callback === callback)) {
      //     storage.debug.warn(`Identical subscription of type ${type} on path "${path}" being added`);
      // }
      pathSubs.push({
        created: Date.now(),
        type: type,
        callback: callback
      });
      this.emit("subscribe", {
        path: path,
        event: type,
        callback: callback
      });
    }
    /**
     * Remove 1 ou mais assinaturas de um nó
     * @param path Caminho para o nó do qual remover a assinatura
     * @param type Tipo de assinatura(s) a ser removido (opcional: se omitido, todos os tipos serão removidos)
     * @param callback Callback a ser removido (opcional: se omitido, todos do mesmo tipo serão removidos)
     */
  }, {
    key: "remove",
    value: function remove(path, type, callback) {
      var pathSubs = this._eventSubscriptions[path];
      if (!pathSubs) {
        return;
      }
      var next = function next() {
        return pathSubs.findIndex(function (ps) {
          return (type ? ps.type === type : true) && (callback ? ps.callback === callback : true);
        });
      };
      var i;
      while ((i = next()) >= 0) {
        pathSubs.splice(i, 1);
      }
      this.emit("unsubscribe", {
        path: path,
        event: type,
        callback: callback
      });
    }
    /**
     * Verifica se existem assinantes no caminho fornecido que precisam do valor anterior do nó quando uma alteração é acionada
     * @param path
     */
  }, {
    key: "hasValueSubscribersForPath",
    value: function hasValueSubscribersForPath(path) {
      var valueNeeded = this.getValueSubscribersForPath(path);
      return !!valueNeeded;
    }
    /**
     * Obtém todos os assinantes no caminho fornecido que precisam do valor anterior do nó quando uma alteração é acionada
     * @param path
     */
  }, {
    key: "getValueSubscribersForPath",
    value: function getValueSubscribersForPath(path) {
      var _this4 = this;
      // Assinantes que DEVEM ter o valor anterior completo de um nó antes da atualização:
      //  - Eventos "value" no próprio caminho e em qualquer caminho ancestral
      //  - Eventos "child_added", "child_removed" no caminho pai
      //  - Eventos "child_changed" no caminho pai e em seus ancestrais
      //  - TODOS os eventos em caminhos filhos/descendentes
      var pathInfo = new ivipbase_core_1.PathInfo(path);
      var valueSubscribers = [];
      Object.keys(this._eventSubscriptions).forEach(function (subscriptionPath) {
        if (pathInfo.equals(subscriptionPath) || pathInfo.isDescendantOf(subscriptionPath)) {
          // Caminho sendo atualizado === subscriptionPath, ou um caminho filho/descendente dele
          // por exemplo, caminho === "posts/123/title"
          // e subscriptionPath é "posts/123/title", "posts/$postId/title", "posts/123", "posts/*", "posts", etc.
          var pathSubs = _this4._eventSubscriptions[subscriptionPath];
          var eventPath = ivipbase_core_1.PathInfo.fillVariables(subscriptionPath, path);
          pathSubs.filter(function (sub) {
            return !sub.type.startsWith("notify_");
          }) // Eventos de notificação não precisam de carregamento de valor adicional
          .forEach(function (sub) {
            var dataPath = null;
            if (sub.type === "value") {
              // ["value", "notify_value"].includes(sub.type)
              dataPath = eventPath;
            } else if (["mutated", "mutations"].includes(sub.type) && pathInfo.isDescendantOf(eventPath)) {
              //["mutated", "notify_mutated"].includes(sub.type)
              dataPath = path; // A única informação necessária são as propriedades sendo atualizadas no caminho alvo
            } else if (sub.type === "child_changed" && path !== eventPath) {
              // ["child_changed", "notify_child_changed"].includes(sub.type)
              var childKey = ivipbase_core_1.PathInfo.getPathKeys(path.slice(eventPath.length).replace(/^\//, ""))[0];
              dataPath = childKey !== "" ? ivipbase_core_1.PathInfo.getChildPath(eventPath, childKey) : null;
            } else if (["child_added", "child_removed"].includes(sub.type) && pathInfo.isChildOf(eventPath)) {
              //["child_added", "child_removed", "notify_child_added", "notify_child_removed"]
              var _childKey = ivipbase_core_1.PathInfo.getPathKeys(path.slice(eventPath.length).replace(/^\//, ""))[0];
              dataPath = _childKey !== "" ? ivipbase_core_1.PathInfo.getChildPath(eventPath, _childKey) : null;
            }
            if (dataPath !== null && !valueSubscribers.some(function (s) {
              return s.type === sub.type && s.eventPath === eventPath;
            })) {
              valueSubscribers.push({
                type: sub.type,
                eventPath: eventPath,
                dataPath: dataPath,
                subscriptionPath: subscriptionPath
              });
            }
          });
        }
      });
      return valueSubscribers;
    }
    /**
     * Obtém todos os assinantes no caminho fornecido que possivelmente podem ser acionados após a atualização de um nó
     */
  }, {
    key: "getAllSubscribersForPath",
    value: function getAllSubscribersForPath(path) {
      var _this5 = this;
      var pathInfo = ivipbase_core_1.PathInfo.get(path);
      var subscribers = [];
      Object.keys(this._eventSubscriptions).forEach(function (subscriptionPath) {
        // if (pathInfo.equals(subscriptionPath) //path === subscriptionPath
        //     || pathInfo.isDescendantOf(subscriptionPath)
        //     || pathInfo.isAncestorOf(subscriptionPath)
        // ) {
        if (pathInfo.isOnTrailOf(subscriptionPath)) {
          var pathSubs = _this5._eventSubscriptions[subscriptionPath];
          var eventPath = ivipbase_core_1.PathInfo.fillVariables(subscriptionPath, path);
          pathSubs.forEach(function (sub) {
            var dataPath = null;
            if (sub.type === "value" || sub.type === "notify_value") {
              dataPath = eventPath;
            } else if (["child_changed", "notify_child_changed"].includes(sub.type)) {
              var childKey = path === eventPath || pathInfo.isAncestorOf(eventPath) ? "*" : ivipbase_core_1.PathInfo.getPathKeys(path.slice(eventPath.length).replace(/^\//, ""))[0];
              dataPath = childKey !== "" ? ivipbase_core_1.PathInfo.getChildPath(eventPath, childKey) : null;
            } else if (["mutated", "mutations", "notify_mutated", "notify_mutations"].includes(sub.type)) {
              dataPath = path;
            } else if (["child_added", "child_removed", "notify_child_added", "notify_child_removed"].includes(sub.type) && (pathInfo.isChildOf(eventPath) || path === eventPath || pathInfo.isAncestorOf(eventPath))) {
              var _childKey2 = path === eventPath || pathInfo.isAncestorOf(eventPath) ? "*" : ivipbase_core_1.PathInfo.getPathKeys(path.slice(eventPath.length).replace(/^\//, ""))[0];
              dataPath = _childKey2 !== "" ? ivipbase_core_1.PathInfo.getChildPath(eventPath, _childKey2) : null; //NodePath(subscriptionPath).childPath(childKey);
            }
            if (dataPath !== null && !subscribers.some(function (s) {
              return s.type === sub.type && s.eventPath === eventPath && s.subscriptionPath === subscriptionPath;
            })) {
              // && subscribers.findIndex(s => s.type === sub.type && s.dataPath === dataPath) < 0
              subscribers.push({
                type: sub.type,
                eventPath: eventPath,
                dataPath: dataPath,
                subscriptionPath: subscriptionPath
              });
            }
          });
        }
      });
      return subscribers;
    }
    /**
     * Aciona eventos de assinatura para serem executados em nós relevantes
     * @param event Tipo de evento: "value", "child_added", "child_changed", "child_removed"
     * @param path Caminho para o nó no qual a assinatura está presente
     * @param dataPath Caminho para o nó onde o valor está armazenado
     * @param oldValue Valor antigo
     * @param newValue Novo valor
     * @param context Contexto usado pelo cliente que atualizou esses dados
     */
  }, {
    key: "trigger",
    value: (function () {
      var _trigger = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(event, path, dataPath, oldValue, newValue, context) {
        var _this6 = this;
        var pathSubscriptions;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(["value", "child_added", "child_changed", "child_removed"].includes(event) && ["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(newValue)))) {
                _context.next = 3;
                break;
              }
              _context.next = 3;
              return new Promise(function (resolve) {
                var timer;
                var callback = function callback(err, mutatedPath, value, previous) {
                  clearTimeout(timer);
                  if (!err) {
                    var propertyTrail = ivipbase_core_1.PathInfo.getPathKeys(mutatedPath.slice(dataPath.length + 1));
                    var asingObj = function asingObj(obj, value) {
                      var insist = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
                      if (["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(obj)) !== true) {
                        return;
                      }
                      var targetObject = obj;
                      var targetProperty = propertyTrail.slice(-1)[0];
                      var _iterator = _createForOfIteratorHelper(propertyTrail.slice(0, -1)),
                        _step;
                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                          var p = _step.value;
                          if (!(p in targetObject)) {
                            if (!insist) {
                              return;
                            }
                            targetObject[p] = typeof p === "number" ? [] : {};
                          }
                          targetObject = targetObject[p];
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }
                      if (value === null) {
                        delete targetObject[targetProperty];
                      } else {
                        targetObject[targetProperty] = value;
                      }
                    };
                    asingObj(newValue, value);
                    asingObj(oldValue, previous, false);
                  }
                  timer = setTimeout(function () {
                    _this6.remove(dataPath, "mutated", callback);
                    resolve();
                  }, 500);
                };
                _this6.add(dataPath, "mutated", callback);
                timer = setTimeout(function () {
                  _this6.remove(dataPath, "mutated", callback);
                  resolve();
                }, 500);
              });
            case 3:
              pathSubscriptions = this._eventSubscriptions[path] || [];
              pathSubscriptions.filter(function (sub) {
                return sub.type === event;
              }).forEach(function (sub) {
                sub.callback(null, dataPath, newValue, oldValue, context);
                // if (event.startsWith('notify_')) {
                //     // Notify only event, run callback without data
                //     sub.callback(null, dataPath);
                // }
                // else {
                //     // Run callback with data
                //     sub.callback(null, dataPath, newValue, oldValue);
                // }
              });
            case 5:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function trigger(_x, _x2, _x3, _x4, _x5, _x6) {
        return _trigger.apply(this, arguments);
      }
      return trigger;
    }()
    /**
     * Obtém o impacto de uma atualização no caminho especificado, considerando as assinaturas relevantes.
     * @param path Caminho para a atualização.
     * @param suppressEvents Indica se os eventos devem ser suprimidos.
     * @returns Um objeto contendo informações sobre o impacto da atualização, incluindo caminho de evento superior, assinaturas de evento, assinaturas de valor e indicador de assinaturas de valor existentes.
     */
    )
  }, {
    key: "getUpdateImpact",
    value: function getUpdateImpact(path) {
      var suppressEvents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var topEventPath = path;
      var hasValueSubscribers = false;
      // Obter todas as assinaturas que devem ser executadas nos dados (inclui eventos em nós filhos também)
      var eventSubscriptions = suppressEvents ? [] : this.getAllSubscribersForPath(path);
      // Obter todas as assinaturas para dados neste ou em nós ancestrais, determina quais dados carregar antes do processamento
      var valueSubscribers = suppressEvents ? [] : this.getValueSubscribersForPath(path);
      if (valueSubscribers.length > 0) {
        hasValueSubscribers = true;
        var eventPaths = valueSubscribers.map(function (sub) {
          return {
            path: sub.dataPath,
            keys: ivipbase_core_1.PathInfo.getPathKeys(sub.dataPath)
          };
        }).sort(function (a, b) {
          if (a.keys.length < b.keys.length) {
            return -1;
          } else if (a.keys.length > b.keys.length) {
            return 1;
          }
          return 0;
        });
        var first = eventPaths[0];
        topEventPath = first.path;
        if (valueSubscribers.filter(function (sub) {
          return sub.dataPath === topEventPath;
        }).every(function (sub) {
          return sub.type === "mutated" || sub.type.startsWith("notify_");
        })) {
          // Impede o carregamento de todos os dados no caminho, para que apenas as propriedades que mudam sejam carregadas
          hasValueSubscribers = false;
        }
        topEventPath = ivipbase_core_1.PathInfo.fillVariables(topEventPath, path); // Preenche quaisquer curingas no caminho da assinatura
      }
      return {
        topEventPath: topEventPath,
        eventSubscriptions: eventSubscriptions,
        valueSubscribers: valueSubscribers,
        hasValueSubscribers: hasValueSubscribers
      };
    }
    /**
     * Executa um callback para cada assinante de valor associado a um caminho, considerando as mudanças nos valores antigo e novo.
     * @param sub Assinante de valor (snapshot) obtido de `this.getValueSubscribersForPath`.
     * @param oldValue Valor antigo.
     * @param newValue Novo valor.
     * @param variables Array de objetos contendo variáveis a serem substituídas no caminho.
     */
  }, {
    key: "callSubscriberWithValues",
    value: function callSubscriberWithValues(sub, currentPath, oldValue, newValue) {
      var variables = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
      var trigger = true;
      var type = sub.type;
      if (type.startsWith("notify_")) {
        type = type.slice("notify_".length);
      }
      if (type === "mutated") {
        return; // Ignore here, requires different logic
      } else if (type === "child_changed" && (oldValue === null || newValue === null)) {
        trigger = false;
      } else if (type === "value" || type === "child_changed") {
        var changes = ivipbase_core_1.Utils.compareValues(oldValue, newValue);
        trigger = changes !== "identical";
      } else if (type === "child_added") {
        trigger = oldValue === null && newValue !== null;
      } else if (type === "child_removed") {
        trigger = oldValue !== null && newValue === null;
      }
      if (!trigger) {
        return;
      }
      var pathKeys = ivipbase_core_1.PathInfo.getPathKeys(sub.dataPath);
      variables.forEach(function (variable) {
        // only replaces first occurrence (so multiple *'s will be processed 1 by 1)
        var index = pathKeys.indexOf(variable.name);
        (0, utils_1.assert)(index >= 0, "Variable \"".concat(variable.name, "\" not found in subscription dataPath \"").concat(sub.dataPath, "\""));
        pathKeys[index] = variable.value;
      });
      var dataPath = pathKeys.reduce(function (path, key) {
        return key !== "" ? ivipbase_core_1.PathInfo.getChildPath(path, key) : path;
      }, "");
      if (type === "value") {
        oldValue = (0, utils_1.pathValueToObject)(dataPath, currentPath, oldValue);
        newValue = (0, utils_1.pathValueToObject)(dataPath, currentPath, newValue);
      }
      this.trigger(sub.type, sub.subscriptionPath, dataPath, oldValue, newValue, {});
    }
    /**
     * Prepara eventos de mutação com base nas alterações entre um valor antigo e um novo em um determinado caminho.
     * @param currentPath Caminho atual onde as alterações ocorreram.
     * @param oldValue Valor antigo.
     * @param newValue Novo valor.
     * @param compareResult Resultado da comparação entre valores antigo e novo (opcional).
     * @returns Uma matriz de objetos representando as alterações preparadas para eventos de mutação.
     */
  }, {
    key: "prepareMutationEvents",
    value: function prepareMutationEvents(currentPath, oldValue, newValue, compareResult) {
      var _this7 = this;
      var batch = [];
      var result = compareResult || ivipbase_core_1.Utils.compareValues(oldValue, newValue);
      if (result === "identical") {
        return batch; // sem alterações no caminho inscrito
      } else if (typeof result === "string") {
        // Estamos em um caminho com uma alteração real
        batch.push({
          path: currentPath,
          oldValue: oldValue,
          newValue: newValue
        });
      }
      // else if (oldValue instanceof Array || newValue instanceof Array) {
      //     // Trigger mutated event on the array itself instead of on individual indexes.
      //     // DO convert both arrays to objects because they are sparse
      //     const oldObj = {}, newObj = {};
      //     result.added.forEach(index => {
      //         oldObj[index] = null;
      //         newObj[index] = newValue[index];
      //     });
      //     result.removed.forEach(index => {
      //         oldObj[index] = oldValue[index];
      //         newObj[index] = null;
      //     });
      //     result.changed.forEach(index => {
      //         oldObj[index] = oldValue[index];
      //         newObj[index] = newValue[index];
      //     });
      //     batch.push({ path: currentPath, oldValue: oldObj, newValue: newObj });
      // }
      else {
        // Desabilitado: manipulação de arrays aqui, porque se um cliente estiver usando um banco de dados de cache, isso causará problemas,
        // pois as entradas individuais do array nunca devem ser modificadas.
        // if (oldValue instanceof Array && newValue instanceof Array) {
        //     // Make sure any removed events on arrays will be triggered from last to first
        //     result.removed.sort((a,b) => a < b ? 1 : -1);
        // }
        result.changed.forEach(function (info) {
          var childPath = ivipbase_core_1.PathInfo.getChildPath(currentPath, info.key);
          var childValues = ivipbase_core_1.Utils.getChildValues(info.key, oldValue, newValue);
          var childBatch = _this7.prepareMutationEvents(childPath, childValues.oldValue, childValues.newValue, info.change);
          batch.push.apply(batch, _toConsumableArray(childBatch));
        });
        result.added.forEach(function (key) {
          var childPath = ivipbase_core_1.PathInfo.getChildPath(currentPath, key);
          batch.push({
            path: childPath,
            oldValue: null,
            newValue: newValue[key]
          });
        });
        if (oldValue instanceof Array && newValue instanceof Array) {
          result.removed.sort(function (a, b) {
            return a < b ? 1 : -1;
          });
        }
        result.removed.forEach(function (key) {
          var childPath = ivipbase_core_1.PathInfo.getChildPath(currentPath, key);
          batch.push({
            path: childPath,
            oldValue: oldValue[key],
            newValue: null
          });
        });
      }
      return batch;
    }
  }, {
    key: "triggerAllEvents",
    value: function triggerAllEvents(path, oldValue, newValue) {
      var _this8 = this;
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        suppress_events: false,
        context: undefined,
        impact: undefined
      };
      var _a;
      var dataChanges = ivipbase_core_1.Utils.compareValues(oldValue, newValue);
      if (dataChanges === "identical") {
        return;
      }
      var emitIpc = typeof options.emitIpc === "boolean" ? options.emitIpc : true;
      if (emitIpc) {
        (_a = this.app.ipc) === null || _a === void 0 ? void 0 : _a.sendTriggerEvents(this.dbName, path, oldValue, newValue, options);
      }
      var updateImpact = options.impact ? options.impact : this.getUpdateImpact(path, options.suppress_events);
      var topEventPath = updateImpact.topEventPath,
        eventSubscriptions = updateImpact.eventSubscriptions,
        hasValueSubscribers = updateImpact.hasValueSubscribers,
        valueSubscribers = updateImpact.valueSubscribers;
      // Notifica todas as assinaturas de eventos, deve ser executado com um atraso
      eventSubscriptions.filter(function (sub) {
        return !["mutated", "mutations", "notify_mutated", "notify_mutations"].includes(sub.type);
      }).map(function (sub) {
        var keys = ivipbase_core_1.PathInfo.getPathKeys(sub.dataPath);
        return {
          sub: sub,
          keys: keys
        };
      }).sort(function (a, b) {
        // Os caminhos mais profundos devem ser acionados primeiro, depois subir na árvore
        if (a.keys.length < b.keys.length) {
          return 1;
        } else if (a.keys.length > b.keys.length) {
          return -1;
        }
        return 0;
      }).forEach(function (_ref) {
        var sub = _ref.sub;
        var process = function process(currentPath, oldValue, newValue) {
          var variables = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
          var trailPath = sub.dataPath.slice(currentPath.length).replace(/^\//, "");
          var trailKeys = ivipbase_core_1.PathInfo.getPathKeys(trailPath);
          var _loop = function _loop() {
              var subKey = trailKeys.shift();
              if (typeof subKey === "string" && (subKey === "*" || subKey[0] === "$")) {
                // Disparar em todas as chaves de filhos relevantes
                var allKeys = !oldValue ? [] : Object.keys(oldValue).map(function (key) {
                  return oldValue instanceof Array ? parseInt(key) : key;
                });
                newValue !== null && Object.keys(newValue).forEach(function (key) {
                  var keyOrIndex = newValue instanceof Array ? parseInt(key) : key;
                  !allKeys.includes(keyOrIndex) && allKeys.push(key);
                });
                allKeys.forEach(function (key) {
                  var childValues = ivipbase_core_1.Utils.getChildValues(key, oldValue, newValue);
                  var vars = variables.concat({
                    name: subKey,
                    value: key
                  });
                  if (trailKeys.length === 0) {
                    _this8.callSubscriberWithValues(sub, path, childValues.oldValue, childValues.newValue, vars);
                  } else {
                    process(ivipbase_core_1.PathInfo.getChildPath(currentPath, subKey), childValues.oldValue, childValues.newValue, vars);
                  }
                });
                return {
                  v: void 0
                }; // Podemos interromper o processamento
              } else if ((typeof subKey === "string" || typeof subKey === "number") && subKey !== "") {
                currentPath = ivipbase_core_1.PathInfo.getChildPath(currentPath, subKey);
                var childValues = ivipbase_core_1.Utils.getChildValues(subKey, oldValue, newValue);
                oldValue = childValues.oldValue;
                newValue = childValues.newValue;
              }
            },
            _ret;
          while (trailKeys.length > 0) {
            _ret = _loop();
            if (_ret) return _ret.v;
          }
          _this8.callSubscriberWithValues(sub, path, oldValue, newValue, variables);
        };
        if (sub.type.startsWith("notify_") && ivipbase_core_1.PathInfo.get(sub.eventPath).isAncestorOf(topEventPath)) {
          // Notificar evento em um caminho superior ao qual carregamos dados
          // Podemos acionar o evento de notificação no caminho assinado
          // Por exemplo:
          // path === 'users/ewout', updates === { name: 'Ewout Stortenbeker' }
          // sub.path === 'users' ou '', sub.type === 'notify_child_changed'
          // => OK para acionar se dataChanges !== 'removed' e 'added'
          var isOnParentPath = ivipbase_core_1.PathInfo.get(sub.eventPath).isParentOf(topEventPath);
          var trigger = sub.type === "notify_value" || sub.type === "notify_child_changed" && (!isOnParentPath || !["added", "removed"].includes(dataChanges)) || sub.type === "notify_child_removed" && dataChanges === "removed" && isOnParentPath || sub.type === "notify_child_added" && dataChanges === "added" && isOnParentPath;
          trigger && _this8.trigger(sub.type, sub.subscriptionPath, sub.dataPath, null, null, options.context);
        } else {
          // A assinatura está no caminho atual ou mais profundo
          process(topEventPath, oldValue, newValue);
        }
      });
      // Os únicos eventos que não processamos agora são eventos 'mutated'.
      // Eles requerem lógica diferente: os chamaremos para todas as propriedades aninhadas do caminho atualizado, que
      // realmente mudaram. Eles não se propagam como 'child_changed' faz.
      var mutationEvents = eventSubscriptions.filter(function (sub) {
        return ["mutated", "mutations", "notify_mutated", "notify_mutations"].includes(sub.type);
      });
      mutationEvents.forEach(function (sub) {
        // Obter os dados de destino nos quais esta assinatura está interessada
        var currentPath = topEventPath;
        // const trailPath = sub.eventPath.slice(currentPath.length).replace(/^\//, ''); // eventPath pode conter variáveis e * ?
        var trailKeys = ivipbase_core_1.PathInfo.getPathKeys(sub.eventPath).slice(ivipbase_core_1.PathInfo.getPathKeys(currentPath).length); //PathInfo.getPathKeys(trailPath);
        var events = [];
        var processNextTrailKey = function processNextTrailKey(target, currentTarget, oldValue, newValue, vars) {
          if (target.length === 0) {
            // Add it
            return events.push({
              target: currentTarget,
              oldValue: oldValue,
              newValue: newValue,
              vars: vars
            });
          }
          var subKey = target[0];
          var keys = new Set();
          var isWildcardKey = typeof subKey === "string" && (subKey === "*" || subKey.startsWith("$"));
          if (isWildcardKey) {
            // Recursivo para cada chave em oldValue e newValue
            if (oldValue !== null && _typeof(oldValue) === "object") {
              Object.keys(oldValue).forEach(function (key) {
                return keys.add(key);
              });
            }
            if (newValue !== null && _typeof(newValue) === "object") {
              Object.keys(newValue).forEach(function (key) {
                return keys.add(key);
              });
            }
          } else {
            keys.add(subKey); // apenas uma chave específica
          }
          var _iterator2 = _createForOfIteratorHelper(keys),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var key = _step2.value;
              var childValues = ivipbase_core_1.Utils.getChildValues(key, oldValue, newValue);
              oldValue = childValues.oldValue;
              newValue = childValues.newValue;
              processNextTrailKey(target.slice(1), currentTarget.concat(key), oldValue, newValue, isWildcardKey ? vars.concat({
                name: subKey,
                value: key
              }) : vars);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        };
        processNextTrailKey(trailKeys, [], oldValue, newValue, []);
        var _loop2 = function _loop2() {
          var event = _events[_i];
          var targetPath = ivipbase_core_1.PathInfo.get(currentPath).child(event.target).path;
          var batch = _this8.prepareMutationEvents(targetPath, event.oldValue, event.newValue);
          if (batch.length === 0) {
            return 1; // continue
          }
          var isNotifyEvent = sub.type.startsWith("notify_");
          if (["mutated", "notify_mutated"].includes(sub.type)) {
            // Enviar todas as mutações uma por uma
            batch.forEach(function (mutation, index) {
              var context = options.context; // const context = cloneObject(options.context);
              // context.acebase_mutated_event = { nr: index + 1, total: batch.length }; // Adicionar informações de contexto sobre o número de mutações
              var prevVal = isNotifyEvent ? null : mutation.oldValue;
              var newVal = isNotifyEvent ? null : mutation.newValue;
              _this8.trigger(sub.type, sub.subscriptionPath, mutation.path, prevVal, newVal, context);
            });
          } else if (["mutations", "notify_mutations"].includes(sub.type)) {
            // Enviar 1 lote com todas as mutações
            // const oldValues = isNotifyEvent ? null : batch.map(m => ({ target: PathInfo.getPathKeys(mutation.path.slice(sub.subscriptionPath.length)), val: m.oldValue })); // batch.reduce((obj, mutation) => (obj[mutation.path.slice(sub.subscriptionPath.length).replace(/^\//, '') || '.'] = mutation.oldValue, obj), {});
            // const newValues = isNotifyEvent ? null : batch.map(m => ({ target: PathInfo.getPathKeys(mutation.path.slice(sub.subscriptionPath.length)), val: m.newValue })) //batch.reduce((obj, mutation) => (obj[mutation.path.slice(sub.subscriptionPath.length).replace(/^\//, '') || '.'] = mutation.newValue, obj), {});
            var subscriptionPathKeys = ivipbase_core_1.PathInfo.getPathKeys(sub.subscriptionPath);
            var values = isNotifyEvent ? null : batch.map(function (m) {
              return {
                target: ivipbase_core_1.PathInfo.getPathKeys(m.path).slice(subscriptionPathKeys.length),
                prev: m.oldValue,
                val: m.newValue
              };
            });
            var dataPath = ivipbase_core_1.PathInfo.get(ivipbase_core_1.PathInfo.getPathKeys(targetPath).slice(0, subscriptionPathKeys.length)).path;
            _this8.trigger(sub.type, sub.subscriptionPath, dataPath, null, values, options.context);
          }
        };
        for (var _i = 0, _events = events; _i < _events.length; _i++) {
          if (_loop2()) continue;
        }
      });
    }
  }]);
}(ivipbase_core_1.SimpleEventEmitter);
exports.Subscriptions = Subscriptions;

},{"../utils":37,"ivipbase-core":152}],23:[function(require,module,exports){
"use strict";

function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SchemaValidationError = exports.hasDatabase = exports.getDatabasesNames = exports.getDatabase = exports.DataBase = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var app_1 = require("../app");
var StorageDBServer_1 = require("./StorageDBServer");
var StorageDBClient_1 = require("./StorageDBClient");
var Subscriptions_1 = require("./Subscriptions");
var rules_1 = require("./services/rules");
var utils_1 = require("../utils");
var DataBase = /*#__PURE__*/function (_ivipbase_core_1$Data) {
  function DataBase(database, app, options) {
    var _this;
    _classCallCheck(this, DataBase);
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    _this = _callSuper(this, DataBase, [database, options]);
    _this.database = database;
    _this.app = app;
    _this.name = database;
    _this.description = (_c = ((_a = (Array.isArray(app.settings.database) ? app.settings.database : [app.settings.database]).find(function (_ref) {
      var name = _ref.name;
      return name === database;
    })) !== null && _a !== void 0 ? _a : {
      name: database,
      description: (_b = app.settings.description) !== null && _b !== void 0 ? _b : "iVipBase database"
    }).description) !== null && _c !== void 0 ? _c : "iVipBase database";
    _this.debug = new ivipbase_core_1.DebugLogger(app.settings.logLevel, "[".concat(database, "]"));
    _this.subscriptions = new Subscriptions_1.Subscriptions(database, app);
    var dbInfo = (Array.isArray(_this.app.settings.database) ? _this.app.settings.database : [_this.app.settings.database]).find(function (d) {
      return d.name === _this.name;
    });
    var defaultRules = (_e = (_d = _this.app.settings) === null || _d === void 0 ? void 0 : _d.defaultRules) !== null && _e !== void 0 ? _e : {
      rules: {}
    };
    var mainRules = (_h = (_g = (_f = _this.app.settings) === null || _f === void 0 ? void 0 : _f.server) === null || _g === void 0 ? void 0 : _g.defineRules) !== null && _h !== void 0 ? _h : {
      rules: {}
    };
    var dbRules = (_j = dbInfo === null || dbInfo === void 0 ? void 0 : dbInfo.defineRules) !== null && _j !== void 0 ? _j : {
      rules: {}
    };
    _this._rules = new rules_1.PathBasedRules((_m = (_l = (_k = _this.app.settings) === null || _k === void 0 ? void 0 : _k.server) === null || _l === void 0 ? void 0 : _l.auth.defaultAccessRule) !== null && _m !== void 0 ? _m : "allow", {
      debug: _this.debug,
      db: _this,
      authEnabled: (_s = (_p = (_o = dbInfo === null || dbInfo === void 0 ? void 0 : dbInfo.authentication) === null || _o === void 0 ? void 0 : _o.enabled) !== null && _p !== void 0 ? _p : (_r = (_q = _this.app.settings) === null || _q === void 0 ? void 0 : _q.server) === null || _r === void 0 ? void 0 : _r.auth.enabled) !== null && _s !== void 0 ? _s : false,
      rules: (0, utils_1.joinObjects)({
        rules: {}
      }, defaultRules.rules, mainRules.rules, dbRules.rules)
    });
    _this.storage = app.isServer ? new StorageDBServer_1.StorageDBServer(_this) : new StorageDBClient_1.StorageDBClient(_this);
    app.storage.on("add", function (e) {
      //console.log(e);
      if (e.dbName !== database) {
        return;
      }
      _this.subscriptions.triggerAllEvents(e.path, null, e.value);
    });
    app.storage.on("change", function (e) {
      //console.log(e);
      if (e.dbName !== database) {
        return;
      }
      _this.subscriptions.triggerAllEvents(e.path, e.previous, e.value);
    });
    app.storage.on("remove", function (e) {
      if (e.dbName !== database) {
        return;
      }
      _this.subscriptions.triggerAllEvents(e.path, e.value, null);
    });
    app.storage.ready(function () {
      _this.emit("ready");
      _this.subscriptions.initialize();
    });
    return _this;
  }
  _inherits(DataBase, _ivipbase_core_1$Data);
  return _createClass(DataBase, [{
    key: "accessToken",
    get: function get() {
      var _a, _b;
      return (_b = (_a = this.app.auth.get(this.name)) === null || _a === void 0 ? void 0 : _a.currentUser) === null || _b === void 0 ? void 0 : _b.accessToken;
    }
  }, {
    key: "rules",
    get: function get() {
      return this._rules;
    }
  }, {
    key: "connect",
    value: function connect() {
      var retry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (this.storage instanceof StorageDBClient_1.StorageDBClient) {
        return this.storage.connect(retry);
      }
      throw new Error("Method not implemented");
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this.storage instanceof StorageDBClient_1.StorageDBClient) {
        return this.storage.disconnect();
      }
      throw new Error("Method not implemented");
    }
  }, {
    key: "getInfo",
    value: function () {
      var _getInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.storage.getInfo();
            case 2:
              return _context.abrupt("return", _context.sent);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getInfo() {
        return _getInfo.apply(this, arguments);
      }
      return getInfo;
    }()
  }, {
    key: "getPerformance",
    value: function () {
      var _getPerformance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var _yield$this$storage$g, data;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.storage.getInfo();
            case 2:
              _yield$this$storage$g = _context2.sent;
              data = _yield$this$storage$g.data;
              return _context2.abrupt("return", data !== null && data !== void 0 ? data : []);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getPerformance() {
        return _getPerformance.apply(this, arguments);
      }
      return getPerformance;
    }()
  }, {
    key: "applyRules",
    value: function applyRules(rules) {
      return this._rules.applyRules(rules);
    }
  }, {
    key: "setRule",
    value: function setRule(rulePaths, ruleTypes, callback) {
      return this._rules.add(rulePaths, ruleTypes, callback);
    }
  }]);
}(ivipbase_core_1.DataBase);
exports.DataBase = DataBase;
function getDatabase() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var app = args.find(function (a) {
      return a instanceof app_1.IvipBaseApp;
    }),
    dbName;
  var appNames = (0, app_1.getAppsName)();
  if (!app) {
    var name = appNames.find(function (n) {
      return args.includes(n);
    });
    app = name ? (0, app_1.getApp)(name) : (0, app_1.getFirstApp)();
  }
  var database = args.find(function (d) {
    return typeof d === "string" && appNames.includes(d) !== true;
  });
  if (typeof database !== "string") {
    database = app.settings.dbname;
  }
  dbName = (Array.isArray(database) ? database : [database])[0];
  if (app.databases.has(dbName)) {
    return app.databases.get(dbName);
  }
  var db = new DataBase(dbName, app, args.find(function (s) {
    return _typeof(s) === "object" && !(s instanceof app_1.IvipBaseApp);
  }));
  app.databases.set(dbName, db);
  return db;
}
exports.getDatabase = getDatabase;
function getDatabasesNames() {
  return Array.prototype.concat.apply([], (0, app_1.getAppsName)().map(function (name) {
    var names = (0, app_1.getApp)(name).settings.dbname;
    return Array.isArray(names) ? names : [names];
  })).filter(function (v, i, a) {
    return a.indexOf(v) === i;
  });
}
exports.getDatabasesNames = getDatabasesNames;
function hasDatabase(database) {
  return getDatabasesNames().includes(database);
}
exports.hasDatabase = hasDatabase;
var SchemaValidationError = /*#__PURE__*/function (_Error) {
  function SchemaValidationError(reason) {
    var _this2;
    _classCallCheck(this, SchemaValidationError);
    _this2 = _callSuper(this, SchemaValidationError, ["Schema validation failed: ".concat(reason)]);
    _this2.reason = reason;
    return _this2;
  }
  _inherits(SchemaValidationError, _Error);
  return _createClass(SchemaValidationError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.SchemaValidationError = SchemaValidationError;

},{"../app":1,"../utils":37,"./StorageDBClient":20,"./StorageDBServer":21,"./Subscriptions":22,"./services/rules":24,"ivipbase-core":152}],24:[function(require,module,exports){
"use strict";

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PathBasedRules = exports.AccessRuleValidationError = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var browser_1 = require("../../server/browser");
var sandbox_1 = require("./sandbox");
var utils_1 = require("../../utils");
var AccessRuleValidationError = /*#__PURE__*/function (_Error) {
  function AccessRuleValidationError(result) {
    var _this;
    _classCallCheck(this, AccessRuleValidationError);
    _this = _callSuper(this, AccessRuleValidationError, [result.message]);
    _this.result = result;
    return _this;
  }
  _inherits(AccessRuleValidationError, _Error);
  return _createClass(AccessRuleValidationError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.AccessRuleValidationError = AccessRuleValidationError;
var PathBasedRules = /*#__PURE__*/function (_ivipbase_core_1$Simp) {
  function PathBasedRules(defaultAccess, env) {
    var _this2;
    _classCallCheck(this, PathBasedRules);
    var _a;
    _this2 = _callSuper(this, PathBasedRules);
    _this2.env = env;
    _this2.codeRules = [];
    _this2.db = env.db;
    _this2.debug = env.debug;
    var defaultAccessRule = function (def) {
      switch (def) {
        case browser_1.AUTH_ACCESS_DEFAULT.ALLOW_AUTHENTICATED:
          {
            return "auth !== null";
          }
        case browser_1.AUTH_ACCESS_DEFAULT.ALLOW_ALL:
          {
            return true;
          }
        case browser_1.AUTH_ACCESS_DEFAULT.DENY_ALL:
          {
            return false;
          }
        default:
          {
            env.debug.error("Unknown defaultAccessRule \"".concat(def, "\""));
            return false;
          }
      }
    }(defaultAccess);
    var defaultRules = {
      rules: {
        ".read": defaultAccessRule,
        ".write": defaultAccessRule
      }
    };
    _this2.jsonRules = defaultRules;
    _this2.accessRules = defaultRules;
    _this2.applyRules((_a = env.rules) !== null && _a !== void 0 ? _a : defaultRules, true);
    _this2.authEnabled = env.authEnabled;
    return _this2;
  }
  _inherits(PathBasedRules, _ivipbase_core_1$Simp);
  return _createClass(PathBasedRules, [{
    key: "stop",
    value: function stop() {
      throw new Error("not started yet");
    }
  }, {
    key: "on",
    value: function on(event, callback) {
      return _get(_getPrototypeOf(PathBasedRules.prototype), "on", this).call(this, event, callback);
    }
  }, {
    key: "emit",
    value: function emit(event, data) {
      _get(_getPrototypeOf(PathBasedRules.prototype), "emit", this).call(this, event, data);
      return this;
    }
  }, {
    key: "applyRules",
    value: function applyRules(rules) {
      var _this3 = this;
      var isInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var accessRules = (0, utils_1.joinObjects)(this.jsonRules, rules);
      this.jsonRules = (0, utils_1.joinObjects)(this.jsonRules, rules);
      // Converta regras de string em funções que podem ser executadas
      var processRules = function processRules(path, parent, variables) {
        Object.keys(parent).forEach(function (key) {
          var rule = parent[key];
          if ([".read", ".write", ".validate"].includes(key) && typeof rule === "string") {
            var ruleCode = rule.includes("return ") ? rule : "return ".concat(rule);
            // Adicione `await`s às expressões de chamada `value` e `exists`
            ruleCode = ruleCode.replace(/(value|exists)\(/g, function (m, fn) {
              return "await ".concat(fn, "(");
            });
            // Converter para função
            // rule = eval(
            //     `(async (env) => {` +
            //     `  const { now, path, ${variables.join(', ')}, operation, data, auth, value, exists } = env;` +
            //     `  ${ruleCode};` +
            //     `})`);
            // rule.getText = () => {
            //     return ruleCode;
            // };
            ruleCode = "(async () => {\n".concat(ruleCode, "\n})();");
            return parent[key] = ruleCode;
          } else if (key === ".schema") {
            // Adicionar esquema
            return _this3.env.db.schema.set(path, rule)["catch"](function (err) {
              _this3.env.debug.error("Error parsing ".concat(path, "/.schema: ").concat(err.message));
            });
          } else if (key.startsWith("$")) {
            variables.push(key);
          }
          if (_typeof(rule) === "object") {
            processRules("".concat(path, "/").concat(key), rule, variables.slice());
          }
        });
      };
      processRules("", accessRules.rules, []);
      this.accessRules = accessRules;
      if (!isInitial) {
        this.emit("changed", this.jsonRules);
      }
    }
  }, {
    key: "isOperationAllowed",
    value: function () {
      var _isOperationAllowed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(user, path, operation, data) {
        var _this4 = this;
        var typeOperation, isPreFlight, allow, getFullPath, env, pathInfo, pathKeys, rule, rulePathKeys, currentPath, isAllowed, _loop, _ret, startRule, getNestedRules, checkRules, _iterator, _step, _loop2, _ret2;
        return _regeneratorRuntime().wrap(function _callee6$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              // Process rules, find out if signed in user is allowed to read/write
              // Defaults to false unless a rule is found that tells us otherwise
              typeOperation = "";
              if (["get", "exists", "query", "reflect", "export", "transact"].includes(operation)) {
                typeOperation += "r";
              }
              if (["update", "set", "delete", "import", "transact"].includes(operation)) {
                typeOperation += "w";
              }
              isPreFlight = typeof data === "undefined";
              allow = {
                allow: true
              };
              if (this.authEnabled) {
                _context8.next = 9;
                break;
              }
              return _context8.abrupt("return", allow);
            case 9:
              if (!((user === null || user === void 0 ? void 0 : user.uid) === "admin" || (user === null || user === void 0 ? void 0 : user.permission_level) >= 2)) {
                _context8.next = 13;
                break;
              }
              return _context8.abrupt("return", allow);
            case 13:
              if (!(path.startsWith("__") && !((user === null || user === void 0 ? void 0 : user.permission_level) >= 1 && typeOperation === "r"))) {
                _context8.next = 15;
                break;
              }
              return _context8.abrupt("return", {
                allow: false,
                code: "private",
                message: "Access to private resource \"".concat(path, "\" not allowed")
              });
            case 15:
              getFullPath = function getFullPath(path, relativePath) {
                if (relativePath.startsWith("/")) {
                  // Absolute path
                  return relativePath;
                } else if (!relativePath.startsWith(".")) {
                  throw new Error("Path must be either absolute (/) or relative (./ or ../)");
                }
                var targetPathInfo = ivipbase_core_1.PathInfo.get(path);
                var trailKeys = ivipbase_core_1.PathInfo.getPathKeys(relativePath);
                trailKeys.forEach(function (key) {
                  if (key === ".") {
                    /* no op */
                  } else if (key === "..") {
                    targetPathInfo = targetPathInfo.parent;
                  } else {
                    targetPathInfo = targetPathInfo.child(key);
                  }
                });
                return targetPathInfo.path;
              };
              env = {
                now: Date.now(),
                auth: user || null,
                operation: operation,
                vars: {},
                context: _typeof(data === null || data === void 0 ? void 0 : data.context) === "object" && data.context !== null ? Object.assign({}, data.context) : {}
              };
              pathInfo = ivipbase_core_1.PathInfo.get(path);
              pathKeys = pathInfo.keys.slice();
              rule = this.accessRules.rules;
              rulePathKeys = [];
              currentPath = "";
              isAllowed = false;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
                var checkRules, applyRule, rulePath, _i, _checkRules, _rule, ruleEnv, result, nextKey, wildcardKey;
                return _regeneratorRuntime().wrap(function _loop$(_context7) {
                  while (1) switch (_context7.prev = _context7.next) {
                    case 0:
                      // Check read/write access or validate operation
                      checkRules = [];
                      applyRule = function applyRule(rule) {
                        if (rule && !checkRules.includes(rule)) {
                          checkRules.push(rule);
                        }
                      };
                      if (["get", "exists", "query", "reflect", "export", "transact"].includes(operation)) {
                        // Operations that require 'read' access
                        applyRule(rule[".read"]);
                      }
                      if (".write" in rule && ["update", "set", "delete", "import", "transact"].includes(operation)) {
                        // Operations that require 'write' access
                        applyRule(rule[".write"]);
                      }
                      if (".".concat(operation) in rule && !isPreFlight) {
                        // If there is a dedicated rule (eg ".update" or ".reflect") for this operation, use it.
                        applyRule(rule[".".concat(operation)]);
                      }
                      rulePath = ivipbase_core_1.PathInfo.get(rulePathKeys).path;
                      _i = 0, _checkRules = checkRules;
                    case 7:
                      if (!(_i < _checkRules.length)) {
                        _context7.next = 38;
                        break;
                      }
                      _rule = _checkRules[_i];
                      if (!(typeof _rule === "boolean")) {
                        _context7.next = 13;
                        break;
                      }
                      if (_rule) {
                        _context7.next = 12;
                        break;
                      }
                      return _context7.abrupt("return", {
                        v: {
                          allow: false,
                          code: "rule",
                          message: "".concat(operation, " operation denied to path \"").concat(path, "\" by set rule"),
                          rule: _rule,
                          rulePath: rulePath
                        }
                      });
                    case 12:
                      isAllowed = true; // return allow;
                    case 13:
                      if (!(typeof _rule === "string" || typeof _rule === "function")) {
                        _context7.next = 35;
                        break;
                      }
                      _context7.prev = 14;
                      // Execute rule function
                      ruleEnv = Object.assign(Object.assign({}, env), {
                        exists: function () {
                          var _exists2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(target) {
                            return _regeneratorRuntime().wrap(function _callee4$(_context5) {
                              while (1) switch (_context5.prev = _context5.next) {
                                case 0:
                                  return _context5.abrupt("return", _this4.db.ref(getFullPath(currentPath, target)).exists());
                                case 1:
                                case "end":
                                  return _context5.stop();
                              }
                            }, _callee4);
                          }));
                          function exists(_x8) {
                            return _exists2.apply(this, arguments);
                          }
                          return exists;
                        }(),
                        value: function () {
                          var _value2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(target, include) {
                            var snap;
                            return _regeneratorRuntime().wrap(function _callee5$(_context6) {
                              while (1) switch (_context6.prev = _context6.next) {
                                case 0:
                                  _context6.next = 2;
                                  return _this4.db.ref(getFullPath(currentPath, target)).get({
                                    include: include
                                  });
                                case 2:
                                  snap = _context6.sent;
                                  return _context6.abrupt("return", snap.val());
                                case 4:
                                case "end":
                                  return _context6.stop();
                              }
                            }, _callee5);
                          }));
                          function value(_x9, _x10) {
                            return _value2.apply(this, arguments);
                          }
                          return value;
                        }()
                      });
                      if (!(typeof _rule === "function")) {
                        _context7.next = 22;
                        break;
                      }
                      _context7.next = 19;
                      return _rule(ruleEnv);
                    case 19:
                      _context7.t0 = _context7.sent;
                      _context7.next = 25;
                      break;
                    case 22:
                      _context7.next = 24;
                      return (0, sandbox_1.executeSandboxed)(_rule, ruleEnv);
                    case 24:
                      _context7.t0 = _context7.sent;
                    case 25:
                      result = _context7.t0;
                      if (!["cascade", "deny", "allow", true, false].includes(result)) {
                        _this4.debug.warn("rule for path ".concat(rulePath, " possibly returns an unintentional value (").concat(JSON.stringify(result), ") which results in outcome \"").concat(result ? "allow" : "deny", "\""));
                      }
                      isAllowed = result === "allow" || result === true;
                      if (!(!isAllowed && result !== "cascade")) {
                        _context7.next = 30;
                        break;
                      }
                      return _context7.abrupt("return", {
                        v: {
                          allow: false,
                          code: "rule",
                          message: "".concat(operation, " operation denied to path \"").concat(path, "\" by set rule"),
                          rule: _rule,
                          rulePath: rulePath
                        }
                      });
                    case 30:
                      _context7.next = 35;
                      break;
                    case 32:
                      _context7.prev = 32;
                      _context7.t1 = _context7["catch"](14);
                      return _context7.abrupt("return", {
                        v: {
                          allow: false,
                          code: "exception",
                          message: "".concat(operation, " operation denied to path \"").concat(path, "\" by set rule"),
                          rule: _rule,
                          rulePath: rulePath,
                          details: _context7.t1
                        }
                      });
                    case 35:
                      _i++;
                      _context7.next = 7;
                      break;
                    case 38:
                      if (!isAllowed) {
                        _context7.next = 40;
                        break;
                      }
                      return _context7.abrupt("return", 0);
                    case 40:
                      if (!(pathKeys.length === 0)) {
                        _context7.next = 42;
                        break;
                      }
                      return _context7.abrupt("return", 0);
                    case 42:
                      nextKey = pathKeys.shift();
                      currentPath = ivipbase_core_1.PathInfo.get(currentPath).childPath(nextKey);
                      // if nextKey is '*' or '$something', rule[nextKey] will be undefined (or match a variable) so there is no
                      // need to change things here for usage of wildcard paths in subscriptions
                      if (typeof rule[nextKey] === "undefined") {
                        // Check if current rule has a wildcard child
                        wildcardKey = Object.keys(rule).find(function (key) {
                          return key === "*" || key[0] === "$";
                        });
                        if (wildcardKey) {
                          env[wildcardKey] = nextKey;
                          env.vars[wildcardKey] = nextKey;
                        }
                        nextKey = wildcardKey;
                      }
                      nextKey && rulePathKeys.push(nextKey);
                      rule = rule[nextKey];
                    case 47:
                    case "end":
                      return _context7.stop();
                  }
                }, _loop, null, [[14, 32]]);
              });
            case 24:
              if (!rule) {
                _context8.next = 33;
                break;
              }
              return _context8.delegateYield(_loop(), "t0", 26);
            case 26:
              _ret = _context8.t0;
              if (!(_ret === 0)) {
                _context8.next = 29;
                break;
              }
              return _context8.abrupt("break", 33);
            case 29:
              if (!_ret) {
                _context8.next = 31;
                break;
              }
              return _context8.abrupt("return", _ret.v);
            case 31:
              _context8.next = 24;
              break;
            case 33:
              if (!(isAllowed && ["set", "update"].includes(operation) && !isPreFlight)) {
                _context8.next = 58;
                break;
              }
              // validate rules start at current path being written to
              startRule = pathInfo.keys.reduce(function (rule, key) {
                if (_typeof(rule) !== "object" || rule === null) {
                  return null;
                }
                if (key in rule) {
                  return rule[key];
                }
                if ("*" in rule) {
                  return rule["*"];
                }
                var variableKey = Object.keys(rule).find(function (key) {
                  return typeof key === "string" && key.startsWith("$");
                });
                if (variableKey) {
                  return rule[variableKey];
                }
                return null;
              }, this.accessRules.rules);
              getNestedRules = function getNestedRules(target, rule) {
                if (!rule) {
                  return [];
                }
                var nested = Object.keys(rule).reduce(function (arr, key) {
                  if (key === ".validate" && ["string", "function"].includes(_typeof(rule[key]))) {
                    arr.push({
                      target: target,
                      validate: rule[key]
                    });
                  }
                  if (!key.startsWith(".")) {
                    var _nested = getNestedRules([].concat(_toConsumableArray(target), [key]), rule[key]);
                    arr.push.apply(arr, _toConsumableArray(_nested));
                  }
                  return arr;
                }, []);
                return nested;
              }; // Check all that apply for sent data (update requires a different strategy)
              checkRules = getNestedRules([], startRule);
              _iterator = _createForOfIteratorHelper(checkRules);
              _context8.prev = 38;
              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
                var check, targetData, validateData, validatePath, validateEnv, result;
                return _regeneratorRuntime().wrap(function _loop2$(_context4) {
                  while (1) switch (_context4.prev = _context4.next) {
                    case 0:
                      check = _step.value;
                      // Keep going as long as rules validate
                      targetData = check.target.reduce(function (data, key) {
                        if (data !== null && _typeof(data) === "object" && key in data) {
                          return data[key];
                        }
                        return null;
                      }, data.value);
                      if (!(typeof targetData === "undefined" && operation === "update" && check.target.length >= 1 && check.target[0] in data)) {
                        _context4.next = 4;
                        break;
                      }
                      return _context4.abrupt("return", 0);
                    case 4:
                      validateData = typeof targetData === "undefined" ? null : targetData;
                      if (!(validateData === null)) {
                        _context4.next = 7;
                        break;
                      }
                      return _context4.abrupt("return", 0);
                    case 7:
                      validatePath = ivipbase_core_1.PathInfo.get(path).child(check.target).path;
                      validateEnv = Object.assign(Object.assign({}, env), {
                        operation: operation === "update" ? check.target.length === 0 ? "update" : "set" : operation,
                        data: validateData,
                        exists: function () {
                          var _exists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(target) {
                            return _regeneratorRuntime().wrap(function _callee$(_context) {
                              while (1) switch (_context.prev = _context.next) {
                                case 0:
                                  return _context.abrupt("return", _this4.db.ref(getFullPath(validatePath, target)).exists());
                                case 1:
                                case "end":
                                  return _context.stop();
                              }
                            }, _callee);
                          }));
                          function exists(_x5) {
                            return _exists.apply(this, arguments);
                          }
                          return exists;
                        }(),
                        value: function () {
                          var _value = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(target, include) {
                            var snap;
                            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                              while (1) switch (_context2.prev = _context2.next) {
                                case 0:
                                  _context2.next = 2;
                                  return _this4.db.ref(getFullPath(validatePath, target)).get({
                                    include: include
                                  });
                                case 2:
                                  snap = _context2.sent;
                                  return _context2.abrupt("return", snap.val());
                                case 4:
                                case "end":
                                  return _context2.stop();
                              }
                            }, _callee2);
                          }));
                          function value(_x6, _x7) {
                            return _value.apply(this, arguments);
                          }
                          return value;
                        }()
                      });
                      _context4.prev = 9;
                      _context4.next = 12;
                      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                        var result;
                        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                          while (1) switch (_context3.prev = _context3.next) {
                            case 0:
                              if (!(typeof check.validate === "function")) {
                                _context3.next = 6;
                                break;
                              }
                              _context3.next = 3;
                              return check.validate(validateEnv);
                            case 3:
                              result = _context3.sent;
                              _context3.next = 13;
                              break;
                            case 6:
                              if (!(typeof check.validate === "string")) {
                                _context3.next = 12;
                                break;
                              }
                              _context3.next = 9;
                              return (0, sandbox_1.executeSandboxed)(check.validate, validateEnv);
                            case 9:
                              result = _context3.sent;
                              _context3.next = 13;
                              break;
                            case 12:
                              if (typeof check.validate === "boolean") {
                                result = check.validate ? "allow" : "deny";
                              }
                            case 13:
                              if (result === "cascade") {
                                _this4.debug.warn("Rule at path ".concat(validatePath, " returned \"cascade\", but ").concat(validateEnv.operation, " rules always cascade"));
                              } else if (!["cascade", "deny", "allow", true, false].includes(result !== null && result !== void 0 ? result : "")) {
                                _this4.debug.warn("".concat(validateEnv.operation, " rule for path ").concat(validatePath, " possibly returned an unintentional value (").concat(JSON.stringify(result), ") which results in outcome \"").concat(result ? "allow" : "deny", "\""));
                              }
                              if (!["cascade", "deny", "allow"].includes(result)) {
                                _context3.next = 16;
                                break;
                              }
                              return _context3.abrupt("return", result);
                            case 16:
                              return _context3.abrupt("return", result ? "allow" : "deny");
                            case 17:
                            case "end":
                              return _context3.stop();
                          }
                        }, _callee3);
                      }))();
                    case 12:
                      result = _context4.sent;
                      if (!(result === "deny")) {
                        _context4.next = 15;
                        break;
                      }
                      return _context4.abrupt("return", {
                        v: {
                          allow: false,
                          code: "rule",
                          message: "".concat(operation, " operation denied to path \"").concat(path, "\" by set rule"),
                          rule: check.validate,
                          rulePath: validatePath
                        }
                      });
                    case 15:
                      _context4.next = 20;
                      break;
                    case 17:
                      _context4.prev = 17;
                      _context4.t0 = _context4["catch"](9);
                      return _context4.abrupt("return", {
                        v: {
                          allow: false,
                          code: "exception",
                          message: "".concat(operation, " operation denied to path \"").concat(path, "\" by set rule"),
                          rule: check.validate,
                          rulePath: validatePath,
                          details: _context4.t0
                        }
                      });
                    case 20:
                    case "end":
                      return _context4.stop();
                  }
                }, _loop2, null, [[9, 17]]);
              });
              _iterator.s();
            case 41:
              if ((_step = _iterator.n()).done) {
                _context8.next = 50;
                break;
              }
              return _context8.delegateYield(_loop2(), "t1", 43);
            case 43:
              _ret2 = _context8.t1;
              if (!(_ret2 === 0)) {
                _context8.next = 46;
                break;
              }
              return _context8.abrupt("continue", 48);
            case 46:
              if (!_ret2) {
                _context8.next = 48;
                break;
              }
              return _context8.abrupt("return", _ret2.v);
            case 48:
              _context8.next = 41;
              break;
            case 50:
              _context8.next = 55;
              break;
            case 52:
              _context8.prev = 52;
              _context8.t2 = _context8["catch"](38);
              _iterator.e(_context8.t2);
            case 55:
              _context8.prev = 55;
              _iterator.f();
              return _context8.finish(55);
            case 58:
              return _context8.abrupt("return", isAllowed ? allow : {
                allow: false,
                code: "no_rule",
                message: "No rules set for requested path \"".concat(path, "\", defaulting to false")
              });
            case 59:
            case "end":
              return _context8.stop();
          }
        }, _callee6, this, [[38, 52, 55, 58]]);
      }));
      function isOperationAllowed(_x, _x2, _x3, _x4) {
        return _isOperationAllowed.apply(this, arguments);
      }
      return isOperationAllowed;
    }()
  }, {
    key: "add",
    value: function add(rulePaths, ruleTypes, callback) {
      var paths = Array.isArray(rulePaths) ? rulePaths : [rulePaths];
      var types = Array.isArray(ruleTypes) ? ruleTypes : [ruleTypes];
      var _iterator2 = _createForOfIteratorHelper(paths),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var path = _step2.value;
          var keys = ivipbase_core_1.PathInfo.getPathKeys(path);
          var target = this.accessRules.rules;
          var _iterator3 = _createForOfIteratorHelper(keys),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var key = _step3.value;
              if (!(key in target)) {
                target[key] = {};
              }
              target = target[key];
              if (_typeof(target) !== "object" || target === null) {
                throw new Error("Cannot add rule because value of key \"".concat(key, "\" is not an object"));
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          var _iterator4 = _createForOfIteratorHelper(types),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var type = _step4.value;
              target[".".concat(type)] = callback;
              this.codeRules.push({
                path: path,
                type: type,
                callback: callback
              });
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }]);
}(ivipbase_core_1.SimpleEventEmitter);
exports.PathBasedRules = PathBasedRules;

},{"../../server/browser":30,"../../utils":37,"./sandbox":25,"ivipbase-core":152}],25:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isCodeSafe = exports.executeSandboxed = void 0;
function executeSandboxed(_x, _x2) {
  return _executeSandboxed.apply(this, arguments);
}
function _executeSandboxed() {
  _executeSandboxed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(code, env) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          return _context.abrupt("return", null);
        case 1:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _executeSandboxed.apply(this, arguments);
}
exports.executeSandboxed = executeSandboxed;
function isCodeSafe(code) {
  return /eval|prototype|require|import/.test(code); // Não permitir acesso ao protótipo, exigir ou importar instruções
}
exports.isCodeSafe = isCodeSafe;

},{}],26:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IPCPeer = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var ipc_1 = require("../ipc");
/**
 * Browser tabs IPC. Database changes and events will be synchronized automatically.
 * Locking of resources will be done by the election of a single locking master:
 * the one with the lowest id.
 */
var IPCPeer = /*#__PURE__*/function (_ipc_1$IvipBaseIPCPee) {
  function IPCPeer(name) {
    var _this;
    _classCallCheck(this, IPCPeer);
    _this = _callSuper(this, IPCPeer, ["browser", name]);
    _this.name = name;
    _this.masterPeerId = _this.id; // We don't know who the master is yet...
    _this.ipcType = "browser.bcc";
    // Setup process exit handler
    // Monitor onbeforeunload event to say goodbye when the window is closed
    addEventListener("beforeunload", function () {
      _this.exit();
    });
    // Create BroadcastChannel to allow multi-tab communication
    // This allows other tabs to make changes to the database, notifying us of those changes.
    if (typeof BroadcastChannel !== "undefined") {
      _this.channel = new BroadcastChannel("ivipbase:".concat(name));
    } else if (typeof localStorage !== "undefined") {
      // Use localStorage as polyfill for Safari & iOS WebKit
      var listeners = []; // first callback reserved for onmessage handler
      var notImplemented = function notImplemented() {
        throw new Error("Not implemented");
      };
      _this.channel = {
        name: "ivipbase:".concat(name),
        postMessage: function postMessage(message) {
          var messageId = ivipbase_core_1.ID.generate(),
            key = "ivipbase:".concat(name, ":").concat(_this.id, ":").concat(messageId),
            payload = JSON.stringify(ivipbase_core_1.Transport.serialize(message));
          // Store message, triggers 'storage' event in other tabs
          localStorage.setItem(key, payload);
          // Remove after 10ms
          setTimeout(function () {
            return localStorage.removeItem(key);
          }, 10);
        },
        set onmessage(handler) {
          listeners[0] = handler;
        },
        set onmessageerror(handler) {
          notImplemented();
        },
        close: function close() {
          notImplemented();
        },
        addEventListener: function addEventListener(event, callback) {
          if (event !== "message") {
            notImplemented();
          }
          listeners.push(callback);
        },
        removeEventListener: function removeEventListener(event, callback) {
          var i = listeners.indexOf(callback);
          i >= 1 && listeners.splice(i, 1);
        },
        dispatchEvent: function dispatchEvent(event) {
          listeners.forEach(function (callback) {
            try {
              callback && callback(event);
            } catch (err) {
              console.error(err);
            }
          });
          return true;
        }
      };
      // Listen for storage events to intercept possible messages
      addEventListener("storage", function (event) {
        var _a;
        if (!event || !event.key) {
          return;
        }
        var _event$key$split = event.key.split(":"),
          _event$key$split2 = _slicedToArray(_event$key$split, 4),
          ivipbase = _event$key$split2[0],
          name = _event$key$split2[1],
          peerId = _event$key$split2[2],
          messageId = _event$key$split2[3];
        if (ivipbase !== "ivipbase" || name !== _this.name || peerId === _this.id || event.newValue === null) {
          return;
        }
        var message = ivipbase_core_1.Transport.deserialize(JSON.parse(event.newValue));
        (_a = _this.channel) === null || _a === void 0 ? void 0 : _a.dispatchEvent({
          data: message
        });
      });
    } else {
      // No localStorage either, this is probably an old browser running in a webworker
      _this.debug.warn("[BroadcastChannel] not supported");
      _this.sendMessage = function () {
        /* No OP */
      };
      return _possibleConstructorReturn(_this);
    }
    // Monitor incoming messages
    _this.channel.addEventListener("message", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(event) {
        var message, allPeerIds;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              message = event.data;
              if (!(message.to && message.to !== _this.id)) {
                _context.next = 3;
                break;
              }
              return _context.abrupt("return");
            case 3:
              _this.debug.verbose("[BroadcastChannel] received: ", message);
              if (message.type === "hello" && message.from < _this.masterPeerId) {
                // This peer was created before other peer we thought was the master
                _this.masterPeerId = message.from;
                _this.debug.log("[BroadcastChannel] Tab ".concat(_this.masterPeerId, " is the master."));
              } else if (message.type === "bye" && message.from === _this.masterPeerId) {
                // The master tab is leaving
                _this.debug.log("[BroadcastChannel] Master tab ".concat(_this.masterPeerId, " is leaving"));
                // Elect new master
                allPeerIds = _this.peers.map(function (peer) {
                  return peer.id;
                }).concat(_this.id).filter(function (id) {
                  return id !== _this.masterPeerId;
                }); // All peers, including us, excluding the leaving master peer
                _this.masterPeerId = allPeerIds.sort()[0];
              }
              return _context.abrupt("return", _this.handleMessage(message));
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    // // Schedule periodic "pulse" to let others know we're still around
    // setInterval(() => {
    //     sendMessage(<IPulseMessage>{ from: tabId, type: 'pulse' });
    // }, 30000);
    _this.emit("connect", _this);
    return _this;
  }
  _inherits(IPCPeer, _ipc_1$IvipBaseIPCPee);
  return _createClass(IPCPeer, [{
    key: "sendMessage",
    value: function sendMessage(message) {
      var _a;
      this.debug.verbose("[BroadcastChannel] sending: ", message);
      (_a = this.channel) === null || _a === void 0 ? void 0 : _a.postMessage(message);
    }
  }]);
}(ipc_1.IvipBaseIPCPeer);
exports.IPCPeer = IPCPeer;

},{"../ipc":29,"ivipbase-core":152}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getIPCPeer = exports.IPCPeer = void 0;
var IPCPeer_1 = require("./IPCPeer");
Object.defineProperty(exports, "IPCPeer", {
  enumerable: true,
  get: function get() {
    return IPCPeer_1.IPCPeer;
  }
});
var internal_1 = require("./internal");
function getIPCPeer() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : internal_1.DEFAULT_ENTRY_NAME;
  if (internal_1._ipcs.has(name)) {
    return internal_1._ipcs.get(name);
  }
  var ipc = new IPCPeer_1.IPCPeer(name);
  internal_1._ipcs.set(name, ipc);
  return ipc;
}
exports.getIPCPeer = getIPCPeer;

},{"./IPCPeer":26,"./internal":28}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._ipcs = exports.DEFAULT_ENTRY_NAME = void 0;
var internal_1 = require("../app/internal");
Object.defineProperty(exports, "DEFAULT_ENTRY_NAME", {
  enumerable: true,
  get: function get() {
    return internal_1.DEFAULT_ENTRY_NAME;
  }
});
/**
 * @internal
 */
exports._ipcs = new Map();

},{"../app/internal":2}],29:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IvipBaseIPCPeer = exports.AIvipBaseIPCPeerExitingError = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var masterPeerId = "[master]";
var AIvipBaseIPCPeerExitingError = /*#__PURE__*/function (_Error) {
  function AIvipBaseIPCPeerExitingError(message) {
    _classCallCheck(this, AIvipBaseIPCPeerExitingError);
    return _callSuper(this, AIvipBaseIPCPeerExitingError, ["Exiting: ".concat(message)]);
  }
  _inherits(AIvipBaseIPCPeerExitingError, _Error);
  return _createClass(AIvipBaseIPCPeerExitingError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.AIvipBaseIPCPeerExitingError = AIvipBaseIPCPeerExitingError;
var IvipBaseIPCPeer = /*#__PURE__*/function (_ivipbase_core_1$Simp) {
  function IvipBaseIPCPeer(id, name) {
    var _this;
    _classCallCheck(this, IvipBaseIPCPeer);
    _this = _callSuper(this, IvipBaseIPCPeer);
    _this.id = id;
    _this.name = name;
    _this.masterPeerId = masterPeerId;
    _this.ipcType = "ipc";
    _this.peers = [];
    _this._exiting = false;
    _this._requests = new Map();
    _this.debug = new ivipbase_core_1.DebugLogger("verbose", "[".concat(name, "]"));
    var helloMsg = {
      type: "hello",
      from: _this.id,
      data: undefined
    };
    _this.sendMessage(helloMsg);
    return _this;
  }
  _inherits(IvipBaseIPCPeer, _ivipbase_core_1$Simp);
  return _createClass(IvipBaseIPCPeer, [{
    key: "isMaster",
    get: function get() {
      return this.masterPeerId === this.id;
    }
  }, {
    key: "on",
    value: function on(event, callback) {
      return _get(_getPrototypeOf(IvipBaseIPCPeer.prototype), "on", this).call(this, event, callback);
    }
  }, {
    key: "emit",
    value: function emit(event, data) {
      _get(_getPrototypeOf(IvipBaseIPCPeer.prototype), "emit", this).call(this, event, data);
      return this;
    }
    /**
     * Requests the peer to shut down. Resolves once its locks are cleared and 'exit' event has been emitted.
     * Has to be overridden by the IPC implementation to perform custom shutdown tasks
     * @param code optional exit code (eg one provided by SIGINT event)
     */
  }, {
    key: "exit",
    value: (function () {
      var _exit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var code,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              code = _args.length > 0 && _args[0] !== undefined ? _args[0] : 0;
              if (!this._exiting) {
                _context.next = 3;
                break;
              }
              return _context.abrupt("return", this.once("exit"));
            case 3:
              this._exiting = true;
              this.debug.warn("Received ".concat(this.isMaster ? "master" : "worker " + this.id, " process exit request"));
              // Send "bye"
              this.sayGoodbye(this.id);
              this.debug.warn("".concat(this.isMaster ? "Master" : "Worker " + this.id, " will now exit"));
              this.emitOnce("exit", code);
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function exit() {
        return _exit.apply(this, arguments);
      }
      return exit;
    }())
  }, {
    key: "sayGoodbye",
    value: function sayGoodbye(forPeerId) {
      // Send "bye" message on their behalf
      var bye = {
        type: "bye",
        from: forPeerId,
        data: undefined
      };
      this.sendMessage(bye);
    }
  }, {
    key: "addPeer",
    value: function addPeer(id) {
      var sendReply = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (this._exiting) {
        return;
      }
      var peer = this.peers.find(function (w) {
        return w.id === id;
      });
      if (!peer) {
        this.peers.push({
          id: id,
          lastSeen: Date.now()
        });
      }
      if (sendReply) {
        // Send hello back to sender
        var helloMessage = {
          type: "hello",
          from: this.id,
          to: id,
          data: undefined
        };
        this.sendMessage(helloMessage);
      }
    }
  }, {
    key: "removePeer",
    value: function removePeer(id) {
      var ignoreUnknown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (this._exiting) {
        return;
      }
      var peer = this.peers.find(function (peer) {
        return peer.id === id;
      });
      if (!peer) {
        if (!ignoreUnknown) {
          throw new Error("We are supposed to know this peer!");
        }
        return;
      }
      this.peers.splice(this.peers.indexOf(peer), 1);
    }
  }, {
    key: "handleMessage",
    value: function () {
      var _handleMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(message) {
        var result, request;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(message.from === this.id)) {
                _context2.next = 2;
                break;
              }
              return _context2.abrupt("return");
            case 2:
              _context2.t0 = message.type;
              _context2.next = _context2.t0 === "hello" ? 5 : _context2.t0 === "bye" ? 6 : _context2.t0 === "triggerEvents" ? 7 : _context2.t0 === "notification" ? 8 : _context2.t0 === "request" ? 9 : _context2.t0 === "result" ? 10 : 15;
              break;
            case 5:
              return _context2.abrupt("return", this.addPeer(message.from, message.to !== this.id));
            case 6:
              return _context2.abrupt("return", this.removePeer(message.from, true));
            case 7:
              return _context2.abrupt("return", this.emit("triggerEvents", message.data));
            case 8:
              return _context2.abrupt("return", this.emit("notification", message.data));
            case 9:
              return _context2.abrupt("return", this.emit("request", message));
            case 10:
              // Result of custom request received - raise event
              result = message;
              request = this._requests.get(result.id);
              if (!(_typeof(request) !== "object")) {
                _context2.next = 14;
                break;
              }
              throw new Error("Result of unknown request received");
            case 14:
              if (result.ok) {
                request.resolve(result.data);
              } else {
                request.reject(new Error(result.reason));
              }
            case 15:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function handleMessage(_x) {
        return _handleMessage.apply(this, arguments);
      }
      return handleMessage;
    }()
  }, {
    key: "request",
    value: function () {
      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(req) {
        var _this2 = this;
        var resolve, reject, timer, promise;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              // Send request, return result promise
              promise = new Promise(function (rs, rj) {
                resolve = function resolve(result) {
                  if (_this2._requests.has(req.id) !== true) {
                    return;
                  }
                  clearTimeout(timer);
                  _this2._requests["delete"](req.id);
                  rs(result);
                };
                reject = function reject(err) {
                  if (_this2._requests.has(req.id) !== true) {
                    return;
                  }
                  clearTimeout(timer);
                  _this2._requests["delete"](req.id);
                  rj(err);
                };
              });
              this._requests.set(req.id, {
                resolve: resolve,
                reject: reject,
                request: req
              });
              timer = setTimeout(function () {
                reject(new Error("Request timed out"));
              }, 1000 * 60 * 1);
              this.sendMessage(req);
              return _context3.abrupt("return", promise);
            case 5:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function request(_x2) {
        return _request.apply(this, arguments);
      }
      return request;
    }()
  }, {
    key: "sendRequest",
    value: function () {
      var _sendRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {
        var _this3 = this;
        var req;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              req = {
                type: "request",
                from: this.id,
                to: this.masterPeerId,
                id: ivipbase_core_1.ID.generate(),
                data: request
              };
              _context4.next = 3;
              return this.request(req)["catch"](function (err) {
                _this3.debug.error(err);
                throw err;
              });
            case 3:
              return _context4.abrupt("return", _context4.sent);
            case 4:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function sendRequest(_x3) {
        return _sendRequest.apply(this, arguments);
      }
      return sendRequest;
    }()
  }, {
    key: "replyRequest",
    value: function replyRequest(requestMessage, result) {
      var reply = {
        type: "result",
        id: requestMessage.id,
        ok: true,
        from: this.id,
        to: requestMessage.from,
        data: result
      };
      this.sendMessage(reply);
    }
  }, {
    key: "sendNotification",
    value: function sendNotification(notification) {
      var msg = {
        type: "notification",
        from: this.id,
        data: notification
      };
      this.sendMessage(msg);
    }
  }, {
    key: "sendTriggerEvents",
    value: function sendTriggerEvents(dbname, path, oldValue, newValue) {
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
        suppress_events: false,
        context: undefined
      };
      this.sendMessage({
        type: "triggerEvents",
        from: this.id,
        data: {
          dbName: dbname,
          path: path,
          oldValue: oldValue,
          newValue: newValue,
          options: options
        },
        dbname: dbname
      });
    }
  }]);
}(ivipbase_core_1.SimpleEventEmitter);
exports.IvipBaseIPCPeer = IvipBaseIPCPeer;

},{"ivipbase-core":152}],30:[function(require,module,exports){
"use strict";

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LocalServer = exports.AbstractLocalServer = exports.isPossiblyServer = exports.ServerSettings = exports.ServerAuthenticationSettings = exports.DataBaseServerTransactionSettings = exports.AUTH_ACCESS_DEFAULT = exports.ExternalServerError = exports.ServerNotReadyError = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var database_1 = require("../database");
var utils_1 = require("../utils");
var storage_1 = require("../storage");
var ServerNotReadyError = /*#__PURE__*/function (_Error) {
  function ServerNotReadyError() {
    _classCallCheck(this, ServerNotReadyError);
    return _callSuper(this, ServerNotReadyError, ["O servidor ainda não está pronto"]);
  }
  _inherits(ServerNotReadyError, _Error);
  return _createClass(ServerNotReadyError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.ServerNotReadyError = ServerNotReadyError;
var ExternalServerError = /*#__PURE__*/function (_Error2) {
  function ExternalServerError() {
    _classCallCheck(this, ExternalServerError);
    return _callSuper(this, ExternalServerError, ["Este método não está disponível com um servidor externo"]);
  }
  _inherits(ExternalServerError, _Error2);
  return _createClass(ExternalServerError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.ExternalServerError = ExternalServerError;
exports.AUTH_ACCESS_DEFAULT = {
  DENY_ALL: "deny",
  ALLOW_ALL: "allow",
  ALLOW_AUTHENTICATED: "auth"
};
var DataBaseServerTransactionSettings = /*#__PURE__*/_createClass(function DataBaseServerTransactionSettings(settings) {
  _classCallCheck(this, DataBaseServerTransactionSettings);
  /**
   * Se deve ativar o log de transações
   */
  this.log = false;
  /**
   * Idade máxima em dias para manter as transações no arquivo de log
   */
  this.maxAge = 30;
  /**
   * Se as operações de gravação do banco de dados não devem esperar até que a transação seja registrada
   */
  this.noWait = false;
  if (_typeof(settings) !== "object") {
    return;
  }
  if (typeof settings.log === "boolean") {
    this.log = settings.log;
  }
  if (typeof settings.maxAge === "number") {
    this.maxAge = settings.maxAge;
  }
  if (typeof settings.noWait === "boolean") {
    this.noWait = settings.noWait;
  }
});
exports.DataBaseServerTransactionSettings = DataBaseServerTransactionSettings;
var ServerAuthenticationSettings = /*#__PURE__*/function () {
  function ServerAuthenticationSettings() {
    var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, ServerAuthenticationSettings);
    /**
     * Se autorização deve ser habilitada. Sem autorização, o banco de dados inteiro pode ser lido e gravado por qualquer pessoa (não recomendado 🤷🏼‍♂️)
     */
    this.enabled = true;
    /**
     * Se a criação de novos usuários é permitida para qualquer pessoa ou apenas para o administrador
     */
    this.allowUserSignup = false;
    /**
     * Quantos novos usuários podem se inscrever por hora por endereço IP. Não implementado ainda
     */
    this.newUserRateLimit = 0;
    /**
     * Quantos minutos antes dos tokens de acesso expirarem. 0 para sem expiração.
     */
    this.tokensExpire = 0;
    /**
     * Quando o servidor é executado pela primeira vez, quais padrões usar para gerar o arquivo rules.json. Opções são: 'auth' (acesso apenas autenticado ao banco de dados, padrão), 'deny' (negar acesso a qualquer pessoa, exceto o usuário administrador), 'allow' (permitir acesso a qualquer pessoa)
     */
    this.defaultAccessRule = exports.AUTH_ACCESS_DEFAULT.ALLOW_AUTHENTICATED;
    /**
     * Se deve usar um banco de dados separado para autenticação e logs. 'v2' armazenará dados em auth.db, o que AINDA NÃO FOI TESTADO!
     */
    this.separateDb = false;
    if (_typeof(settings) !== "object") {
      settings = {};
    }
    if (typeof settings.enabled === "boolean") {
      this.enabled = settings.enabled;
    }
    if (typeof settings.allowUserSignup === "boolean") {
      this.allowUserSignup = settings.allowUserSignup;
    }
    if (typeof settings.newUserRateLimit === "number") {
      this.newUserRateLimit = settings.newUserRateLimit;
    }
    if (typeof settings.tokensExpire === "number") {
      this.tokensExpire = settings.tokensExpire;
    }
    if (typeof settings.defaultAccessRule === "string") {
      this.defaultAccessRule = settings.defaultAccessRule;
    }
    if (typeof settings.defaultAdminPassword === "string") {
      this.defaultAdminPassword = settings.defaultAdminPassword;
    }
    if (typeof settings.seperateDb === "boolean") {
      this.separateDb = settings.seperateDb;
    } // Lidar com a grafia anterior _errada_
    if (typeof settings.separateDb === "boolean") {
      this.separateDb = settings.separateDb;
    }
  }
  return _createClass(ServerAuthenticationSettings, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        enabled: this.enabled,
        allowUserSignup: this.allowUserSignup,
        newUserRateLimit: this.newUserRateLimit,
        tokensExpire: this.tokensExpire,
        defaultAccessRule: this.defaultAccessRule,
        defaultAdminPassword: this.defaultAdminPassword,
        separateDb: this.separateDb
      };
    }
  }]);
}();
exports.ServerAuthenticationSettings = ServerAuthenticationSettings;
var ServerSettings = /*#__PURE__*/_createClass(function ServerSettings() {
  var _this = this;
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  _classCallCheck(this, ServerSettings);
  var _a, _b, _c;
  this.logLevel = "log";
  this.host = "localhost";
  this.port = 3000;
  this.rootPath = "";
  this.maxPayloadSize = "10mb";
  this.allowOrigin = "*";
  this.trustProxy = true;
  this.serverVersion = "1.0.0";
  this.localPath = "./data";
  this.dbAuth = {};
  if (typeof options.logLevel === "string" && ["verbose", "log", "warn", "error"].includes(options.logLevel)) {
    this.logLevel = options.logLevel;
  }
  if (typeof options.host === "string") {
    this.host = options.host;
  }
  if (typeof options.port === "number") {
    this.port = options.port;
  }
  if (typeof options.maxPayloadSize === "string") {
    this.maxPayloadSize = options.maxPayloadSize;
  }
  if (typeof options.allowOrigin === "string") {
    this.allowOrigin = options.allowOrigin;
  }
  if (typeof options.trustProxy === "boolean") {
    this.trustProxy = options.trustProxy;
  }
  this.auth = new ServerAuthenticationSettings((_b = (_a = options.authentication) !== null && _a !== void 0 ? _a : options.auth) !== null && _b !== void 0 ? _b : {});
  var dbList = (Array.isArray(options.database) ? options.database : [options.database]).filter(function (db) {
    return typeof db !== "undefined";
  });
  if (_typeof(options.dbAuth) === "object") {
    this.dbAuth = Object.fromEntries(Object.entries(options.dbAuth).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        dbName = _ref2[0],
        auth = _ref2[1];
      if (auth instanceof ServerAuthenticationSettings) {
        return [dbName, auth];
      }
      return [dbName, new ServerAuthenticationSettings((0, utils_1.joinObjects)(_this.auth.toJSON(), auth !== null && auth !== void 0 ? auth : {}))];
    }));
  }
  dbList.forEach(function (db) {
    var _a;
    _this.dbAuth[db.name] = new ServerAuthenticationSettings((0, utils_1.joinObjects)(_this.auth.toJSON(), (_a = db.authentication) !== null && _a !== void 0 ? _a : {}));
  });
  if (typeof options.init === "function") {
    this.init = options.init;
  }
  if (typeof options.serverVersion === "string") {
    this.serverVersion = options.serverVersion;
  }
  this.transactions = new DataBaseServerTransactionSettings((_c = options.transactions) !== null && _c !== void 0 ? _c : {});
  if (_typeof(options.defineRules) === "object") {
    this.defineRules = options.defineRules;
  }
  if (typeof options.localPath === "string") {
    this.localPath = options.localPath;
  }
});
exports.ServerSettings = ServerSettings;
exports.isPossiblyServer = false;
var AbstractLocalServer = /*#__PURE__*/function (_ivipbase_core_1$Simp) {
  function AbstractLocalServer(localApp) {
    var _this2;
    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, AbstractLocalServer);
    _this2 = _callSuper(this, AbstractLocalServer);
    _this2.localApp = localApp;
    _this2._ready = false;
    _this2.securityRef = function (dbName) {
      return _this2.db(dbName).ref("__auth__/security");
    };
    _this2.authRef = function (dbName) {
      return _this2.db(dbName).ref("__auth__/accounts");
    };
    _this2.send_email = function (dbName, request) {
      return new Promise(function (resolve, reject) {
        try {
          if (!_this2.hasDatabase(dbName)) {
            throw new Error("Database '".concat(dbName, "' not found"));
          }
          var send_email = _this2.db(dbName).app.settings.email;
          if (!send_email || !send_email.send) {
            throw new Error("Email not configured");
          }
          send_email.send(request).then(resolve);
        } catch (e) {
          reject(e);
        }
      });
    };
    _this2.settings = new ServerSettings(settings);
    _this2.db = function (dbName) {
      return (0, database_1.getDatabase)(dbName, localApp);
    };
    _this2.storageFile = function (dbName) {
      return (0, storage_1.getStorage)(dbName, localApp);
    };
    _this2.hasDatabase = function (dbName) {
      return (0, database_1.hasDatabase)(dbName);
    };
    _this2.rules = function (dbName) {
      return _this2.db(dbName).rules;
    };
    _this2.debug = new ivipbase_core_1.DebugLogger(_this2.settings.logLevel, "[SERVER]");
    _this2.log = _this2.debug;
    _this2.on("ready", function () {
      _this2._ready = true;
    });
    return _this2;
  }
  /**
   * Aguarda o servidor estar pronto antes de executar o seu callback.
   * @param callback (opcional) função de retorno chamada quando o servidor estiver pronto para ser usado. Você também pode usar a promise retornada.
   * @returns retorna uma promise que resolve quando estiver pronto
   */
  _inherits(AbstractLocalServer, _ivipbase_core_1$Simp);
  return _createClass(AbstractLocalServer, [{
    key: "ready",
    value: (function () {
      var _ready = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(callback) {
        var _this3 = this;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this._ready) {
                _context.next = 3;
                break;
              }
              _context.next = 3;
              return new Promise(function (resolve) {
                return _this3.once("ready", resolve);
              });
            case 3:
              callback === null || callback === void 0 ? void 0 : callback();
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function ready(_x) {
        return _ready.apply(this, arguments);
      }
      return ready;
    }())
  }, {
    key: "isReady",
    get: function get() {
      return this._ready;
    }
    /**
     * Obtém a URL na qual o servidor está sendo executado
     */
  }, {
    key: "url",
    get: function get() {
      //return `http${this.settings.https.enabled ? 's' : ''}://${this.settings.host}:${this.settings.port}/${this.settings.rootPath}`;
      return "http://".concat(this.settings.host, ":").concat(this.settings.port, "/").concat(this.settings.rootPath).replace(/\/+$/gi, "");
    }
  }, {
    key: "dbNames",
    get: function get() {
      return (0, database_1.getDatabasesNames)();
    }
    /**
     * Redefine a senha do usuário. Isso também pode ser feito usando o ponto de extremidade da API auth/reset_password
     * @param clientIp endereço IP do usuário
     * @param code código de redefinição que foi enviado para o endereço de e-mail do usuário
     * @param newPassword nova senha escolhida pelo usuário
     */
  }, {
    key: "resetPassword",
    value: function resetPassword(dbName, clientIp, code, newPassword) {
      throw new ServerNotReadyError();
    }
    /**
     * Marca o endereço de e-mail da conta do usuário como validado. Isso também pode ser feito usando o ponto de extremidade da API auth/verify_email
     * @param clientIp endereço IP do usuário
     * @param code código de verificação enviado para o endereço de e-mail do usuário
     */
  }, {
    key: "verifyEmailAddress",
    value: function verifyEmailAddress(dbName, clientIp, code) {
      throw new ServerNotReadyError();
    }
  }, {
    key: "getLogBytesUsage",
    value: function getLogBytesUsage() {
      return Promise.resolve({});
    }
  }]);
}(ivipbase_core_1.SimpleEventEmitter);
exports.AbstractLocalServer = AbstractLocalServer;
var LocalServer = /*#__PURE__*/function (_AbstractLocalServer) {
  function LocalServer(localApp) {
    var _this4;
    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, LocalServer);
    _this4 = _callSuper(this, LocalServer, [localApp, settings]);
    _this4.isServer = false;
    _this4.init();
    return _this4;
  }
  _inherits(LocalServer, _AbstractLocalServer);
  return _createClass(LocalServer, [{
    key: "init",
    value: function init() {
      this.emit("ready");
    }
  }]);
}(AbstractLocalServer);
exports.LocalServer = LocalServer;

},{"../database":23,"../storage":32,"../utils":37,"ivipbase-core":152}],31:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StorageReference = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var _private = Symbol("private");
var StorageReference = /*#__PURE__*/function (_ivipbase_core_1$Simp) {
  function StorageReference(storage, path) {
    var _this;
    _classCallCheck(this, StorageReference);
    _this = _callSuper(this, StorageReference);
    _this.storage = storage;
    if (!path) {
      path = "";
    }
    path = path.replace(/^\/|\/$/g, ""); // Trim slashes
    var pathInfo = ivipbase_core_1.PathInfo.get(path);
    var key = pathInfo.key;
    _this[_private] = {
      get path() {
        return path;
      },
      get key() {
        return key;
      }
    };
    return _this;
  }
  _inherits(StorageReference, _ivipbase_core_1$Simp);
  return _createClass(StorageReference, [{
    key: "on",
    value: function on(event, callback) {
      return _get(_getPrototypeOf(StorageReference.prototype), "on", this).call(this, event, callback);
    }
  }, {
    key: "emit",
    value: function emit(event, data) {
      return _get(_getPrototypeOf(StorageReference.prototype), "emit", this).call(this, event, data);
    }
  }, {
    key: "isWildcardPath",
    get: function get() {
      return this.fullPath.indexOf("*") >= 0 || this.fullPath.indexOf("$") >= 0;
    }
    /**
     * O caminho com o qual esta instância foi criada
     */
  }, {
    key: "fullPath",
    get: function get() {
      return this[_private].path;
    }
  }, {
    key: "name",
    get: function get() {
      return ivipbase_core_1.PathInfo.get(this.fullPath).key;
    }
    /**
     * A chave ou índice deste nó
     */
  }, {
    key: "key",
    get: function get() {
      var key = this[_private].key;
      return typeof key === "number" ? "[".concat(key, "]") : key;
    }
    /**
     * Retorna uma nova referência para o pai deste nó
     */
  }, {
    key: "parent",
    get: function get() {
      var info = ivipbase_core_1.PathInfo.get(this.fullPath);
      if (info.parentPath === null) {
        return null;
      }
      return new StorageReference(this.storage, info.parentPath);
    }
  }, {
    key: "root",
    get: function get() {
      return new StorageReference(this.storage, "");
    }
    /**
     * Retorna uma nova referência para um nó filho
     * @param childPath Chave de filho, índice ou caminho
     * @returns Referência para o filho
     */
  }, {
    key: "child",
    value: function child(childPath) {
      childPath = typeof childPath === "number" ? childPath : childPath.replace(/^\/|\/$/g, "");
      var targetPath = ivipbase_core_1.PathInfo.getChildPath(this.fullPath, childPath);
      return new StorageReference(this.storage, targetPath); //  `${this.path}/${childPath}`
    }
  }, {
    key: "put",
    value: function put(data, metadata) {
      if (this.isWildcardPath) {
        throw new Error("Cannot put data to a wildcard path");
      }
      var self = this;
      var promise = this.storage.put(this, data, metadata, function (snapshot) {
        self.emit("state_changed", snapshot);
      });
      return {
        pause: function pause() {},
        resume: function resume() {},
        cancel: function cancel() {},
        on: function on(event, callback) {
          return self.on(event, callback);
        },
        async: function async() {
          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return promise;
                case 2:
                  return _context.abrupt("return", self);
                case 3:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }))();
        }
      };
    }
  }, {
    key: "putString",
    value: function putString(data) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "text";
      if (this.isWildcardPath) {
        throw new Error("Cannot put data to a wildcard path");
      }
      var self = this;
      var promise = this.storage.putString(this, data, type, function (snapshot) {
        self.emit("state_changed", snapshot);
      });
      return {
        pause: function pause() {},
        resume: function resume() {},
        cancel: function cancel() {},
        on: function on(event, callback) {
          return self.on(event, callback);
        },
        async: function async() {
          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return promise;
                case 2:
                  return _context2.abrupt("return", self);
                case 3:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }))();
        }
      };
    }
  }, {
    key: "delete",
    value: function _delete() {
      if (this.isWildcardPath) {
        throw new Error("Cannot delete a wildcard path");
      }
      return this.storage["delete"](this);
    }
  }, {
    key: "getDownloadURL",
    value: function getDownloadURL() {
      return this.storage.getDownloadURL(this);
    }
  }, {
    key: "getBlob",
    value: function getBlob() {}
  }, {
    key: "getBytes",
    value: function getBytes() {}
  }, {
    key: "getStream",
    value: function getStream() {}
  }, {
    key: "listAll",
    value: function listAll() {
      return this.storage.listAll(this);
    }
  }, {
    key: "list",
    value: function list(config) {
      return this.storage.list(this, config);
    }
  }]);
}(ivipbase_core_1.SimpleEventEmitter);
exports.StorageReference = StorageReference;

},{"ivipbase-core":152}],32:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStorage = exports.Storage = void 0;
var ivipbase_core_1 = require("ivipbase-core");
var app_1 = require("../app");
var database_1 = require("../database");
var StorageReference_1 = require("./StorageReference");
var storageController_1 = require("./storageController");
var Storage = /*#__PURE__*/function (_ivipbase_core_1$Simp) {
  function Storage(app, database) {
    var _this;
    _classCallCheck(this, Storage);
    _this = _callSuper(this, Storage);
    _this.app = app;
    _this.database = database;
    _this._ready = false;
    _this.api = app.isServer ? new storageController_1.StorageServer(_this) : new storageController_1.StorageClient(_this);
    _this.app.ready(function () {
      _this._ready = true;
      _this.emit("ready");
    });
    return _this;
  }
  _inherits(Storage, _ivipbase_core_1$Simp);
  return _createClass(Storage, [{
    key: "ready",
    value: function () {
      var _ready = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(callback) {
        var _this2 = this;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this._ready) {
                _context.next = 3;
                break;
              }
              _context.next = 3;
              return new Promise(function (resolve) {
                return _this2.once("ready", resolve);
              });
            case 3:
              callback === null || callback === void 0 ? void 0 : callback(this);
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function ready(_x) {
        return _ready.apply(this, arguments);
      }
      return ready;
    }()
  }, {
    key: "root",
    value: function root() {
      return new StorageReference_1.StorageReference(this, "");
    }
    /**
     * Creates a reference to a node
     * @param path
     * @returns reference to the requested node
     */
  }, {
    key: "ref",
    value: function ref(path) {
      return new StorageReference_1.StorageReference(this, path);
    }
  }, {
    key: "put",
    value: function put(ref, data, metadata, onStateChanged) {
      return this.api.put(ref, data, metadata);
    }
  }, {
    key: "putString",
    value: function putString(ref, data, type, onStateChanged) {
      return this.api.putString(ref, data, type);
    }
  }, {
    key: "delete",
    value: function _delete(ref) {
      return this.api["delete"](ref);
    }
  }, {
    key: "getDownloadURL",
    value: function getDownloadURL(ref) {
      return this.api.getDownloadURL(ref);
    }
  }, {
    key: "listAll",
    value: function listAll(ref) {
      return this.api.listAll(ref);
    }
  }, {
    key: "list",
    value: function list(ref, config) {
      return this.api.list(ref, config);
    }
  }]);
}(ivipbase_core_1.SimpleEventEmitter);
exports.Storage = Storage;
function getStorage() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var app = args.find(function (a) {
      return a instanceof app_1.IvipBaseApp;
    }),
    dbName;
  var appNames = (0, app_1.getAppsName)();
  if (!app) {
    var name = appNames.find(function (n) {
      return args.includes(n);
    });
    app = name ? (0, app_1.getApp)(name) : (0, app_1.getFirstApp)();
  }
  var database = args.find(function (d) {
    return typeof d === "string" && appNames.includes(d) !== true;
  });
  if (typeof database !== "string") {
    database = app.settings.dbname;
  }
  dbName = (Array.isArray(database) ? database : [database])[0];
  if (!(0, database_1.hasDatabase)(dbName)) {
    throw new Error("Database \"".concat(dbName, "\" does not exist"));
  }
  if (app.storageFile.has(dbName)) {
    return app.storageFile.get(dbName);
  }
  var db = app.databases.get(dbName);
  var storage = new Storage(app, db);
  app.storageFile.set(dbName, storage);
  return storage;
}
exports.getStorage = getStorage;

},{"../app":1,"../database":23,"./StorageReference":31,"./storageController":34,"ivipbase-core":152}],33:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StorageClient = void 0;
var StorageReference_1 = require("../StorageReference");
var StorageClient = /*#__PURE__*/function () {
  function StorageClient(storage) {
    _classCallCheck(this, StorageClient);
    this.storage = storage;
  }
  return _createClass(StorageClient, [{
    key: "put",
    value: function () {
      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(p, data, metadata, onStateChanged) {
        var ref;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              ref = p instanceof StorageReference_1.StorageReference ? p : new StorageReference_1.StorageReference(this.storage, p);
              _context.next = 3;
              return this.storage.app.request({
                route: "/storage/".concat(this.storage.database.name, "/").concat(ref.fullPath) + ((metadata === null || metadata === void 0 ? void 0 : metadata.contentType) ? "?contentType=".concat(metadata.contentType) : ""),
                data: data,
                method: "PUT",
                onUploadProgress: onStateChanged ? function (progressEvent) {
                  onStateChanged({
                    bytesTransferred: progressEvent.loaded,
                    totalBytes: progressEvent.total,
                    state: "running",
                    metadata: metadata,
                    task: "put",
                    ref: ref
                  });
                } : undefined
              });
            case 3:
              return _context.abrupt("return", _context.sent);
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function put(_x, _x2, _x3, _x4) {
        return _put.apply(this, arguments);
      }
      return put;
    }()
  }, {
    key: "putString",
    value: function () {
      var _putString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(p, data, type, onStateChanged) {
        var ref;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              ref = p instanceof StorageReference_1.StorageReference ? p : new StorageReference_1.StorageReference(this.storage, p);
              _context2.next = 3;
              return this.storage.app.request({
                route: "/storage/".concat(this.storage.database.name, "/").concat(ref.fullPath, "?format=").concat(type !== null && type !== void 0 ? type : "text"),
                data: {
                  format: type !== null && type !== void 0 ? type : "text",
                  data: data
                },
                method: "PUT",
                onUploadProgress: onStateChanged ? function (progressEvent) {
                  onStateChanged({
                    bytesTransferred: progressEvent.loaded,
                    totalBytes: progressEvent.total,
                    state: "running",
                    metadata: undefined,
                    task: "put",
                    ref: ref
                  });
                } : undefined
              });
            case 3:
              return _context2.abrupt("return", _context2.sent);
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function putString(_x5, _x6, _x7, _x8) {
        return _putString.apply(this, arguments);
      }
      return putString;
    }()
  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(p) {
        var ref;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              ref = p instanceof StorageReference_1.StorageReference ? p : new StorageReference_1.StorageReference(this.storage, p);
              _context3.next = 3;
              return this.storage.app.request({
                route: "/storage/".concat(this.storage.database.name, "/").concat(ref.fullPath),
                method: "DELETE"
              });
            case 3:
              return _context3.abrupt("return", Promise.resolve());
            case 4:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function _delete(_x9) {
        return _delete2.apply(this, arguments);
      }
      return _delete;
    }()
  }, {
    key: "getDownloadURL",
    value: function () {
      var _getDownloadURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(p) {
        var ref, _yield$this$storage$a, path, isFile;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              ref = p instanceof StorageReference_1.StorageReference ? p : new StorageReference_1.StorageReference(this.storage, p);
              _context4.next = 3;
              return this.storage.app.request({
                method: "GET",
                route: "storage-url/".concat(this.storage.database.name, "/").concat(ref.fullPath)
              });
            case 3:
              _yield$this$storage$a = _context4.sent;
              path = _yield$this$storage$a.path;
              isFile = _yield$this$storage$a.isFile;
              return _context4.abrupt("return", typeof path === "string" && isFile ? "".concat(this.storage.app.url, "/").concat(path.replace(/^\/+/, "")) : null);
            case 7:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function getDownloadURL(_x10) {
        return _getDownloadURL.apply(this, arguments);
      }
      return getDownloadURL;
    }()
  }, {
    key: "listAll",
    value: function () {
      var _listAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(p) {
        var _this = this;
        var ref, _yield$this$storage$a2, items, prefixes;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              ref = p instanceof StorageReference_1.StorageReference ? p : new StorageReference_1.StorageReference(this.storage, p);
              _context5.next = 3;
              return this.storage.app.request({
                method: "GET",
                route: "storage-list/".concat(this.storage.database.name, "/").concat(ref.fullPath)
              });
            case 3:
              _yield$this$storage$a2 = _context5.sent;
              items = _yield$this$storage$a2.items;
              prefixes = _yield$this$storage$a2.prefixes;
              return _context5.abrupt("return", {
                items: items.map(function (path) {
                  return new StorageReference_1.StorageReference(_this.storage, path);
                }),
                prefixes: prefixes.map(function (path) {
                  return new StorageReference_1.StorageReference(_this.storage, path);
                })
              });
            case 7:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function listAll(_x11) {
        return _listAll.apply(this, arguments);
      }
      return listAll;
    }()
  }, {
    key: "list",
    value: function () {
      var _list = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(p, config) {
        var _this2 = this;
        var ref, _yield$this$storage$a3, items, prefixes, more, page;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              ref = p instanceof StorageReference_1.StorageReference ? p : new StorageReference_1.StorageReference(this.storage, p);
              _context6.next = 3;
              return this.storage.app.request({
                method: "GET",
                route: "storage-list/".concat(this.storage.database.name, "/").concat(ref.fullPath),
                data: config
              });
            case 3:
              _yield$this$storage$a3 = _context6.sent;
              items = _yield$this$storage$a3.items;
              prefixes = _yield$this$storage$a3.prefixes;
              more = _yield$this$storage$a3.more;
              page = _yield$this$storage$a3.page;
              return _context6.abrupt("return", {
                more: more,
                page: page,
                items: items.map(function (path) {
                  return new StorageReference_1.StorageReference(_this2.storage, path);
                }),
                prefixes: prefixes.map(function (path) {
                  return new StorageReference_1.StorageReference(_this2.storage, path);
                })
              });
            case 9:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function list(_x12, _x13) {
        return _list.apply(this, arguments);
      }
      return list;
    }()
  }]);
}();
exports.StorageClient = StorageClient;

},{"../StorageReference":31}],34:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StorageClient = exports.StorageServer = void 0;
var StorageClient_1 = require("./StorageClient");
Object.defineProperty(exports, "StorageClient", {
  enumerable: true,
  get: function get() {
    return StorageClient_1.StorageClient;
  }
});
var StorageServer = /*#__PURE__*/function (_StorageClient_1$Stor) {
  function StorageServer(storage) {
    var _this;
    _classCallCheck(this, StorageServer);
    _this = _callSuper(this, StorageServer, [storage]);
    _this.storage = storage;
    return _this;
  }
  _inherits(StorageServer, _StorageClient_1$Stor);
  return _createClass(StorageServer);
}(StorageClient_1.StorageClient);
exports.StorageServer = StorageServer;

},{"./StorageClient":33}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getExtension = exports.getType = exports.define = exports.extensions = exports.types = void 0;
var standard = {
  "application/andrew-inset": ["ez"],
  "application/applixware": ["aw"],
  "application/atom+xml": ["atom"],
  "application/atomcat+xml": ["atomcat"],
  "application/atomdeleted+xml": ["atomdeleted"],
  "application/atomsvc+xml": ["atomsvc"],
  "application/atsc-dwd+xml": ["dwd"],
  "application/atsc-held+xml": ["held"],
  "application/atsc-rsat+xml": ["rsat"],
  "application/bdoc": ["bdoc"],
  "application/calendar+xml": ["xcs"],
  "application/ccxml+xml": ["ccxml"],
  "application/cdfx+xml": ["cdfx"],
  "application/cdmi-capability": ["cdmia"],
  "application/cdmi-container": ["cdmic"],
  "application/cdmi-domain": ["cdmid"],
  "application/cdmi-object": ["cdmio"],
  "application/cdmi-queue": ["cdmiq"],
  "application/cu-seeme": ["cu"],
  "application/dash+xml": ["mpd"],
  "application/davmount+xml": ["davmount"],
  "application/docbook+xml": ["dbk"],
  "application/dssc+der": ["dssc"],
  "application/dssc+xml": ["xdssc"],
  "application/ecmascript": ["es", "ecma"],
  "application/emma+xml": ["emma"],
  "application/emotionml+xml": ["emotionml"],
  "application/epub+zip": ["epub"],
  "application/exi": ["exi"],
  "application/express": ["exp"],
  "application/fdt+xml": ["fdt"],
  "application/font-tdpfr": ["pfr"],
  "application/geo+json": ["geojson"],
  "application/gml+xml": ["gml"],
  "application/gpx+xml": ["gpx"],
  "application/gxf": ["gxf"],
  "application/gzip": ["gz"],
  "application/hjson": ["hjson"],
  "application/hyperstudio": ["stk"],
  "application/inkml+xml": ["ink", "inkml"],
  "application/ipfix": ["ipfix"],
  "application/its+xml": ["its"],
  "application/java-archive": ["jar", "war", "ear"],
  "application/java-serialized-object": ["ser"],
  "application/java-vm": ["class"],
  "application/javascript": ["js", "mjs"],
  "application/json": ["json", "map"],
  "application/json5": ["json5"],
  "application/jsonml+json": ["jsonml"],
  "application/ld+json": ["jsonld"],
  "application/lgr+xml": ["lgr"],
  "application/lost+xml": ["lostxml"],
  "application/mac-binhex40": ["hqx"],
  "application/mac-compactpro": ["cpt"],
  "application/mads+xml": ["mads"],
  "application/manifest+json": ["webmanifest"],
  "application/marc": ["mrc"],
  "application/marcxml+xml": ["mrcx"],
  "application/mathematica": ["ma", "nb", "mb"],
  "application/mathml+xml": ["mathml"],
  "application/mbox": ["mbox"],
  "application/mediaservercontrol+xml": ["mscml"],
  "application/metalink+xml": ["metalink"],
  "application/metalink4+xml": ["meta4"],
  "application/mets+xml": ["mets"],
  "application/mmt-aei+xml": ["maei"],
  "application/mmt-usd+xml": ["musd"],
  "application/mods+xml": ["mods"],
  "application/mp21": ["m21", "mp21"],
  "application/mp4": ["mp4s", "m4p"],
  "application/msword": ["doc", "dot"],
  "application/mxf": ["mxf"],
  "application/n-quads": ["nq"],
  "application/n-triples": ["nt"],
  "application/node": ["cjs"],
  "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"],
  "application/oda": ["oda"],
  "application/oebps-package+xml": ["opf"],
  "application/ogg": ["ogx"],
  "application/omdoc+xml": ["omdoc"],
  "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
  "application/oxps": ["oxps"],
  "application/p2p-overlay+xml": ["relo"],
  "application/patch-ops-error+xml": ["xer"],
  "application/pdf": ["pdf"],
  "application/pgp-encrypted": ["pgp"],
  "application/pgp-signature": ["asc", "sig"],
  "application/pics-rules": ["prf"],
  "application/pkcs10": ["p10"],
  "application/pkcs7-mime": ["p7m", "p7c"],
  "application/pkcs7-signature": ["p7s"],
  "application/pkcs8": ["p8"],
  "application/pkix-attr-cert": ["ac"],
  "application/pkix-cert": ["cer"],
  "application/pkix-crl": ["crl"],
  "application/pkix-pkipath": ["pkipath"],
  "application/pkixcmp": ["pki"],
  "application/pls+xml": ["pls"],
  "application/postscript": ["ai", "eps", "ps"],
  "application/provenance+xml": ["provx"],
  "application/pskc+xml": ["pskcxml"],
  "application/raml+yaml": ["raml"],
  "application/rdf+xml": ["rdf", "owl"],
  "application/reginfo+xml": ["rif"],
  "application/relax-ng-compact-syntax": ["rnc"],
  "application/resource-lists+xml": ["rl"],
  "application/resource-lists-diff+xml": ["rld"],
  "application/rls-services+xml": ["rs"],
  "application/route-apd+xml": ["rapd"],
  "application/route-s-tsid+xml": ["sls"],
  "application/route-usd+xml": ["rusd"],
  "application/rpki-ghostbusters": ["gbr"],
  "application/rpki-manifest": ["mft"],
  "application/rpki-roa": ["roa"],
  "application/rsd+xml": ["rsd"],
  "application/rss+xml": ["rss"],
  "application/rtf": ["rtf"],
  "application/sbml+xml": ["sbml"],
  "application/scvp-cv-request": ["scq"],
  "application/scvp-cv-response": ["scs"],
  "application/scvp-vp-request": ["spq"],
  "application/scvp-vp-response": ["spp"],
  "application/sdp": ["sdp"],
  "application/senml+xml": ["senmlx"],
  "application/sensml+xml": ["sensmlx"],
  "application/set-payment-initiation": ["setpay"],
  "application/set-registration-initiation": ["setreg"],
  "application/shf+xml": ["shf"],
  "application/sieve": ["siv", "sieve"],
  "application/smil+xml": ["smi", "smil"],
  "application/sparql-query": ["rq"],
  "application/sparql-results+xml": ["srx"],
  "application/srgs": ["gram"],
  "application/srgs+xml": ["grxml"],
  "application/sru+xml": ["sru"],
  "application/ssdl+xml": ["ssdl"],
  "application/ssml+xml": ["ssml"],
  "application/swid+xml": ["swidtag"],
  "application/tei+xml": ["tei", "teicorpus"],
  "application/thraud+xml": ["tfi"],
  "application/timestamped-data": ["tsd"],
  "application/toml": ["toml"],
  "application/trig": ["trig"],
  "application/ttml+xml": ["ttml"],
  "application/ubjson": ["ubj"],
  "application/urc-ressheet+xml": ["rsheet"],
  "application/urc-targetdesc+xml": ["td"],
  "application/voicexml+xml": ["vxml"],
  "application/wasm": ["wasm"],
  "application/widget": ["wgt"],
  "application/winhlp": ["hlp"],
  "application/wsdl+xml": ["wsdl"],
  "application/wspolicy+xml": ["wspolicy"],
  "application/xaml+xml": ["xaml"],
  "application/xcap-att+xml": ["xav"],
  "application/xcap-caps+xml": ["xca"],
  "application/xcap-diff+xml": ["xdf"],
  "application/xcap-el+xml": ["xel"],
  "application/xcap-ns+xml": ["xns"],
  "application/xenc+xml": ["xenc"],
  "application/xhtml+xml": ["xhtml", "xht"],
  "application/xliff+xml": ["xlf"],
  "application/xml": ["xml", "xsl", "xsd", "rng"],
  "application/xml-dtd": ["dtd"],
  "application/xop+xml": ["xop"],
  "application/xproc+xml": ["xpl"],
  "application/xslt+xml": ["*xsl", "xslt"],
  "application/xspf+xml": ["xspf"],
  "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
  "application/yang": ["yang"],
  "application/yin+xml": ["yin"],
  "application/zip": ["zip"],
  "audio/3gpp": ["*3gpp"],
  "audio/adpcm": ["adp"],
  "audio/amr": ["amr"],
  "audio/basic": ["au", "snd"],
  "audio/midi": ["mid", "midi", "kar", "rmi"],
  "audio/mobile-xmf": ["mxmf"],
  "audio/mp3": ["*mp3"],
  "audio/mp4": ["m4a", "mp4a"],
  "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
  "audio/ogg": ["oga", "ogg", "spx", "opus"],
  "audio/s3m": ["s3m"],
  "audio/silk": ["sil"],
  "audio/wav": ["wav"],
  "audio/wave": ["*wav"],
  "audio/webm": ["weba"],
  "audio/xm": ["xm"],
  "font/collection": ["ttc"],
  "font/otf": ["otf"],
  "font/ttf": ["ttf"],
  "font/woff": ["woff"],
  "font/woff2": ["woff2"],
  "image/aces": ["exr"],
  "image/apng": ["apng"],
  "image/avif": ["avif"],
  "image/bmp": ["bmp"],
  "image/cgm": ["cgm"],
  "image/dicom-rle": ["drle"],
  "image/emf": ["emf"],
  "image/fits": ["fits"],
  "image/g3fax": ["g3"],
  "image/gif": ["gif"],
  "image/heic": ["heic"],
  "image/heic-sequence": ["heics"],
  "image/heif": ["heif"],
  "image/heif-sequence": ["heifs"],
  "image/hej2k": ["hej2"],
  "image/hsj2": ["hsj2"],
  "image/ief": ["ief"],
  "image/jls": ["jls"],
  "image/jp2": ["jp2", "jpg2"],
  "image/jpeg": ["jpeg", "jpg", "jpe"],
  "image/jph": ["jph"],
  "image/jphc": ["jhc"],
  "image/jpm": ["jpm"],
  "image/jpx": ["jpx", "jpf"],
  "image/jxr": ["jxr"],
  "image/jxra": ["jxra"],
  "image/jxrs": ["jxrs"],
  "image/jxs": ["jxs"],
  "image/jxsc": ["jxsc"],
  "image/jxsi": ["jxsi"],
  "image/jxss": ["jxss"],
  "image/ktx": ["ktx"],
  "image/ktx2": ["ktx2"],
  "image/png": ["png"],
  "image/sgi": ["sgi"],
  "image/svg+xml": ["svg", "svgz"],
  "image/t38": ["t38"],
  "image/tiff": ["tif", "tiff"],
  "image/tiff-fx": ["tfx"],
  "image/webp": ["webp"],
  "image/wmf": ["wmf"],
  "message/disposition-notification": ["disposition-notification"],
  "message/global": ["u8msg"],
  "message/global-delivery-status": ["u8dsn"],
  "message/global-disposition-notification": ["u8mdn"],
  "message/global-headers": ["u8hdr"],
  "message/rfc822": ["eml", "mime"],
  "model/3mf": ["3mf"],
  "model/gltf+json": ["gltf"],
  "model/gltf-binary": ["glb"],
  "model/iges": ["igs", "iges"],
  "model/mesh": ["msh", "mesh", "silo"],
  "model/mtl": ["mtl"],
  "model/obj": ["obj"],
  "model/step+xml": ["stpx"],
  "model/step+zip": ["stpz"],
  "model/step-xml+zip": ["stpxz"],
  "model/stl": ["stl"],
  "model/vrml": ["wrl", "vrml"],
  "model/x3d+binary": ["*x3db", "x3dbz"],
  "model/x3d+fastinfoset": ["x3db"],
  "model/x3d+vrml": ["*x3dv", "x3dvz"],
  "model/x3d+xml": ["x3d", "x3dz"],
  "model/x3d-vrml": ["x3dv"],
  "text/cache-manifest": ["appcache", "manifest"],
  "text/calendar": ["ics", "ifb"],
  "text/coffeescript": ["coffee", "litcoffee"],
  "text/css": ["css"],
  "text/csv": ["csv"],
  "text/html": ["html", "htm", "shtml"],
  "text/jade": ["jade"],
  "text/jsx": ["jsx"],
  "text/less": ["less"],
  "text/markdown": ["markdown", "md"],
  "text/mathml": ["mml"],
  "text/mdx": ["mdx"],
  "text/n3": ["n3"],
  "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
  "text/richtext": ["rtx"],
  "text/rtf": ["*rtf"],
  "text/sgml": ["sgml", "sgm"],
  "text/shex": ["shex"],
  "text/slim": ["slim", "slm"],
  "text/spdx": ["spdx"],
  "text/stylus": ["stylus", "styl"],
  "text/tab-separated-values": ["tsv"],
  "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
  "text/turtle": ["ttl"],
  "text/uri-list": ["uri", "uris", "urls"],
  "text/vcard": ["vcard"],
  "text/vtt": ["vtt"],
  "text/xml": ["*xml"],
  "text/yaml": ["yaml", "yml"],
  "video/3gpp": ["3gp", "3gpp"],
  "video/3gpp2": ["3g2"],
  "video/h261": ["h261"],
  "video/h263": ["h263"],
  "video/h264": ["h264"],
  "video/iso.segment": ["m4s"],
  "video/jpeg": ["jpgv"],
  "video/jpm": ["*jpm", "jpgm"],
  "video/mj2": ["mj2", "mjp2"],
  "video/mp2t": ["ts"],
  "video/mp4": ["mp4", "mp4v", "mpg4"],
  "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
  "video/ogg": ["ogv"],
  "video/quicktime": ["qt", "mov"],
  "video/webm": ["webm"]
};
var other = {
  "application/prs.cww": ["cww"],
  "application/vnd.1000minds.decision-model+xml": ["1km"],
  "application/vnd.3gpp.pic-bw-large": ["plb"],
  "application/vnd.3gpp.pic-bw-small": ["psb"],
  "application/vnd.3gpp.pic-bw-var": ["pvb"],
  "application/vnd.3gpp2.tcap": ["tcap"],
  "application/vnd.3m.post-it-notes": ["pwn"],
  "application/vnd.accpac.simply.aso": ["aso"],
  "application/vnd.accpac.simply.imp": ["imp"],
  "application/vnd.acucobol": ["acu"],
  "application/vnd.acucorp": ["atc", "acutc"],
  "application/vnd.adobe.air-application-installer-package+zip": ["air"],
  "application/vnd.adobe.formscentral.fcdt": ["fcdt"],
  "application/vnd.adobe.fxp": ["fxp", "fxpl"],
  "application/vnd.adobe.xdp+xml": ["xdp"],
  "application/vnd.adobe.xfdf": ["xfdf"],
  "application/vnd.ahead.space": ["ahead"],
  "application/vnd.airzip.filesecure.azf": ["azf"],
  "application/vnd.airzip.filesecure.azs": ["azs"],
  "application/vnd.amazon.ebook": ["azw"],
  "application/vnd.americandynamics.acc": ["acc"],
  "application/vnd.amiga.ami": ["ami"],
  "application/vnd.android.package-archive": ["apk"],
  "application/vnd.anser-web-certificate-issue-initiation": ["cii"],
  "application/vnd.anser-web-funds-transfer-initiation": ["fti"],
  "application/vnd.antix.game-component": ["atx"],
  "application/vnd.apple.installer+xml": ["mpkg"],
  "application/vnd.apple.keynote": ["key"],
  "application/vnd.apple.mpegurl": ["m3u8"],
  "application/vnd.apple.numbers": ["numbers"],
  "application/vnd.apple.pages": ["pages"],
  "application/vnd.apple.pkpass": ["pkpass"],
  "application/vnd.aristanetworks.swi": ["swi"],
  "application/vnd.astraea-software.iota": ["iota"],
  "application/vnd.audiograph": ["aep"],
  "application/vnd.balsamiq.bmml+xml": ["bmml"],
  "application/vnd.blueice.multipass": ["mpm"],
  "application/vnd.bmi": ["bmi"],
  "application/vnd.businessobjects": ["rep"],
  "application/vnd.chemdraw+xml": ["cdxml"],
  "application/vnd.chipnuts.karaoke-mmd": ["mmd"],
  "application/vnd.cinderella": ["cdy"],
  "application/vnd.citationstyles.style+xml": ["csl"],
  "application/vnd.claymore": ["cla"],
  "application/vnd.cloanto.rp9": ["rp9"],
  "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"],
  "application/vnd.cluetrust.cartomobile-config": ["c11amc"],
  "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"],
  "application/vnd.commonspace": ["csp"],
  "application/vnd.contact.cmsg": ["cdbcmsg"],
  "application/vnd.cosmocaller": ["cmc"],
  "application/vnd.crick.clicker": ["clkx"],
  "application/vnd.crick.clicker.keyboard": ["clkk"],
  "application/vnd.crick.clicker.palette": ["clkp"],
  "application/vnd.crick.clicker.template": ["clkt"],
  "application/vnd.crick.clicker.wordbank": ["clkw"],
  "application/vnd.criticaltools.wbs+xml": ["wbs"],
  "application/vnd.ctc-posml": ["pml"],
  "application/vnd.cups-ppd": ["ppd"],
  "application/vnd.curl.car": ["car"],
  "application/vnd.curl.pcurl": ["pcurl"],
  "application/vnd.dart": ["dart"],
  "application/vnd.data-vision.rdz": ["rdz"],
  "application/vnd.dbf": ["dbf"],
  "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"],
  "application/vnd.dece.ttml+xml": ["uvt", "uvvt"],
  "application/vnd.dece.unspecified": ["uvx", "uvvx"],
  "application/vnd.dece.zip": ["uvz", "uvvz"],
  "application/vnd.denovo.fcselayout-link": ["fe_launch"],
  "application/vnd.dna": ["dna"],
  "application/vnd.dolby.mlp": ["mlp"],
  "application/vnd.dpgraph": ["dpg"],
  "application/vnd.dreamfactory": ["dfac"],
  "application/vnd.ds-keypoint": ["kpxx"],
  "application/vnd.dvb.ait": ["ait"],
  "application/vnd.dvb.service": ["svc"],
  "application/vnd.dynageo": ["geo"],
  "application/vnd.ecowin.chart": ["mag"],
  "application/vnd.enliven": ["nml"],
  "application/vnd.epson.esf": ["esf"],
  "application/vnd.epson.msf": ["msf"],
  "application/vnd.epson.quickanime": ["qam"],
  "application/vnd.epson.salt": ["slt"],
  "application/vnd.epson.ssf": ["ssf"],
  "application/vnd.eszigno3+xml": ["es3", "et3"],
  "application/vnd.ezpix-album": ["ez2"],
  "application/vnd.ezpix-package": ["ez3"],
  "application/vnd.fdf": ["fdf"],
  "application/vnd.fdsn.mseed": ["mseed"],
  "application/vnd.fdsn.seed": ["seed", "dataless"],
  "application/vnd.flographit": ["gph"],
  "application/vnd.fluxtime.clip": ["ftc"],
  "application/vnd.framemaker": ["fm", "frame", "maker", "book"],
  "application/vnd.frogans.fnc": ["fnc"],
  "application/vnd.frogans.ltf": ["ltf"],
  "application/vnd.fsc.weblaunch": ["fsc"],
  "application/vnd.fujitsu.oasys": ["oas"],
  "application/vnd.fujitsu.oasys2": ["oa2"],
  "application/vnd.fujitsu.oasys3": ["oa3"],
  "application/vnd.fujitsu.oasysgp": ["fg5"],
  "application/vnd.fujitsu.oasysprs": ["bh2"],
  "application/vnd.fujixerox.ddd": ["ddd"],
  "application/vnd.fujixerox.docuworks": ["xdw"],
  "application/vnd.fujixerox.docuworks.binder": ["xbd"],
  "application/vnd.fuzzysheet": ["fzs"],
  "application/vnd.genomatix.tuxedo": ["txd"],
  "application/vnd.geogebra.file": ["ggb"],
  "application/vnd.geogebra.tool": ["ggt"],
  "application/vnd.geometry-explorer": ["gex", "gre"],
  "application/vnd.geonext": ["gxt"],
  "application/vnd.geoplan": ["g2w"],
  "application/vnd.geospace": ["g3w"],
  "application/vnd.gmx": ["gmx"],
  "application/vnd.google-apps.document": ["gdoc"],
  "application/vnd.google-apps.presentation": ["gslides"],
  "application/vnd.google-apps.spreadsheet": ["gsheet"],
  "application/vnd.google-earth.kml+xml": ["kml"],
  "application/vnd.google-earth.kmz": ["kmz"],
  "application/vnd.grafeq": ["gqf", "gqs"],
  "application/vnd.groove-account": ["gac"],
  "application/vnd.groove-help": ["ghf"],
  "application/vnd.groove-identity-message": ["gim"],
  "application/vnd.groove-injector": ["grv"],
  "application/vnd.groove-tool-message": ["gtm"],
  "application/vnd.groove-tool-template": ["tpl"],
  "application/vnd.groove-vcard": ["vcg"],
  "application/vnd.hal+xml": ["hal"],
  "application/vnd.handheld-entertainment+xml": ["zmm"],
  "application/vnd.hbci": ["hbci"],
  "application/vnd.hhe.lesson-player": ["les"],
  "application/vnd.hp-hpgl": ["hpgl"],
  "application/vnd.hp-hpid": ["hpid"],
  "application/vnd.hp-hps": ["hps"],
  "application/vnd.hp-jlyt": ["jlt"],
  "application/vnd.hp-pcl": ["pcl"],
  "application/vnd.hp-pclxl": ["pclxl"],
  "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"],
  "application/vnd.ibm.minipay": ["mpy"],
  "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"],
  "application/vnd.ibm.rights-management": ["irm"],
  "application/vnd.ibm.secure-container": ["sc"],
  "application/vnd.iccprofile": ["icc", "icm"],
  "application/vnd.igloader": ["igl"],
  "application/vnd.immervision-ivp": ["ivp"],
  "application/vnd.immervision-ivu": ["ivu"],
  "application/vnd.insors.igm": ["igm"],
  "application/vnd.intercon.formnet": ["xpw", "xpx"],
  "application/vnd.intergeo": ["i2g"],
  "application/vnd.intu.qbo": ["qbo"],
  "application/vnd.intu.qfx": ["qfx"],
  "application/vnd.ipunplugged.rcprofile": ["rcprofile"],
  "application/vnd.irepository.package+xml": ["irp"],
  "application/vnd.is-xpr": ["xpr"],
  "application/vnd.isac.fcs": ["fcs"],
  "application/vnd.jam": ["jam"],
  "application/vnd.jcp.javame.midlet-rms": ["rms"],
  "application/vnd.jisp": ["jisp"],
  "application/vnd.joost.joda-archive": ["joda"],
  "application/vnd.kahootz": ["ktz", "ktr"],
  "application/vnd.kde.karbon": ["karbon"],
  "application/vnd.kde.kchart": ["chrt"],
  "application/vnd.kde.kformula": ["kfo"],
  "application/vnd.kde.kivio": ["flw"],
  "application/vnd.kde.kontour": ["kon"],
  "application/vnd.kde.kpresenter": ["kpr", "kpt"],
  "application/vnd.kde.kspread": ["ksp"],
  "application/vnd.kde.kword": ["kwd", "kwt"],
  "application/vnd.kenameaapp": ["htke"],
  "application/vnd.kidspiration": ["kia"],
  "application/vnd.kinar": ["kne", "knp"],
  "application/vnd.koan": ["skp", "skd", "skt", "skm"],
  "application/vnd.kodak-descriptor": ["sse"],
  "application/vnd.las.las+xml": ["lasxml"],
  "application/vnd.llamagraphics.life-balance.desktop": ["lbd"],
  "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"],
  "application/vnd.lotus-1-2-3": ["123"],
  "application/vnd.lotus-approach": ["apr"],
  "application/vnd.lotus-freelance": ["pre"],
  "application/vnd.lotus-notes": ["nsf"],
  "application/vnd.lotus-organizer": ["org"],
  "application/vnd.lotus-screencam": ["scm"],
  "application/vnd.lotus-wordpro": ["lwp"],
  "application/vnd.macports.portpkg": ["portpkg"],
  "application/vnd.mapbox-vector-tile": ["mvt"],
  "application/vnd.mcd": ["mcd"],
  "application/vnd.medcalcdata": ["mc1"],
  "application/vnd.mediastation.cdkey": ["cdkey"],
  "application/vnd.mfer": ["mwf"],
  "application/vnd.mfmp": ["mfm"],
  "application/vnd.micrografx.flo": ["flo"],
  "application/vnd.micrografx.igx": ["igx"],
  "application/vnd.mif": ["mif"],
  "application/vnd.mobius.daf": ["daf"],
  "application/vnd.mobius.dis": ["dis"],
  "application/vnd.mobius.mbk": ["mbk"],
  "application/vnd.mobius.mqy": ["mqy"],
  "application/vnd.mobius.msl": ["msl"],
  "application/vnd.mobius.plc": ["plc"],
  "application/vnd.mobius.txf": ["txf"],
  "application/vnd.mophun.application": ["mpn"],
  "application/vnd.mophun.certificate": ["mpc"],
  "application/vnd.mozilla.xul+xml": ["xul"],
  "application/vnd.ms-artgalry": ["cil"],
  "application/vnd.ms-cab-compressed": ["cab"],
  "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
  "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"],
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"],
  "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"],
  "application/vnd.ms-excel.template.macroenabled.12": ["xltm"],
  "application/vnd.ms-fontobject": ["eot"],
  "application/vnd.ms-htmlhelp": ["chm"],
  "application/vnd.ms-ims": ["ims"],
  "application/vnd.ms-lrm": ["lrm"],
  "application/vnd.ms-officetheme": ["thmx"],
  "application/vnd.ms-outlook": ["msg"],
  "application/vnd.ms-pki.seccat": ["cat"],
  "application/vnd.ms-pki.stl": ["*stl"],
  "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"],
  "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"],
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"],
  "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"],
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"],
  "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"],
  "application/vnd.ms-project": ["mpp", "mpt"],
  "application/vnd.ms-word.document.macroenabled.12": ["docm"],
  "application/vnd.ms-word.template.macroenabled.12": ["dotm"],
  "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"],
  "application/vnd.ms-wpl": ["wpl"],
  "application/vnd.ms-xpsdocument": ["xps"],
  "application/vnd.mseq": ["mseq"],
  "application/vnd.musician": ["mus"],
  "application/vnd.muvee.style": ["msty"],
  "application/vnd.mynfc": ["taglet"],
  "application/vnd.neurolanguage.nlu": ["nlu"],
  "application/vnd.nitf": ["ntf", "nitf"],
  "application/vnd.noblenet-directory": ["nnd"],
  "application/vnd.noblenet-sealer": ["nns"],
  "application/vnd.noblenet-web": ["nnw"],
  "application/vnd.nokia.n-gage.ac+xml": ["*ac"],
  "application/vnd.nokia.n-gage.data": ["ngdat"],
  "application/vnd.nokia.n-gage.symbian.install": ["n-gage"],
  "application/vnd.nokia.radio-preset": ["rpst"],
  "application/vnd.nokia.radio-presets": ["rpss"],
  "application/vnd.novadigm.edm": ["edm"],
  "application/vnd.novadigm.edx": ["edx"],
  "application/vnd.novadigm.ext": ["ext"],
  "application/vnd.oasis.opendocument.chart": ["odc"],
  "application/vnd.oasis.opendocument.chart-template": ["otc"],
  "application/vnd.oasis.opendocument.database": ["odb"],
  "application/vnd.oasis.opendocument.formula": ["odf"],
  "application/vnd.oasis.opendocument.formula-template": ["odft"],
  "application/vnd.oasis.opendocument.graphics": ["odg"],
  "application/vnd.oasis.opendocument.graphics-template": ["otg"],
  "application/vnd.oasis.opendocument.image": ["odi"],
  "application/vnd.oasis.opendocument.image-template": ["oti"],
  "application/vnd.oasis.opendocument.presentation": ["odp"],
  "application/vnd.oasis.opendocument.presentation-template": ["otp"],
  "application/vnd.oasis.opendocument.spreadsheet": ["ods"],
  "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"],
  "application/vnd.oasis.opendocument.text": ["odt"],
  "application/vnd.oasis.opendocument.text-master": ["odm"],
  "application/vnd.oasis.opendocument.text-template": ["ott"],
  "application/vnd.oasis.opendocument.text-web": ["oth"],
  "application/vnd.olpc-sugar": ["xo"],
  "application/vnd.oma.dd2+xml": ["dd2"],
  "application/vnd.openblox.game+xml": ["obgx"],
  "application/vnd.openofficeorg.extension": ["oxt"],
  "application/vnd.openstreetmap.data+xml": ["osm"],
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"],
  "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"],
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"],
  "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"],
  "application/vnd.osgeo.mapguide.package": ["mgp"],
  "application/vnd.osgi.dp": ["dp"],
  "application/vnd.osgi.subsystem": ["esa"],
  "application/vnd.palm": ["pdb", "pqa", "oprc"],
  "application/vnd.pawaafile": ["paw"],
  "application/vnd.pg.format": ["str"],
  "application/vnd.pg.osasli": ["ei6"],
  "application/vnd.picsel": ["efif"],
  "application/vnd.pmi.widget": ["wg"],
  "application/vnd.pocketlearn": ["plf"],
  "application/vnd.powerbuilder6": ["pbd"],
  "application/vnd.previewsystems.box": ["box"],
  "application/vnd.proteus.magazine": ["mgz"],
  "application/vnd.publishare-delta-tree": ["qps"],
  "application/vnd.pvi.ptid1": ["ptid"],
  "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
  "application/vnd.rar": ["rar"],
  "application/vnd.realvnc.bed": ["bed"],
  "application/vnd.recordare.musicxml": ["mxl"],
  "application/vnd.recordare.musicxml+xml": ["musicxml"],
  "application/vnd.rig.cryptonote": ["cryptonote"],
  "application/vnd.rim.cod": ["cod"],
  "application/vnd.rn-realmedia": ["rm"],
  "application/vnd.rn-realmedia-vbr": ["rmvb"],
  "application/vnd.route66.link66+xml": ["link66"],
  "application/vnd.sailingtracker.track": ["st"],
  "application/vnd.seemail": ["see"],
  "application/vnd.sema": ["sema"],
  "application/vnd.semd": ["semd"],
  "application/vnd.semf": ["semf"],
  "application/vnd.shana.informed.formdata": ["ifm"],
  "application/vnd.shana.informed.formtemplate": ["itp"],
  "application/vnd.shana.informed.interchange": ["iif"],
  "application/vnd.shana.informed.package": ["ipk"],
  "application/vnd.simtech-mindmapper": ["twd", "twds"],
  "application/vnd.smaf": ["mmf"],
  "application/vnd.smart.teacher": ["teacher"],
  "application/vnd.software602.filler.form+xml": ["fo"],
  "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
  "application/vnd.spotfire.dxp": ["dxp"],
  "application/vnd.spotfire.sfs": ["sfs"],
  "application/vnd.stardivision.calc": ["sdc"],
  "application/vnd.stardivision.draw": ["sda"],
  "application/vnd.stardivision.impress": ["sdd"],
  "application/vnd.stardivision.math": ["smf"],
  "application/vnd.stardivision.writer": ["sdw", "vor"],
  "application/vnd.stardivision.writer-global": ["sgl"],
  "application/vnd.stepmania.package": ["smzip"],
  "application/vnd.stepmania.stepchart": ["sm"],
  "application/vnd.sun.wadl+xml": ["wadl"],
  "application/vnd.sun.xml.calc": ["sxc"],
  "application/vnd.sun.xml.calc.template": ["stc"],
  "application/vnd.sun.xml.draw": ["sxd"],
  "application/vnd.sun.xml.draw.template": ["std"],
  "application/vnd.sun.xml.impress": ["sxi"],
  "application/vnd.sun.xml.impress.template": ["sti"],
  "application/vnd.sun.xml.math": ["sxm"],
  "application/vnd.sun.xml.writer": ["sxw"],
  "application/vnd.sun.xml.writer.global": ["sxg"],
  "application/vnd.sun.xml.writer.template": ["stw"],
  "application/vnd.sus-calendar": ["sus", "susp"],
  "application/vnd.svd": ["svd"],
  "application/vnd.symbian.install": ["sis", "sisx"],
  "application/vnd.syncml+xml": ["xsm"],
  "application/vnd.syncml.dm+wbxml": ["bdm"],
  "application/vnd.syncml.dm+xml": ["xdm"],
  "application/vnd.syncml.dmddf+xml": ["ddf"],
  "application/vnd.tao.intent-module-archive": ["tao"],
  "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"],
  "application/vnd.tmobile-livetv": ["tmo"],
  "application/vnd.trid.tpt": ["tpt"],
  "application/vnd.triscape.mxs": ["mxs"],
  "application/vnd.trueapp": ["tra"],
  "application/vnd.ufdl": ["ufd", "ufdl"],
  "application/vnd.uiq.theme": ["utz"],
  "application/vnd.umajin": ["umj"],
  "application/vnd.unity": ["unityweb"],
  "application/vnd.uoml+xml": ["uoml"],
  "application/vnd.vcx": ["vcx"],
  "application/vnd.visio": ["vsd", "vst", "vss", "vsw"],
  "application/vnd.visionary": ["vis"],
  "application/vnd.vsf": ["vsf"],
  "application/vnd.wap.wbxml": ["wbxml"],
  "application/vnd.wap.wmlc": ["wmlc"],
  "application/vnd.wap.wmlscriptc": ["wmlsc"],
  "application/vnd.webturbo": ["wtb"],
  "application/vnd.wolfram.player": ["nbp"],
  "application/vnd.wordperfect": ["wpd"],
  "application/vnd.wqd": ["wqd"],
  "application/vnd.wt.stf": ["stf"],
  "application/vnd.xara": ["xar"],
  "application/vnd.xfdl": ["xfdl"],
  "application/vnd.yamaha.hv-dic": ["hvd"],
  "application/vnd.yamaha.hv-script": ["hvs"],
  "application/vnd.yamaha.hv-voice": ["hvp"],
  "application/vnd.yamaha.openscoreformat": ["osf"],
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"],
  "application/vnd.yamaha.smaf-audio": ["saf"],
  "application/vnd.yamaha.smaf-phrase": ["spf"],
  "application/vnd.yellowriver-custom-menu": ["cmp"],
  "application/vnd.zul": ["zir", "zirz"],
  "application/vnd.zzazz.deck+xml": ["zaz"],
  "application/x-7z-compressed": ["7z"],
  "application/x-abiword": ["abw"],
  "application/x-ace-compressed": ["ace"],
  "application/x-apple-diskimage": ["*dmg"],
  "application/x-arj": ["arj"],
  "application/x-authorware-bin": ["aab", "x32", "u32", "vox"],
  "application/x-authorware-map": ["aam"],
  "application/x-authorware-seg": ["aas"],
  "application/x-bcpio": ["bcpio"],
  "application/x-bdoc": ["*bdoc"],
  "application/x-bittorrent": ["torrent"],
  "application/x-blorb": ["blb", "blorb"],
  "application/x-bzip": ["bz"],
  "application/x-bzip2": ["bz2", "boz"],
  "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"],
  "application/x-cdlink": ["vcd"],
  "application/x-cfs-compressed": ["cfs"],
  "application/x-chat": ["chat"],
  "application/x-chess-pgn": ["pgn"],
  "application/x-chrome-extension": ["crx"],
  "application/x-cocoa": ["cco"],
  "application/x-conference": ["nsc"],
  "application/x-cpio": ["cpio"],
  "application/x-csh": ["csh"],
  "application/x-debian-package": ["*deb", "udeb"],
  "application/x-dgc-compressed": ["dgc"],
  "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
  "application/x-doom": ["wad"],
  "application/x-dtbncx+xml": ["ncx"],
  "application/x-dtbook+xml": ["dtb"],
  "application/x-dtbresource+xml": ["res"],
  "application/x-dvi": ["dvi"],
  "application/x-envoy": ["evy"],
  "application/x-eva": ["eva"],
  "application/x-font-bdf": ["bdf"],
  "application/x-font-ghostscript": ["gsf"],
  "application/x-font-linux-psf": ["psf"],
  "application/x-font-pcf": ["pcf"],
  "application/x-font-snf": ["snf"],
  "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"],
  "application/x-freearc": ["arc"],
  "application/x-futuresplash": ["spl"],
  "application/x-gca-compressed": ["gca"],
  "application/x-glulx": ["ulx"],
  "application/x-gnumeric": ["gnumeric"],
  "application/x-gramps-xml": ["gramps"],
  "application/x-gtar": ["gtar"],
  "application/x-hdf": ["hdf"],
  "application/x-httpd-php": ["php"],
  "application/x-install-instructions": ["install"],
  "application/x-iso9660-image": ["*iso"],
  "application/x-iwork-keynote-sffkey": ["*key"],
  "application/x-iwork-numbers-sffnumbers": ["*numbers"],
  "application/x-iwork-pages-sffpages": ["*pages"],
  "application/x-java-archive-diff": ["jardiff"],
  "application/x-java-jnlp-file": ["jnlp"],
  "application/x-keepass2": ["kdbx"],
  "application/x-latex": ["latex"],
  "application/x-lua-bytecode": ["luac"],
  "application/x-lzh-compressed": ["lzh", "lha"],
  "application/x-makeself": ["run"],
  "application/x-mie": ["mie"],
  "application/x-mobipocket-ebook": ["prc", "mobi"],
  "application/x-ms-application": ["application"],
  "application/x-ms-shortcut": ["lnk"],
  "application/x-ms-wmd": ["wmd"],
  "application/x-ms-wmz": ["wmz"],
  "application/x-ms-xbap": ["xbap"],
  "application/x-msaccess": ["mdb"],
  "application/x-msbinder": ["obd"],
  "application/x-mscardfile": ["crd"],
  "application/x-msclip": ["clp"],
  "application/x-msdos-program": ["*exe"],
  "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"],
  "application/x-msmediaview": ["mvb", "m13", "m14"],
  "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"],
  "application/x-msmoney": ["mny"],
  "application/x-mspublisher": ["pub"],
  "application/x-msschedule": ["scd"],
  "application/x-msterminal": ["trm"],
  "application/x-mswrite": ["wri"],
  "application/x-netcdf": ["nc", "cdf"],
  "application/x-ns-proxy-autoconfig": ["pac"],
  "application/x-nzb": ["nzb"],
  "application/x-perl": ["pl", "pm"],
  "application/x-pilot": ["*prc", "*pdb"],
  "application/x-pkcs12": ["p12", "pfx"],
  "application/x-pkcs7-certificates": ["p7b", "spc"],
  "application/x-pkcs7-certreqresp": ["p7r"],
  "application/x-rar-compressed": ["*rar"],
  "application/x-redhat-package-manager": ["rpm"],
  "application/x-research-info-systems": ["ris"],
  "application/x-sea": ["sea"],
  "application/x-sh": ["sh"],
  "application/x-shar": ["shar"],
  "application/x-shockwave-flash": ["swf"],
  "application/x-silverlight-app": ["xap"],
  "application/x-sql": ["sql"],
  "application/x-stuffit": ["sit"],
  "application/x-stuffitx": ["sitx"],
  "application/x-subrip": ["srt"],
  "application/x-sv4cpio": ["sv4cpio"],
  "application/x-sv4crc": ["sv4crc"],
  "application/x-t3vm-image": ["t3"],
  "application/x-tads": ["gam"],
  "application/x-tar": ["tar"],
  "application/x-tcl": ["tcl", "tk"],
  "application/x-tex": ["tex"],
  "application/x-tex-tfm": ["tfm"],
  "application/x-texinfo": ["texinfo", "texi"],
  "application/x-tgif": ["*obj"],
  "application/x-ustar": ["ustar"],
  "application/x-virtualbox-hdd": ["hdd"],
  "application/x-virtualbox-ova": ["ova"],
  "application/x-virtualbox-ovf": ["ovf"],
  "application/x-virtualbox-vbox": ["vbox"],
  "application/x-virtualbox-vbox-extpack": ["vbox-extpack"],
  "application/x-virtualbox-vdi": ["vdi"],
  "application/x-virtualbox-vhd": ["vhd"],
  "application/x-virtualbox-vmdk": ["vmdk"],
  "application/x-wais-source": ["src"],
  "application/x-web-app-manifest+json": ["webapp"],
  "application/x-x509-ca-cert": ["der", "crt", "pem"],
  "application/x-xfig": ["fig"],
  "application/x-xliff+xml": ["*xlf"],
  "application/x-xpinstall": ["xpi"],
  "application/x-xz": ["xz"],
  "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
  "audio/vnd.dece.audio": ["uva", "uvva"],
  "audio/vnd.digital-winds": ["eol"],
  "audio/vnd.dra": ["dra"],
  "audio/vnd.dts": ["dts"],
  "audio/vnd.dts.hd": ["dtshd"],
  "audio/vnd.lucent.voice": ["lvp"],
  "audio/vnd.ms-playready.media.pya": ["pya"],
  "audio/vnd.nuera.ecelp4800": ["ecelp4800"],
  "audio/vnd.nuera.ecelp7470": ["ecelp7470"],
  "audio/vnd.nuera.ecelp9600": ["ecelp9600"],
  "audio/vnd.rip": ["rip"],
  "audio/x-aac": ["aac"],
  "audio/x-aiff": ["aif", "aiff", "aifc"],
  "audio/x-caf": ["caf"],
  "audio/x-flac": ["flac"],
  "audio/x-m4a": ["*m4a"],
  "audio/x-matroska": ["mka"],
  "audio/x-mpegurl": ["m3u"],
  "audio/x-ms-wax": ["wax"],
  "audio/x-ms-wma": ["wma"],
  "audio/x-pn-realaudio": ["ram", "ra"],
  "audio/x-pn-realaudio-plugin": ["rmp"],
  "audio/x-realaudio": ["*ra"],
  "audio/x-wav": ["*wav"],
  "chemical/x-cdx": ["cdx"],
  "chemical/x-cif": ["cif"],
  "chemical/x-cmdf": ["cmdf"],
  "chemical/x-cml": ["cml"],
  "chemical/x-csml": ["csml"],
  "chemical/x-xyz": ["xyz"],
  "image/prs.btif": ["btif"],
  "image/prs.pti": ["pti"],
  "image/vnd.adobe.photoshop": ["psd"],
  "image/vnd.airzip.accelerator.azv": ["azv"],
  "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"],
  "image/vnd.djvu": ["djvu", "djv"],
  "image/vnd.dvb.subtitle": ["*sub"],
  "image/vnd.dwg": ["dwg"],
  "image/vnd.dxf": ["dxf"],
  "image/vnd.fastbidsheet": ["fbs"],
  "image/vnd.fpx": ["fpx"],
  "image/vnd.fst": ["fst"],
  "image/vnd.fujixerox.edmics-mmr": ["mmr"],
  "image/vnd.fujixerox.edmics-rlc": ["rlc"],
  "image/vnd.microsoft.icon": ["ico"],
  "image/vnd.ms-dds": ["dds"],
  "image/vnd.ms-modi": ["mdi"],
  "image/vnd.ms-photo": ["wdp"],
  "image/vnd.net-fpx": ["npx"],
  "image/vnd.pco.b16": ["b16"],
  "image/vnd.tencent.tap": ["tap"],
  "image/vnd.valve.source.texture": ["vtf"],
  "image/vnd.wap.wbmp": ["wbmp"],
  "image/vnd.xiff": ["xif"],
  "image/vnd.zbrush.pcx": ["pcx"],
  "image/x-3ds": ["3ds"],
  "image/x-cmu-raster": ["ras"],
  "image/x-cmx": ["cmx"],
  "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"],
  "image/x-icon": ["*ico"],
  "image/x-jng": ["jng"],
  "image/x-mrsid-image": ["sid"],
  "image/x-ms-bmp": ["*bmp"],
  "image/x-pcx": ["*pcx"],
  "image/x-pict": ["pic", "pct"],
  "image/x-portable-anymap": ["pnm"],
  "image/x-portable-bitmap": ["pbm"],
  "image/x-portable-graymap": ["pgm"],
  "image/x-portable-pixmap": ["ppm"],
  "image/x-rgb": ["rgb"],
  "image/x-tga": ["tga"],
  "image/x-xbitmap": ["xbm"],
  "image/x-xpixmap": ["xpm"],
  "image/x-xwindowdump": ["xwd"],
  "message/vnd.wfa.wsc": ["wsc"],
  "model/vnd.collada+xml": ["dae"],
  "model/vnd.dwf": ["dwf"],
  "model/vnd.gdl": ["gdl"],
  "model/vnd.gtw": ["gtw"],
  "model/vnd.mts": ["mts"],
  "model/vnd.opengex": ["ogex"],
  "model/vnd.parasolid.transmit.binary": ["x_b"],
  "model/vnd.parasolid.transmit.text": ["x_t"],
  "model/vnd.sap.vds": ["vds"],
  "model/vnd.usdz+zip": ["usdz"],
  "model/vnd.valve.source.compiled-map": ["bsp"],
  "model/vnd.vtu": ["vtu"],
  "text/prs.lines.tag": ["dsc"],
  "text/vnd.curl": ["curl"],
  "text/vnd.curl.dcurl": ["dcurl"],
  "text/vnd.curl.mcurl": ["mcurl"],
  "text/vnd.curl.scurl": ["scurl"],
  "text/vnd.dvb.subtitle": ["sub"],
  "text/vnd.fly": ["fly"],
  "text/vnd.fmi.flexstor": ["flx"],
  "text/vnd.graphviz": ["gv"],
  "text/vnd.in3d.3dml": ["3dml"],
  "text/vnd.in3d.spot": ["spot"],
  "text/vnd.sun.j2me.app-descriptor": ["jad"],
  "text/vnd.wap.wml": ["wml"],
  "text/vnd.wap.wmlscript": ["wmls"],
  "text/x-asm": ["s", "asm"],
  "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
  "text/x-component": ["htc"],
  "text/x-fortran": ["f", "for", "f77", "f90"],
  "text/x-handlebars-template": ["hbs"],
  "text/x-java-source": ["java"],
  "text/x-lua": ["lua"],
  "text/x-markdown": ["mkd"],
  "text/x-nfo": ["nfo"],
  "text/x-opml": ["opml"],
  "text/x-org": ["*org"],
  "text/x-pascal": ["p", "pas"],
  "text/x-processing": ["pde"],
  "text/x-sass": ["sass"],
  "text/x-scss": ["scss"],
  "text/x-setext": ["etx"],
  "text/x-sfv": ["sfv"],
  "text/x-suse-ymp": ["ymp"],
  "text/x-uuencode": ["uu"],
  "text/x-vcalendar": ["vcs"],
  "text/x-vcard": ["vcf"],
  "video/vnd.dece.hd": ["uvh", "uvvh"],
  "video/vnd.dece.mobile": ["uvm", "uvvm"],
  "video/vnd.dece.pd": ["uvp", "uvvp"],
  "video/vnd.dece.sd": ["uvs", "uvvs"],
  "video/vnd.dece.video": ["uvv", "uvvv"],
  "video/vnd.dvb.file": ["dvb"],
  "video/vnd.fvt": ["fvt"],
  "video/vnd.mpegurl": ["mxu", "m4u"],
  "video/vnd.ms-playready.media.pyv": ["pyv"],
  "video/vnd.uvvu.mp4": ["uvu", "uvvu"],
  "video/vnd.vivo": ["viv"],
  "video/x-f4v": ["f4v"],
  "video/x-fli": ["fli"],
  "video/x-flv": ["flv"],
  "video/x-m4v": ["m4v"],
  "video/x-matroska": ["mkv", "mk3d", "mks"],
  "video/x-mng": ["mng"],
  "video/x-ms-asf": ["asf", "asx"],
  "video/x-ms-vob": ["vob"],
  "video/x-ms-wm": ["wm"],
  "video/x-ms-wmv": ["wmv"],
  "video/x-ms-wmx": ["wmx"],
  "video/x-ms-wvx": ["wvx"],
  "video/x-msvideo": ["avi"],
  "video/x-sgi-movie": ["movie"],
  "video/x-smv": ["smv"],
  "x-conference/x-cooltalk": ["ice"]
};
exports.types = new Map();
exports.extensions = new Map();
var define = function define(typeMap, force) {
  for (var type in typeMap) {
    var exts = typeMap[type].map(function (t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();
    for (var i = 0; i < exts.length; i++) {
      var ext = exts[i];
      if (ext[0] === "*") {
        continue;
      }
      if (!force && exports.types.has(ext)) {
        throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + exports.types.get(ext) + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
      }
      exports.types.set(ext, type);
    }
    if (force || !exports.extensions.has(type)) {
      var _ext = exts[0];
      exports.extensions.set(type, _ext[0] !== "*" ? _ext : _ext.substr(1));
    }
  }
};
exports.define = define;
(0, exports.define)(standard);
(0, exports.define)(other);
var getType = function getType(path) {
  path = String(path);
  var last = path.replace(/^.*[/\\]/, "").toLowerCase();
  var ext = last.replace(/^.*\./, "").toLowerCase();
  var hasPath = last.length < path.length;
  var hasDot = ext.length < last.length - 1;
  return (hasDot || !hasPath) && exports.types.get(ext) || "application/octet-binary";
};
exports.getType = getType;
var getExtension = function getExtension(type) {
  // type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  var t = /^\s*([^;\s]*)/.test(type);
  return t && exports.extensions.get(type.toLowerCase()) || null;
};
exports.getExtension = getExtension;

},{}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decode = exports.encode = void 0;
function encode(str) {
  return btoa(unescape(encodeURIComponent(str)));
}
exports.encode = encode;
function decode(base64) {
  return decodeURIComponent(escape(atob(base64)));
}
exports.decode = decode;
exports["default"] = {
  encode: encode,
  decode: decode
};

},{}],37:[function(require,module,exports){
"use strict";

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDate = exports.getExtension = exports.sanitizeEmailPrefix = exports.replaceUndefined = exports.joinObjects = exports.removeNulls = exports.pathValueToObject = exports.assert = exports.Mime = void 0;
var ivipbase_core_1 = require("ivipbase-core");
__exportStar(require("./base64"), exports);
exports.Mime = __importStar(require("./Mime"));
/**
 * Substituição para console.assert, lança um erro se a condição não for atendida.
 * @param condition Condição 'truthy'
 * @param error Mensagem de erro opcional
 */
function assert(condition, error) {
  if (!condition) {
    throw new Error("Asser\xE7\xE3o falhou: ".concat(error !== null && error !== void 0 ? error : "verifique seu código"));
  }
}
exports.assert = assert;
function pathValueToObject(dataPath, currentPath, value) {
  var result = value;
  var pathInfo = ivipbase_core_1.PathInfo.get(dataPath);
  var currentPathInfo = ivipbase_core_1.PathInfo.get(currentPath);
  var currentKeys = currentPathInfo.pathKeys.slice(currentPathInfo.pathKeys.findIndex(function (k) {
    return !pathInfo.pathKeys.includes(k);
  }));
  var _iterator = _createForOfIteratorHelper(currentKeys),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var k = _step.value;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return result;
}
exports.pathValueToObject = pathValueToObject;
function removeNulls(obj) {
  if (obj === null || !["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(obj))) {
    return obj;
  }
  var result = Array.isArray(obj) ? [] : {};
  for (var prop in obj) {
    var val = obj[prop];
    if (val === null) {
      continue;
    }
    result[prop] = val;
    if (_typeof(val) === "object") {
      result[prop] = removeNulls(val);
    }
  }
  return result;
}
exports.removeNulls = removeNulls;
function joinObjects(obj1) {
  var merge = function merge(obj1, obj2) {
    if (!obj1 || !obj2) {
      return obj2 !== null && obj2 !== void 0 ? obj2 : obj1;
    }
    if (["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(obj1)) !== true || ["[object Object]", "[object Array]"].includes(Object.prototype.toString.call(obj2)) !== true) {
      return obj2;
    }
    var result = Array.isArray(obj1) ? [] : {};
    var keys = [].concat(_toConsumableArray(Object.keys(obj1)), _toConsumableArray(Object.keys(obj2))).filter(function (v, i, a) {
      return a.indexOf(v) === i;
    });
    var _iterator2 = _createForOfIteratorHelper(keys),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var prop = _step2.value;
        result[prop] = merge(obj1[prop], obj2[prop]);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return result;
  };
  for (var _len = arguments.length, objs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    objs[_key - 1] = arguments[_key];
  }
  return objs.reduce(function (acc, obj) {
    return merge(acc, obj);
  }, obj1);
}
exports.joinObjects = joinObjects;
function replaceUndefined(obj) {
  if (!obj || obj === null || _typeof(obj) !== "object") {
    return obj !== null && obj !== void 0 ? obj : null;
  }
  var result = Array.isArray(obj) ? [] : {};
  for (var prop in obj) {
    var val = obj[prop];
    result[prop] = val === undefined ? null : val;
    if (_typeof(val) === "object") {
      result[prop] = replaceUndefined(val);
    }
  }
  return result;
}
exports.replaceUndefined = replaceUndefined;
function sanitizeEmailPrefix(email) {
  // Divide a string de email em duas partes: antes e depois do @
  var _email$split = email.split("@"),
    _email$split2 = _slicedToArray(_email$split, 2),
    prefix = _email$split2[0],
    domain = _email$split2[1];
  // Define o regex para os caracteres permitidos
  var allowedCharacters = /^[a-zA-Z0-9_.]+$/;
  // Filtra os caracteres da parte antes do @ que correspondem ao regex
  var sanitizedPrefix = prefix.split("").filter(function (_char) {
    return allowedCharacters.test(_char);
  }).join("");
  return sanitizedPrefix;
}
exports.sanitizeEmailPrefix = sanitizeEmailPrefix;
var getExtension = function getExtension(filename) {
  try {
    var i = filename.lastIndexOf(".");
    return i < 0 ? "" : filename.substr(i);
  } catch (_a) {
    return "";
  }
};
exports.getExtension = getExtension;
var isDate = function isDate(value) {
  if (value instanceof Date) {
    return !isNaN(value.getTime());
  }
  if (_typeof(value) === "object" && value !== null && typeof value.getMonth === "function") {
    return !isNaN(value.getTime());
  }
  if (typeof value === "string" && /^\d+$/.test(value) !== true) {
    var parsedDate = Date.parse(value);
    var iso8601Regex = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(\.\d+)?(Z|([+-]\d{2}:\d{2}))?$/;
    return !isNaN(parsedDate) && (new Date(parsedDate).toISOString().startsWith(value) || iso8601Regex.test(value));
  }
  return false;
};
exports.isDate = isDate;

},{"./Mime":35,"./base64":36,"ivipbase-core":152}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var localStorage = window.localStorage;
exports["default"] = localStorage;

},{}],39:[function(require,module,exports){
"use strict";

/**
 * Expose `Emitter`.
 */

exports.Emitter = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }
  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1),
    callbacks = this._callbacks['$' + event];
  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }
  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

},{}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.all = exports.VERSION = exports.HttpStatusCode = exports.CanceledError = exports.CancelToken = exports.Cancel = exports.AxiosHeaders = exports.AxiosError = exports.Axios = void 0;
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return _axios["default"];
  }
});
exports.toFormData = exports.spread = exports.mergeConfig = exports.isCancel = exports.isAxiosError = exports.getAdapter = exports.formToJSON = void 0;
var _axios = _interopRequireDefault(require("./lib/axios.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// This module is intended to unwrap Axios default export as named.
// Keep top-level export same with static properties
// so that it can keep same with es module or cjs
var Axios = exports.Axios = _axios["default"].Axios,
  AxiosError = exports.AxiosError = _axios["default"].AxiosError,
  CanceledError = exports.CanceledError = _axios["default"].CanceledError,
  isCancel = exports.isCancel = _axios["default"].isCancel,
  CancelToken = exports.CancelToken = _axios["default"].CancelToken,
  VERSION = exports.VERSION = _axios["default"].VERSION,
  all = exports.all = _axios["default"].all,
  Cancel = exports.Cancel = _axios["default"].Cancel,
  isAxiosError = exports.isAxiosError = _axios["default"].isAxiosError,
  spread = exports.spread = _axios["default"].spread,
  toFormData = exports.toFormData = _axios["default"].toFormData,
  AxiosHeaders = exports.AxiosHeaders = _axios["default"].AxiosHeaders,
  HttpStatusCode = exports.HttpStatusCode = _axios["default"].HttpStatusCode,
  formToJSON = exports.formToJSON = _axios["default"].formToJSON,
  getAdapter = exports.getAdapter = _axios["default"].getAdapter,
  mergeConfig = exports.mergeConfig = _axios["default"].mergeConfig;

},{"./lib/axios.js":44}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _utils = _interopRequireDefault(require("../utils.js"));
var _http = _interopRequireDefault(require("./http.js"));
var _xhr = _interopRequireDefault(require("./xhr.js"));
var _fetch = _interopRequireDefault(require("./fetch.js"));
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var knownAdapters = {
  http: _http["default"],
  xhr: _xhr["default"],
  fetch: _fetch["default"]
};
_utils["default"].forEach(knownAdapters, function (fn, value) {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {
        value: value
      });
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {
      value: value
    });
  }
});
var renderReason = function renderReason(reason) {
  return "- ".concat(reason);
};
var isResolvedHandle = function isResolvedHandle(adapter) {
  return _utils["default"].isFunction(adapter) || adapter === null || adapter === false;
};
var _default = exports["default"] = {
  getAdapter: function getAdapter(adapters) {
    adapters = _utils["default"].isArray(adapters) ? adapters : [adapters];
    var _adapters = adapters,
      length = _adapters.length;
    var nameOrAdapter;
    var adapter;
    var rejectedReasons = {};
    for (var i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      var id = void 0;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === undefined) {
          throw new _AxiosError["default"]("Unknown adapter '".concat(id, "'"));
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || '#' + i] = adapter;
    }
    if (!adapter) {
      var reasons = Object.entries(rejectedReasons).map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          id = _ref2[0],
          state = _ref2[1];
        return "adapter ".concat(id, " ") + (state === false ? 'is not supported by the environment' : 'is not available in the build');
      });
      var s = length ? reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0]) : 'as no adapter specified';
      throw new _AxiosError["default"]("There is no suitable adapter to dispatch the request " + s, 'ERR_NOT_SUPPORT');
    }
    return adapter;
  },
  adapters: knownAdapters
};

},{"../core/AxiosError.js":49,"../utils.js":89,"./fetch.js":42,"./http.js":71,"./xhr.js":43}],42:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _index = _interopRequireDefault(require("../platform/index.js"));
var _utils = _interopRequireDefault(require("../utils.js"));
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
var _composeSignals = _interopRequireDefault(require("../helpers/composeSignals.js"));
var _trackStream = require("../helpers/trackStream.js");
var _AxiosHeaders = _interopRequireDefault(require("../core/AxiosHeaders.js"));
var _progressEventReducer = _interopRequireDefault(require("../helpers/progressEventReducer.js"));
var _resolveConfig2 = _interopRequireDefault(require("../helpers/resolveConfig.js"));
var _settle = _interopRequireDefault(require("../core/settle.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
var fetchProgressDecorator = function fetchProgressDecorator(total, fn) {
  var lengthComputable = total != null;
  return function (loaded) {
    return setTimeout(function () {
      return fn({
        lengthComputable: lengthComputable,
        total: total,
        loaded: loaded
      });
    });
  };
};
var isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
var encodeText = isFetchSupported && (typeof TextEncoder === 'function' ? function (encoder) {
  return function (str) {
    return encoder.encode(str);
  };
}(new TextEncoder()) : ( /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(str) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.t0 = Uint8Array;
          _context.next = 3;
          return new Response(str).arrayBuffer();
        case 3:
          _context.t1 = _context.sent;
          return _context.abrupt("return", new _context.t0(_context.t1));
        case 5:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function (_x) {
    return _ref.apply(this, arguments);
  };
}()));
var supportsRequestStream = isReadableStreamSupported && function () {
  var duplexAccessed = false;
  var hasContentType = new Request(_index["default"].origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    }
  }).headers.has('Content-Type');
  return duplexAccessed && !hasContentType;
}();
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && !!function () {
  try {
    return _utils["default"].isReadableStream(new Response('').body);
  } catch (err) {
    // return undefined
  }
}();
var resolvers = {
  stream: supportsResponseStream && function (res) {
    return res.body;
  }
};
isFetchSupported && function (res) {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(function (type) {
    !resolvers[type] && (resolvers[type] = _utils["default"].isFunction(res[type]) ? function (res) {
      return res[type]();
    } : function (_, config) {
      throw new _AxiosError["default"]("Response type '".concat(type, "' is not supported"), _AxiosError["default"].ERR_NOT_SUPPORT, config);
    });
  });
}(new Response());
var getBodyLength = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(body) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (!(body == null)) {
            _context2.next = 2;
            break;
          }
          return _context2.abrupt("return", 0);
        case 2:
          if (!_utils["default"].isBlob(body)) {
            _context2.next = 4;
            break;
          }
          return _context2.abrupt("return", body.size);
        case 4:
          if (!_utils["default"].isSpecCompliantForm(body)) {
            _context2.next = 8;
            break;
          }
          _context2.next = 7;
          return new Request(body).arrayBuffer();
        case 7:
          return _context2.abrupt("return", _context2.sent.byteLength);
        case 8:
          if (!_utils["default"].isArrayBufferView(body)) {
            _context2.next = 10;
            break;
          }
          return _context2.abrupt("return", body.byteLength);
        case 10:
          if (_utils["default"].isURLSearchParams(body)) {
            body = body + '';
          }
          if (!_utils["default"].isString(body)) {
            _context2.next = 15;
            break;
          }
          _context2.next = 14;
          return encodeText(body);
        case 14:
          return _context2.abrupt("return", _context2.sent.byteLength);
        case 15:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function getBodyLength(_x2) {
    return _ref2.apply(this, arguments);
  };
}();
var resolveBodyLength = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(headers, body) {
    var length;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          length = _utils["default"].toFiniteNumber(headers.getContentLength());
          return _context3.abrupt("return", length == null ? getBodyLength(body) : length);
        case 2:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function resolveBodyLength(_x3, _x4) {
    return _ref3.apply(this, arguments);
  };
}();
var _default = exports["default"] = isFetchSupported && ( /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(config) {
    var _resolveConfig, url, method, data, signal, cancelToken, timeout, onDownloadProgress, onUploadProgress, responseType, headers, _resolveConfig$withCr, withCredentials, fetchOptions, _ref5, _ref6, composedSignal, stopTimeout, finished, request, onFinish, requestContentLength, _request, contentTypeHeader, response, isStreamResponse, options, responseContentLength, responseData;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _resolveConfig = (0, _resolveConfig2["default"])(config), url = _resolveConfig.url, method = _resolveConfig.method, data = _resolveConfig.data, signal = _resolveConfig.signal, cancelToken = _resolveConfig.cancelToken, timeout = _resolveConfig.timeout, onDownloadProgress = _resolveConfig.onDownloadProgress, onUploadProgress = _resolveConfig.onUploadProgress, responseType = _resolveConfig.responseType, headers = _resolveConfig.headers, _resolveConfig$withCr = _resolveConfig.withCredentials, withCredentials = _resolveConfig$withCr === void 0 ? 'same-origin' : _resolveConfig$withCr, fetchOptions = _resolveConfig.fetchOptions;
          responseType = responseType ? (responseType + '').toLowerCase() : 'text';
          _ref5 = signal || cancelToken || timeout ? (0, _composeSignals["default"])([signal, cancelToken], timeout) : [], _ref6 = _slicedToArray(_ref5, 2), composedSignal = _ref6[0], stopTimeout = _ref6[1];
          onFinish = function onFinish() {
            !finished && setTimeout(function () {
              composedSignal && composedSignal.unsubscribe();
            });
            finished = true;
          };
          _context4.prev = 4;
          _context4.t0 = onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head';
          if (!_context4.t0) {
            _context4.next = 11;
            break;
          }
          _context4.next = 9;
          return resolveBodyLength(headers, data);
        case 9:
          _context4.t1 = requestContentLength = _context4.sent;
          _context4.t0 = _context4.t1 !== 0;
        case 11:
          if (!_context4.t0) {
            _context4.next = 15;
            break;
          }
          _request = new Request(url, {
            method: 'POST',
            body: data,
            duplex: "half"
          });
          if (_utils["default"].isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
            headers.setContentType(contentTypeHeader);
          }
          if (_request.body) {
            data = (0, _trackStream.trackStream)(_request.body, DEFAULT_CHUNK_SIZE, fetchProgressDecorator(requestContentLength, (0, _progressEventReducer["default"])(onUploadProgress)), null, encodeText);
          }
        case 15:
          if (!_utils["default"].isString(withCredentials)) {
            withCredentials = withCredentials ? 'cors' : 'omit';
          }
          request = new Request(url, _objectSpread(_objectSpread({}, fetchOptions), {}, {
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: "half",
            withCredentials: withCredentials
          }));
          _context4.next = 19;
          return fetch(request);
        case 19:
          response = _context4.sent;
          isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');
          if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
            options = {};
            ['status', 'statusText', 'headers'].forEach(function (prop) {
              options[prop] = response[prop];
            });
            responseContentLength = _utils["default"].toFiniteNumber(response.headers.get('content-length'));
            response = new Response((0, _trackStream.trackStream)(response.body, DEFAULT_CHUNK_SIZE, onDownloadProgress && fetchProgressDecorator(responseContentLength, (0, _progressEventReducer["default"])(onDownloadProgress, true)), isStreamResponse && onFinish, encodeText), options);
          }
          responseType = responseType || 'text';
          _context4.next = 25;
          return resolvers[_utils["default"].findKey(resolvers, responseType) || 'text'](response, config);
        case 25:
          responseData = _context4.sent;
          !isStreamResponse && onFinish();
          stopTimeout && stopTimeout();
          _context4.next = 30;
          return new Promise(function (resolve, reject) {
            (0, _settle["default"])(resolve, reject, {
              data: responseData,
              headers: _AxiosHeaders["default"].from(response.headers),
              status: response.status,
              statusText: response.statusText,
              config: config,
              request: request
            });
          });
        case 30:
          return _context4.abrupt("return", _context4.sent);
        case 33:
          _context4.prev = 33;
          _context4.t2 = _context4["catch"](4);
          onFinish();
          if (!(_context4.t2 && _context4.t2.name === 'TypeError' && /fetch/i.test(_context4.t2.message))) {
            _context4.next = 38;
            break;
          }
          throw Object.assign(new _AxiosError["default"]('Network Error', _AxiosError["default"].ERR_NETWORK, config, request), {
            cause: _context4.t2.cause || _context4.t2
          });
        case 38:
          throw _AxiosError["default"].from(_context4.t2, _context4.t2 && _context4.t2.code, config, request);
        case 39:
        case "end":
          return _context4.stop();
      }
    }, _callee4, null, [[4, 33]]);
  }));
  return function (_x5) {
    return _ref4.apply(this, arguments);
  };
}());

},{"../core/AxiosError.js":49,"../core/AxiosHeaders.js":50,"../core/settle.js":55,"../helpers/composeSignals.js":65,"../helpers/progressEventReducer.js":74,"../helpers/resolveConfig.js":75,"../helpers/trackStream.js":81,"../platform/index.js":88,"../utils.js":89}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _utils = _interopRequireDefault(require("./../utils.js"));
var _settle = _interopRequireDefault(require("./../core/settle.js"));
var _transitional = _interopRequireDefault(require("../defaults/transitional.js"));
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
var _CanceledError = _interopRequireDefault(require("../cancel/CanceledError.js"));
var _parseProtocol = _interopRequireDefault(require("../helpers/parseProtocol.js"));
var _index = _interopRequireDefault(require("../platform/index.js"));
var _AxiosHeaders = _interopRequireDefault(require("../core/AxiosHeaders.js"));
var _progressEventReducer = _interopRequireDefault(require("../helpers/progressEventReducer.js"));
var _resolveConfig = _interopRequireDefault(require("../helpers/resolveConfig.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
var isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';
var _default = exports["default"] = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var _config = (0, _resolveConfig["default"])(config);
    var requestData = _config.data;
    var requestHeaders = _AxiosHeaders["default"].from(_config.headers).normalize();
    var responseType = _config.responseType;
    var onCanceled;
    function done() {
      if (_config.cancelToken) {
        _config.cancelToken.unsubscribe(onCanceled);
      }
      if (_config.signal) {
        _config.signal.removeEventListener('abort', onCanceled);
      }
    }
    var request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = _AxiosHeaders["default"].from('getAllResponseHeaders' in request && request.getAllResponseHeaders());
      var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      (0, _settle["default"])(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }
    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new _AxiosError["default"]('Request aborted', _AxiosError["default"].ECONNABORTED, _config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new _AxiosError["default"]('Network Error', _AxiosError["default"].ERR_NETWORK, _config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = _config.transitional || _transitional["default"];
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new _AxiosError["default"](timeoutErrorMessage, transitional.clarifyTimeoutError ? _AxiosError["default"].ETIMEDOUT : _AxiosError["default"].ECONNABORTED, _config, request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      _utils["default"].forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!_utils["default"].isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (typeof _config.onDownloadProgress === 'function') {
      request.addEventListener('progress', (0, _progressEventReducer["default"])(_config.onDownloadProgress, true));
    }

    // Not all browsers support upload events
    if (typeof _config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', (0, _progressEventReducer["default"])(_config.onUploadProgress));
    }
    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function onCanceled(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new _CanceledError["default"](null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }
    var protocol = (0, _parseProtocol["default"])(_config.url);
    if (protocol && _index["default"].protocols.indexOf(protocol) === -1) {
      reject(new _AxiosError["default"]('Unsupported protocol ' + protocol + ':', _AxiosError["default"].ERR_BAD_REQUEST, config));
      return;
    }

    // Send the request
    request.send(requestData || null);
  });
};

},{"../cancel/CanceledError.js":46,"../core/AxiosError.js":49,"../core/AxiosHeaders.js":50,"../defaults/transitional.js":58,"../helpers/parseProtocol.js":73,"../helpers/progressEventReducer.js":74,"../helpers/resolveConfig.js":75,"../platform/index.js":88,"./../core/settle.js":55,"./../utils.js":89}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _utils = _interopRequireDefault(require("./utils.js"));
var _bind = _interopRequireDefault(require("./helpers/bind.js"));
var _Axios = _interopRequireDefault(require("./core/Axios.js"));
var _mergeConfig = _interopRequireDefault(require("./core/mergeConfig.js"));
var _index = _interopRequireDefault(require("./defaults/index.js"));
var _formDataToJSON = _interopRequireDefault(require("./helpers/formDataToJSON.js"));
var _CanceledError = _interopRequireDefault(require("./cancel/CanceledError.js"));
var _CancelToken = _interopRequireDefault(require("./cancel/CancelToken.js"));
var _isCancel = _interopRequireDefault(require("./cancel/isCancel.js"));
var _data = require("./env/data.js");
var _toFormData = _interopRequireDefault(require("./helpers/toFormData.js"));
var _AxiosError = _interopRequireDefault(require("./core/AxiosError.js"));
var _spread = _interopRequireDefault(require("./helpers/spread.js"));
var _isAxiosError = _interopRequireDefault(require("./helpers/isAxiosError.js"));
var _AxiosHeaders = _interopRequireDefault(require("./core/AxiosHeaders.js"));
var _adapters = _interopRequireDefault(require("./adapters/adapters.js"));
var _HttpStatusCode = _interopRequireDefault(require("./helpers/HttpStatusCode.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new _Axios["default"](defaultConfig);
  var instance = (0, _bind["default"])(_Axios["default"].prototype.request, context);

  // Copy axios.prototype to instance
  _utils["default"].extend(instance, _Axios["default"].prototype, context, {
    allOwnKeys: true
  });

  // Copy context to instance
  _utils["default"].extend(instance, context, null, {
    allOwnKeys: true
  });

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance((0, _mergeConfig["default"])(defaultConfig, instanceConfig));
  };
  return instance;
}

// Create the default instance to be exported
var axios = createInstance(_index["default"]);

// Expose Axios class to allow class inheritance
axios.Axios = _Axios["default"];

// Expose Cancel & CancelToken
axios.CanceledError = _CanceledError["default"];
axios.CancelToken = _CancelToken["default"];
axios.isCancel = _isCancel["default"];
axios.VERSION = _data.VERSION;
axios.toFormData = _toFormData["default"];

// Expose AxiosError class
axios.AxiosError = _AxiosError["default"];

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = _spread["default"];

// Expose isAxiosError
axios.isAxiosError = _isAxiosError["default"];

// Expose mergeConfig
axios.mergeConfig = _mergeConfig["default"];
axios.AxiosHeaders = _AxiosHeaders["default"];
axios.formToJSON = function (thing) {
  return (0, _formDataToJSON["default"])(_utils["default"].isHTMLForm(thing) ? new FormData(thing) : thing);
};
axios.getAdapter = _adapters["default"].getAdapter;
axios.HttpStatusCode = _HttpStatusCode["default"];
axios["default"] = axios;

// this module should only have a default export
var _default = exports["default"] = axios;

},{"./adapters/adapters.js":41,"./cancel/CancelToken.js":45,"./cancel/CanceledError.js":46,"./cancel/isCancel.js":47,"./core/Axios.js":48,"./core/AxiosError.js":49,"./core/AxiosHeaders.js":50,"./core/mergeConfig.js":54,"./defaults/index.js":57,"./env/data.js":59,"./helpers/HttpStatusCode.js":61,"./helpers/bind.js":62,"./helpers/formDataToJSON.js":67,"./helpers/isAxiosError.js":69,"./helpers/spread.js":77,"./helpers/toFormData.js":79,"./utils.js":89}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _CanceledError = _interopRequireDefault(require("./CanceledError.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
var CancelToken = /*#__PURE__*/function () {
  function CancelToken(executor) {
    _classCallCheck(this, CancelToken);
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token = this;

    // eslint-disable-next-line func-names
    this.promise.then(function (cancel) {
      if (!token._listeners) return;
      var i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = function (onfulfilled) {
      var _resolve;
      // eslint-disable-next-line func-names
      var promise = new Promise(function (resolve) {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }
      token.reason = new _CanceledError["default"](message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  return _createClass(CancelToken, [{
    key: "throwIfRequested",
    value: function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }

    /**
     * Subscribe to the cancel signal
     */
  }, {
    key: "subscribe",
    value: function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }

    /**
     * Unsubscribe from the cancel signal
     */
  }, {
    key: "unsubscribe",
    value: function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    }

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
  }], [{
    key: "source",
    value: function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    }
  }]);
}();
var _default = exports["default"] = CancelToken;

},{"./CanceledError.js":46}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
var _utils = _interopRequireDefault(require("../utils.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  _AxiosError["default"].call(this, message == null ? 'canceled' : message, _AxiosError["default"].ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}
_utils["default"].inherits(CanceledError, _AxiosError["default"], {
  __CANCEL__: true
});
var _default = exports["default"] = CanceledError;

},{"../core/AxiosError.js":49,"../utils.js":89}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isCancel;
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

},{}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _utils = _interopRequireDefault(require("./../utils.js"));
var _buildURL = _interopRequireDefault(require("../helpers/buildURL.js"));
var _InterceptorManager = _interopRequireDefault(require("./InterceptorManager.js"));
var _dispatchRequest = _interopRequireDefault(require("./dispatchRequest.js"));
var _mergeConfig = _interopRequireDefault(require("./mergeConfig.js"));
var _buildFullPath = _interopRequireDefault(require("./buildFullPath.js"));
var _validator = _interopRequireDefault(require("../helpers/validator.js"));
var _AxiosHeaders = _interopRequireDefault(require("./AxiosHeaders.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var validators = _validator["default"].validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
var Axios = /*#__PURE__*/function () {
  function Axios(instanceConfig) {
    _classCallCheck(this, Axios);
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new _InterceptorManager["default"](),
      response: new _InterceptorManager["default"]()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  return _createClass(Axios, [{
    key: "request",
    value: (function () {
      var _request2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(configOrUrl, config) {
        var dummy, stack;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return this._request(configOrUrl, config);
            case 3:
              return _context.abrupt("return", _context.sent);
            case 6:
              _context.prev = 6;
              _context.t0 = _context["catch"](0);
              if (_context.t0 instanceof Error) {
                Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();

                // slice off the Error: ... line
                stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
                try {
                  if (!_context.t0.stack) {
                    _context.t0.stack = stack;
                    // match without the 2 top stack lines
                  } else if (stack && !String(_context.t0.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
                    _context.t0.stack += '\n' + stack;
                  }
                } catch (e) {
                  // ignore the case where "stack" is an un-writable property
                }
              }
              throw _context.t0;
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 6]]);
      }));
      function request(_x, _x2) {
        return _request2.apply(this, arguments);
      }
      return request;
    }())
  }, {
    key: "_request",
    value: function _request(configOrUrl, config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof configOrUrl === 'string') {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = (0, _mergeConfig["default"])(this.defaults, config);
      var _config = config,
        transitional = _config.transitional,
        paramsSerializer = _config.paramsSerializer,
        headers = _config.headers;
      if (transitional !== undefined) {
        _validator["default"].assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators["boolean"]),
          forcedJSONParsing: validators.transitional(validators["boolean"]),
          clarifyTimeoutError: validators.transitional(validators["boolean"])
        }, false);
      }
      if (paramsSerializer != null) {
        if (_utils["default"].isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          _validator["default"].assertOptions(paramsSerializer, {
            encode: validators["function"],
            serialize: validators["function"]
          }, true);
        }
      }

      // Set config.method
      config.method = (config.method || this.defaults.method || 'get').toLowerCase();

      // Flatten headers
      var contextHeaders = headers && _utils["default"].merge(headers.common, headers[config.method]);
      headers && _utils["default"].forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function (method) {
        delete headers[method];
      });
      config.headers = _AxiosHeaders["default"].concat(contextHeaders, headers);

      // filter out skipped interceptors
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      var i = 0;
      var len;
      if (!synchronousRequestInterceptors) {
        var chain = [_dispatchRequest["default"].bind(this), undefined];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config);
        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      var newConfig = config;
      i = 0;
      while (i < len) {
        var onFulfilled = requestInterceptorChain[i++];
        var onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = _dispatchRequest["default"].call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i = 0;
      len = responseInterceptorChain.length;
      while (i < len) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }
      return promise;
    }
  }, {
    key: "getUri",
    value: function getUri(config) {
      config = (0, _mergeConfig["default"])(this.defaults, config);
      var fullPath = (0, _buildFullPath["default"])(config.baseURL, config.url);
      return (0, _buildURL["default"])(fullPath, config.params, config.paramsSerializer);
    }
  }]);
}(); // Provide aliases for supported request methods
_utils["default"].forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request((0, _mergeConfig["default"])(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});
_utils["default"].forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request((0, _mergeConfig["default"])(config || {}, {
        method: method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url: url,
        data: data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});
var _default = exports["default"] = Axios;

},{"../helpers/buildURL.js":63,"../helpers/validator.js":82,"./../utils.js":89,"./AxiosHeaders.js":50,"./InterceptorManager.js":51,"./buildFullPath.js":52,"./dispatchRequest.js":53,"./mergeConfig.js":54}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _utils = _interopRequireDefault(require("../utils.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
_utils["default"].inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: _utils["default"].toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED', 'ERR_NOT_SUPPORT', 'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(function (code) {
  descriptors[code] = {
    value: code
  };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {
  value: true
});

// eslint-disable-next-line func-names
AxiosError.from = function (error, code, config, request, response, customProps) {
  var axiosError = Object.create(prototype);
  _utils["default"].toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, function (prop) {
    return prop !== 'isAxiosError';
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var _default = exports["default"] = AxiosError;

},{"../utils.js":89}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _utils = _interopRequireDefault(require("../utils.js"));
var _parseHeaders = _interopRequireDefault(require("../helpers/parseHeaders.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var $internals = Symbol('internals');
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return _utils["default"].isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  var tokens = Object.create(null);
  var tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  var match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = function isValidHeaderName(str) {
  return /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
};
function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (_utils["default"].isFunction(filter)) {
    return filter.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!_utils["default"].isString(value)) return;
  if (_utils["default"].isString(filter)) {
    return value.indexOf(filter) !== -1;
  }
  if (_utils["default"].isRegExp(filter)) {
    return filter.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, function (w, _char, str) {
    return _char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  var accessorName = _utils["default"].toCamelCase(' ' + header);
  ['get', 'set', 'has'].forEach(function (methodName) {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function value(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = /*#__PURE__*/function () {
  function AxiosHeaders(headers) {
    _classCallCheck(this, AxiosHeaders);
    headers && this.set(headers);
  }
  return _createClass(AxiosHeaders, [{
    key: "set",
    value: function set(header, valueOrRewrite, rewrite) {
      var self = this;
      function setHeader(_value, _header, _rewrite) {
        var lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error('header name must be a non-empty string');
        }
        var key = _utils["default"].findKey(self, lHeader);
        if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {
          self[key || _header] = normalizeValue(_value);
        }
      }
      var setHeaders = function setHeaders(headers, _rewrite) {
        return _utils["default"].forEach(headers, function (_value, _header) {
          return setHeader(_value, _header, _rewrite);
        });
      };
      if (_utils["default"].isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (_utils["default"].isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders((0, _parseHeaders["default"])(header), valueOrRewrite);
      } else if (_utils["default"].isHeaders(header)) {
        var _iterator = _createForOfIteratorHelper(header.entries()),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];
            setHeader(value, key, rewrite);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
  }, {
    key: "get",
    value: function get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        var key = _utils["default"].findKey(this, header);
        if (key) {
          var value = this[key];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (_utils["default"].isFunction(parser)) {
            return parser.call(this, value, key);
          }
          if (_utils["default"].isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError('parser must be boolean|regexp|function');
        }
      }
    }
  }, {
    key: "has",
    value: function has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        var key = _utils["default"].findKey(this, header);
        return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
  }, {
    key: "delete",
    value: function _delete(header, matcher) {
      var self = this;
      var deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          var key = _utils["default"].findKey(self, _header);
          if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
            delete self[key];
            deleted = true;
          }
        }
      }
      if (_utils["default"].isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
  }, {
    key: "clear",
    value: function clear(matcher) {
      var keys = Object.keys(this);
      var i = keys.length;
      var deleted = false;
      while (i--) {
        var key = keys[i];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
  }, {
    key: "normalize",
    value: function normalize(format) {
      var self = this;
      var headers = {};
      _utils["default"].forEach(this, function (value, header) {
        var key = _utils["default"].findKey(headers, header);
        if (key) {
          self[key] = normalizeValue(value);
          delete self[header];
          return;
        }
        var normalized = format ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self[header];
        }
        self[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
  }, {
    key: "concat",
    value: function concat() {
      var _this$constructor;
      for (var _len = arguments.length, targets = new Array(_len), _key = 0; _key < _len; _key++) {
        targets[_key] = arguments[_key];
      }
      return (_this$constructor = this.constructor).concat.apply(_this$constructor, [this].concat(targets));
    }
  }, {
    key: "toJSON",
    value: function toJSON(asStrings) {
      var obj = Object.create(null);
      _utils["default"].forEach(this, function (value, header) {
        value != null && value !== false && (obj[header] = asStrings && _utils["default"].isArray(value) ? value.join(', ') : value);
      });
      return obj;
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
  }, {
    key: "toString",
    value: function toString() {
      return Object.entries(this.toJSON()).map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          header = _ref2[0],
          value = _ref2[1];
        return header + ': ' + value;
      }).join('\n');
    }
  }, {
    key: Symbol.toStringTag,
    get: function get() {
      return 'AxiosHeaders';
    }
  }], [{
    key: "from",
    value: function from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
  }, {
    key: "concat",
    value: function concat(first) {
      var computed = new this(first);
      for (var _len2 = arguments.length, targets = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        targets[_key2 - 1] = arguments[_key2];
      }
      targets.forEach(function (target) {
        return computed.set(target);
      });
      return computed;
    }
  }, {
    key: "accessor",
    value: function accessor(header) {
      var internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      var accessors = internals.accessors;
      var prototype = this.prototype;
      function defineAccessor(_header) {
        var lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype, _header);
          accessors[lHeader] = true;
        }
      }
      _utils["default"].isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  }]);
}();
AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
_utils["default"].reduceDescriptors(AxiosHeaders.prototype, function (_ref3, key) {
  var value = _ref3.value;
  var mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: function get() {
      return value;
    },
    set: function set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
_utils["default"].freezeMethods(AxiosHeaders);
var _default = exports["default"] = AxiosHeaders;

},{"../helpers/parseHeaders.js":72,"../utils.js":89}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _utils = _interopRequireDefault(require("./../utils.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var InterceptorManager = /*#__PURE__*/function () {
  function InterceptorManager() {
    _classCallCheck(this, InterceptorManager);
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  return _createClass(InterceptorManager, [{
    key: "use",
    value: function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
  }, {
    key: "eject",
    value: function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    }

    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
  }, {
    key: "clear",
    value: function clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
  }, {
    key: "forEach",
    value: function forEach(fn) {
      _utils["default"].forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    }
  }]);
}();
var _default = exports["default"] = InterceptorManager;

},{"./../utils.js":89}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = buildFullPath;
var _isAbsoluteURL = _interopRequireDefault(require("../helpers/isAbsoluteURL.js"));
var _combineURLs = _interopRequireDefault(require("../helpers/combineURLs.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !(0, _isAbsoluteURL["default"])(requestedURL)) {
    return (0, _combineURLs["default"])(baseURL, requestedURL);
  }
  return requestedURL;
}

},{"../helpers/combineURLs.js":64,"../helpers/isAbsoluteURL.js":68}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = dispatchRequest;
var _transformData = _interopRequireDefault(require("./transformData.js"));
var _isCancel = _interopRequireDefault(require("../cancel/isCancel.js"));
var _index = _interopRequireDefault(require("../defaults/index.js"));
var _CanceledError = _interopRequireDefault(require("../cancel/CanceledError.js"));
var _AxiosHeaders = _interopRequireDefault(require("../core/AxiosHeaders.js"));
var _adapters = _interopRequireDefault(require("../adapters/adapters.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new _CanceledError["default"](null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = _AxiosHeaders["default"].from(config.headers);

  // Transform request data
  config.data = _transformData["default"].call(config, config.transformRequest);
  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }
  var adapter = _adapters["default"].getAdapter(config.adapter || _index["default"].adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = _transformData["default"].call(config, config.transformResponse, response);
    response.headers = _AxiosHeaders["default"].from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!(0, _isCancel["default"])(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = _transformData["default"].call(config, config.transformResponse, reason.response);
        reason.response.headers = _AxiosHeaders["default"].from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

},{"../adapters/adapters.js":41,"../cancel/CanceledError.js":46,"../cancel/isCancel.js":47,"../core/AxiosHeaders.js":50,"../defaults/index.js":57,"./transformData.js":56}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = mergeConfig;
var _utils = _interopRequireDefault(require("../utils.js"));
var _AxiosHeaders = _interopRequireDefault(require("./AxiosHeaders.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var headersToObject = function headersToObject(thing) {
  return thing instanceof _AxiosHeaders["default"] ? _objectSpread({}, thing) : thing;
};

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};
  function getMergedValue(target, source, caseless) {
    if (_utils["default"].isPlainObject(target) && _utils["default"].isPlainObject(source)) {
      return _utils["default"].merge.call({
        caseless: caseless
      }, target, source);
    } else if (_utils["default"].isPlainObject(source)) {
      return _utils["default"].merge({}, source);
    } else if (_utils["default"].isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, caseless) {
    if (!_utils["default"].isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!_utils["default"].isUndefined(a)) {
      return getMergedValue(undefined, a, caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!_utils["default"].isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!_utils["default"].isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!_utils["default"].isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }
  var mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: function headers(a, b) {
      return mergeDeepProperties(headersToObject(a), headersToObject(b), true);
    }
  };
  _utils["default"].forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(config1[prop], config2[prop], prop);
    _utils["default"].isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

},{"../utils.js":89,"./AxiosHeaders.js":50}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = settle;
var _AxiosError = _interopRequireDefault(require("./AxiosError.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new _AxiosError["default"]('Request failed with status code ' + response.status, [_AxiosError["default"].ERR_BAD_REQUEST, _AxiosError["default"].ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
  }
}

},{"./AxiosError.js":49}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = transformData;
var _utils = _interopRequireDefault(require("./../utils.js"));
var _index = _interopRequireDefault(require("../defaults/index.js"));
var _AxiosHeaders = _interopRequireDefault(require("../core/AxiosHeaders.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  var config = this || _index["default"];
  var context = response || config;
  var headers = _AxiosHeaders["default"].from(context.headers);
  var data = context.data;
  _utils["default"].forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });
  headers.normalize();
  return data;
}

},{"../core/AxiosHeaders.js":50,"../defaults/index.js":57,"./../utils.js":89}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _utils = _interopRequireDefault(require("../utils.js"));
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
var _transitional = _interopRequireDefault(require("./transitional.js"));
var _toFormData = _interopRequireDefault(require("../helpers/toFormData.js"));
var _toURLEncodedForm = _interopRequireDefault(require("../helpers/toURLEncodedForm.js"));
var _index = _interopRequireDefault(require("../platform/index.js"));
var _formDataToJSON = _interopRequireDefault(require("../helpers/formDataToJSON.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (_utils["default"].isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return _utils["default"].trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: _transitional["default"],
  adapter: ['xhr', 'http', 'fetch'],
  transformRequest: [function transformRequest(data, headers) {
    var contentType = headers.getContentType() || '';
    var hasJSONContentType = contentType.indexOf('application/json') > -1;
    var isObjectPayload = _utils["default"].isObject(data);
    if (isObjectPayload && _utils["default"].isHTMLForm(data)) {
      data = new FormData(data);
    }
    var isFormData = _utils["default"].isFormData(data);
    if (isFormData) {
      return hasJSONContentType ? JSON.stringify((0, _formDataToJSON["default"])(data)) : data;
    }
    if (_utils["default"].isArrayBuffer(data) || _utils["default"].isBuffer(data) || _utils["default"].isStream(data) || _utils["default"].isFile(data) || _utils["default"].isBlob(data) || _utils["default"].isReadableStream(data)) {
      return data;
    }
    if (_utils["default"].isArrayBufferView(data)) {
      return data.buffer;
    }
    if (_utils["default"].isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }
    var isFileList;
    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return (0, _toURLEncodedForm["default"])(data, this.formSerializer).toString();
      }
      if ((isFileList = _utils["default"].isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        var _FormData = this.env && this.env.FormData;
        return (0, _toFormData["default"])(isFileList ? {
          'files[]': data
        } : data, _FormData && new _FormData(), this.formSerializer);
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var JSONRequested = this.responseType === 'json';
    if (_utils["default"].isResponse(data) || _utils["default"].isReadableStream(data)) {
      return data;
    }
    if (data && _utils["default"].isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      var silentJSONParsing = transitional && transitional.silentJSONParsing;
      var strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw _AxiosError["default"].from(e, _AxiosError["default"].ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: _index["default"].classes.FormData,
    Blob: _index["default"].classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};
_utils["default"].forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], function (method) {
  defaults.headers[method] = {};
});
var _default = exports["default"] = defaults;

},{"../core/AxiosError.js":49,"../helpers/formDataToJSON.js":67,"../helpers/toFormData.js":79,"../helpers/toURLEncodedForm.js":80,"../platform/index.js":88,"../utils.js":89,"./transitional.js":58}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = exports["default"] = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

},{}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VERSION = void 0;
var VERSION = exports.VERSION = "1.7.2";

},{}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _toFormData = _interopRequireDefault(require("./toFormData.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode(str) {
  var charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && (0, _toFormData["default"])(params, this, options);
}
var prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString(encoder) {
  var _encode = encoder ? function (value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};
var _default = exports["default"] = AxiosURLSearchParams;

},{"./toFormData.js":79}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
    key = _ref2[0],
    value = _ref2[1];
  HttpStatusCode[value] = key;
});
var _default = exports["default"] = HttpStatusCode;

},{}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = bind;
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

},{}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = buildURL;
var _utils = _interopRequireDefault(require("../utils.js"));
var _AxiosURLSearchParams = _interopRequireDefault(require("../helpers/AxiosURLSearchParams.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  var _encode = options && options.encode || encode;
  var serializeFn = options && options.serialize;
  var serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = _utils["default"].isURLSearchParams(params) ? params.toString() : new _AxiosURLSearchParams["default"](params, options).toString(_encode);
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }
  return url;
}

},{"../helpers/AxiosURLSearchParams.js":60,"../utils.js":89}],64:[function(require,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = combineURLs;
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
}

},{}],65:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _CanceledError = _interopRequireDefault(require("../cancel/CanceledError.js"));
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
var composeSignals = function composeSignals(signals, timeout) {
  var controller = new AbortController();
  var aborted;
  var onabort = function onabort(cancel) {
    if (!aborted) {
      aborted = true;
      unsubscribe();
      var err = cancel instanceof Error ? cancel : this.reason;
      controller.abort(err instanceof _AxiosError["default"] ? err : new _CanceledError["default"](err instanceof Error ? err.message : err));
    }
  };
  var timer = timeout && setTimeout(function () {
    onabort(new _AxiosError["default"]("timeout ".concat(timeout, " of ms exceeded"), _AxiosError["default"].ETIMEDOUT));
  }, timeout);
  var unsubscribe = function unsubscribe() {
    if (signals) {
      timer && clearTimeout(timer);
      timer = null;
      signals.forEach(function (signal) {
        signal && (signal.removeEventListener ? signal.removeEventListener('abort', onabort) : signal.unsubscribe(onabort));
      });
      signals = null;
    }
  };
  signals.forEach(function (signal) {
    return signal && signal.addEventListener && signal.addEventListener('abort', onabort);
  });
  var signal = controller.signal;
  signal.unsubscribe = unsubscribe;
  return [signal, function () {
    timer && clearTimeout(timer);
    timer = null;
  }];
};
var _default = exports["default"] = composeSignals;

},{"../cancel/CanceledError.js":46,"../core/AxiosError.js":49}],66:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _utils = _interopRequireDefault(require("./../utils.js"));
var _index = _interopRequireDefault(require("../platform/index.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
var _default = exports["default"] = _index["default"].hasStandardBrowserEnv ?
// Standard browser envs support document.cookie
{
  write: function write(name, value, expires, path, domain, secure) {
    var cookie = [name + '=' + encodeURIComponent(value)];
    _utils["default"].isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());
    _utils["default"].isString(path) && cookie.push('path=' + path);
    _utils["default"].isString(domain) && cookie.push('domain=' + domain);
    secure === true && cookie.push('secure');
    document.cookie = cookie.join('; ');
  },
  read: function read(name) {
    var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
    return match ? decodeURIComponent(match[3]) : null;
  },
  remove: function remove(name) {
    this.write(name, '', Date.now() - 86400000);
  }
} :
// Non-standard browser env (web workers, react-native) lack needed support.
{
  write: function write() {},
  read: function read() {
    return null;
  },
  remove: function remove() {}
};

},{"../platform/index.js":88,"./../utils.js":89}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _utils = _interopRequireDefault(require("../utils.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return _utils["default"].matchAll(/\w+|\[(\w*)]/g, name).map(function (match) {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  var obj = {};
  var keys = Object.keys(arr);
  var i;
  var len = keys.length;
  var key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    var name = path[index++];
    if (name === '__proto__') return true;
    var isNumericKey = Number.isFinite(+name);
    var isLast = index >= path.length;
    name = !name && _utils["default"].isArray(target) ? target.length : name;
    if (isLast) {
      if (_utils["default"].hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !_utils["default"].isObject(target[name])) {
      target[name] = [];
    }
    var result = buildPath(path, value, target[name], index);
    if (result && _utils["default"].isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (_utils["default"].isFormData(formData) && _utils["default"].isFunction(formData.entries)) {
    var obj = {};
    _utils["default"].forEachEntry(formData, function (name, value) {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var _default = exports["default"] = formDataToJSON;

},{"../utils.js":89}],68:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isAbsoluteURL;
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

},{}],69:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isAxiosError;
var _utils = _interopRequireDefault(require("./../utils.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return _utils["default"].isObject(payload) && payload.isAxiosError === true;
}

},{"./../utils.js":89}],70:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _utils = _interopRequireDefault(require("./../utils.js"));
var _index = _interopRequireDefault(require("../platform/index.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
var _default = exports["default"] = _index["default"].hasStandardBrowserEnv ?
// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;

  /**
  * Parse a URL to discover its components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */
  function resolveURL(url) {
    var href = url;
    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute('href', href);

    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);

  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */
  return function isURLSameOrigin(requestURL) {
    var parsed = _utils["default"].isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() :
// Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

},{"../platform/index.js":88,"./../utils.js":89}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
// eslint-disable-next-line strict
var _default = exports["default"] = null;

},{}],72:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _utils = _interopRequireDefault(require("./../utils.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = _utils["default"].toObjectSet(['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
var _default = exports["default"] = function _default(rawHeaders) {
  var parsed = {};
  var key;
  var val;
  var i;
  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });
  return parsed;
};

},{"./../utils.js":89}],73:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = parseProtocol;
function parseProtocol(url) {
  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

},{}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _speedometer2 = _interopRequireDefault(require("./speedometer.js"));
var _throttle = _interopRequireDefault(require("./throttle.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
var _default = exports["default"] = function _default(listener, isDownloadStream) {
  var freq = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
  var bytesNotified = 0;
  var _speedometer = (0, _speedometer2["default"])(50, 250);
  return (0, _throttle["default"])(function (e) {
    var loaded = e.loaded;
    var total = e.lengthComputable ? e.total : undefined;
    var progressBytes = loaded - bytesNotified;
    var rate = _speedometer(progressBytes);
    var inRange = loaded <= total;
    bytesNotified = loaded;
    var data = {
      loaded: loaded,
      total: total,
      progress: total ? loaded / total : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null
    };
    data[isDownloadStream ? 'download' : 'upload'] = true;
    listener(data);
  }, freq);
};

},{"./speedometer.js":76,"./throttle.js":78}],75:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _index = _interopRequireDefault(require("../platform/index.js"));
var _utils = _interopRequireDefault(require("../utils.js"));
var _isURLSameOrigin = _interopRequireDefault(require("./isURLSameOrigin.js"));
var _cookies = _interopRequireDefault(require("./cookies.js"));
var _buildFullPath = _interopRequireDefault(require("../core/buildFullPath.js"));
var _mergeConfig = _interopRequireDefault(require("../core/mergeConfig.js"));
var _AxiosHeaders = _interopRequireDefault(require("../core/AxiosHeaders.js"));
var _buildURL = _interopRequireDefault(require("./buildURL.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var _default = exports["default"] = function _default(config) {
  var newConfig = (0, _mergeConfig["default"])({}, config);
  var data = newConfig.data,
    withXSRFToken = newConfig.withXSRFToken,
    xsrfHeaderName = newConfig.xsrfHeaderName,
    xsrfCookieName = newConfig.xsrfCookieName,
    headers = newConfig.headers,
    auth = newConfig.auth;
  newConfig.headers = headers = _AxiosHeaders["default"].from(headers);
  newConfig.url = (0, _buildURL["default"])((0, _buildFullPath["default"])(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' + btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : '')));
  }
  var contentType;
  if (_utils["default"].isFormData(data)) {
    if (_index["default"].hasStandardBrowserEnv || _index["default"].hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      var _ref = contentType ? contentType.split(';').map(function (token) {
          return token.trim();
        }).filter(Boolean) : [],
        _ref2 = _toArray(_ref),
        type = _ref2[0],
        tokens = _ref2.slice(1);
      headers.setContentType([type || 'multipart/form-data'].concat(_toConsumableArray(tokens)).join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (_index["default"].hasStandardBrowserEnv) {
    withXSRFToken && _utils["default"].isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && (0, _isURLSameOrigin["default"])(newConfig.url)) {
      // Add xsrf header
      var xsrfValue = xsrfHeaderName && xsrfCookieName && _cookies["default"].read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

},{"../core/AxiosHeaders.js":50,"../core/buildFullPath.js":52,"../core/mergeConfig.js":54,"../platform/index.js":88,"../utils.js":89,"./buildURL.js":63,"./cookies.js":66,"./isURLSameOrigin.js":70}],76:[function(require,module,exports){
'use strict';

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  var bytes = new Array(samplesCount);
  var timestamps = new Array(samplesCount);
  var head = 0;
  var tail = 0;
  var firstSampleTS;
  min = min !== undefined ? min : 1000;
  return function push(chunkLength) {
    var now = Date.now();
    var startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    var i = tail;
    var bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    var passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}
var _default = exports["default"] = speedometer;

},{}],77:[function(require,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = spread;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

},{}],78:[function(require,module,exports){
'use strict';

/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
function throttle(fn, freq) {
  var timestamp = 0;
  var threshold = 1000 / freq;
  var timer = null;
  return function throttled() {
    var _arguments = arguments;
    var force = this === true;
    var now = Date.now();
    if (force || now - timestamp > threshold) {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      timestamp = now;
      return fn.apply(null, arguments);
    }
    if (!timer) {
      timer = setTimeout(function () {
        timer = null;
        timestamp = Date.now();
        return fn.apply(null, _arguments);
      }, threshold - (now - timestamp));
    }
  };
}
var _default = exports["default"] = throttle;

},{}],79:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _utils = _interopRequireDefault(require("../utils.js"));
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
var _FormData = _interopRequireDefault(require("../platform/node/classes/FormData.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); } // temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored
/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return _utils["default"].isPlainObject(thing) || _utils["default"].isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return _utils["default"].endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return _utils["default"].isArray(arr) && !arr.some(isVisitable);
}
var predicates = _utils["default"].toFlatObject(_utils["default"], {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!_utils["default"].isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (_FormData["default"] || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = _utils["default"].toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !_utils["default"].isUndefined(source[option]);
  });
  var metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  var visitor = options.visitor || defaultVisitor;
  var dots = options.dots;
  var indexes = options.indexes;
  var _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  var useBlob = _Blob && _utils["default"].isSpecCompliantForm(formData);
  if (!_utils["default"].isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }
  function convertValue(value) {
    if (value === null) return '';
    if (_utils["default"].isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && _utils["default"].isBlob(value)) {
      throw new _AxiosError["default"]('Blob is not supported. Use a Buffer instead.');
    }
    if (_utils["default"].isArrayBuffer(value) || _utils["default"].isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    var arr = value;
    if (value && !path && _typeof(value) === 'object') {
      if (_utils["default"].endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (_utils["default"].isArray(value) && isFlatArray(value) || (_utils["default"].isFileList(value) || _utils["default"].endsWith(key, '[]')) && (arr = _utils["default"].toArray(value))) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(_utils["default"].isUndefined(el) || el === null) && formData.append(
          // eslint-disable-next-line no-nested-ternary
          indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + '[]', convertValue(el));
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  var stack = [];
  var exposedHelpers = Object.assign(predicates, {
    defaultVisitor: defaultVisitor,
    convertValue: convertValue,
    isVisitable: isVisitable
  });
  function build(value, path) {
    if (_utils["default"].isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }
    stack.push(value);
    _utils["default"].forEach(value, function each(el, key) {
      var result = !(_utils["default"].isUndefined(el) || el === null) && visitor.call(formData, el, _utils["default"].isString(key) ? key.trim() : key, path, exposedHelpers);
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!_utils["default"].isObject(obj)) {
    throw new TypeError('data must be an object');
  }
  build(obj);
  return formData;
}
var _default = exports["default"] = toFormData;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../core/AxiosError.js":49,"../platform/node/classes/FormData.js":71,"../utils.js":89,"buffer":90}],80:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = toURLEncodedForm;
var _utils = _interopRequireDefault(require("../utils.js"));
var _toFormData = _interopRequireDefault(require("./toFormData.js"));
var _index = _interopRequireDefault(require("../platform/index.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function toURLEncodedForm(data, options) {
  return (0, _toFormData["default"])(data, new _index["default"].classes.URLSearchParams(), Object.assign({
    visitor: function visitor(value, key, path, helpers) {
      if (_index["default"].isNode && _utils["default"].isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

},{"../platform/index.js":88,"../utils.js":89,"./toFormData.js":79}],81:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.trackStream = exports.streamChunk = exports.readBytes = void 0;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e["return"] && (this["return"] = void 0); }
AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype["throw"] = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype["return"] = function (e) { return this._invoke("return", e); };
function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
function _asyncGeneratorDelegate(t) { var e = {}, n = !1; function pump(e, r) { return n = !0, r = new Promise(function (n) { n(t[e](r)); }), { done: !1, value: new _OverloadYield(r, 1) }; } return e["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function () { return this; }, e.next = function (t) { return n ? (n = !1, t) : pump("next", t); }, "function" == typeof t["throw"] && (e["throw"] = function (t) { if (n) throw n = !1, t; return pump("throw", t); }), "function" == typeof t["return"] && (e["return"] = function (t) { return n ? (n = !1, t) : pump("return", t); }), e; }
function _OverloadYield(e, d) { this.v = e, this.k = d; }
function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, "return": function _return(r) { var n = this.s["return"]; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, "throw": function _throw(r) { var n = this.s["return"]; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); }
var streamChunk = exports.streamChunk = /*#__PURE__*/_regeneratorRuntime().mark(function streamChunk(chunk, chunkSize) {
  var len, pos, end;
  return _regeneratorRuntime().wrap(function streamChunk$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        len = chunk.byteLength;
        if (!(!chunkSize || len < chunkSize)) {
          _context.next = 5;
          break;
        }
        _context.next = 4;
        return chunk;
      case 4:
        return _context.abrupt("return");
      case 5:
        pos = 0;
      case 6:
        if (!(pos < len)) {
          _context.next = 13;
          break;
        }
        end = pos + chunkSize;
        _context.next = 10;
        return chunk.slice(pos, end);
      case 10:
        pos = end;
        _context.next = 6;
        break;
      case 13:
      case "end":
        return _context.stop();
    }
  }, streamChunk);
});
var readBytes = exports.readBytes = /*#__PURE__*/function () {
  var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(iterable, chunkSize, encode) {
    var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;
    return _regeneratorRuntime().wrap(function _callee$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _iteratorAbruptCompletion = false;
          _didIteratorError = false;
          _context2.prev = 2;
          _iterator = _asyncIterator(iterable);
        case 4:
          _context2.next = 6;
          return _awaitAsyncGenerator(_iterator.next());
        case 6:
          if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {
            _context2.next = 27;
            break;
          }
          chunk = _step.value;
          _context2.t0 = _asyncGeneratorDelegate;
          _context2.t1 = _asyncIterator;
          _context2.t2 = streamChunk;
          if (!ArrayBuffer.isView(chunk)) {
            _context2.next = 15;
            break;
          }
          _context2.t3 = chunk;
          _context2.next = 18;
          break;
        case 15:
          _context2.next = 17;
          return _awaitAsyncGenerator(encode(String(chunk)));
        case 17:
          _context2.t3 = _context2.sent;
        case 18:
          _context2.t4 = _context2.t3;
          _context2.t5 = chunkSize;
          _context2.t6 = (0, _context2.t2)(_context2.t4, _context2.t5);
          _context2.t7 = (0, _context2.t1)(_context2.t6);
          _context2.t8 = _awaitAsyncGenerator;
          return _context2.delegateYield((0, _context2.t0)(_context2.t7, _context2.t8), "t9", 24);
        case 24:
          _iteratorAbruptCompletion = false;
          _context2.next = 4;
          break;
        case 27:
          _context2.next = 33;
          break;
        case 29:
          _context2.prev = 29;
          _context2.t10 = _context2["catch"](2);
          _didIteratorError = true;
          _iteratorError = _context2.t10;
        case 33:
          _context2.prev = 33;
          _context2.prev = 34;
          if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
            _context2.next = 38;
            break;
          }
          _context2.next = 38;
          return _awaitAsyncGenerator(_iterator["return"]());
        case 38:
          _context2.prev = 38;
          if (!_didIteratorError) {
            _context2.next = 41;
            break;
          }
          throw _iteratorError;
        case 41:
          return _context2.finish(38);
        case 42:
          return _context2.finish(33);
        case 43:
        case "end":
          return _context2.stop();
      }
    }, _callee, null, [[2, 29, 33, 43], [34,, 38, 42]]);
  }));
  return function readBytes(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();
var trackStream = exports.trackStream = function trackStream(stream, chunkSize, onProgress, onFinish, encode) {
  var iterator = readBytes(stream, chunkSize, encode);
  var bytes = 0;
  return new ReadableStream({
    type: 'bytes',
    pull: function pull(controller) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var _yield$iterator$next, done, value, len;
        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return iterator.next();
            case 2:
              _yield$iterator$next = _context3.sent;
              done = _yield$iterator$next.done;
              value = _yield$iterator$next.value;
              if (!done) {
                _context3.next = 9;
                break;
              }
              controller.close();
              onFinish();
              return _context3.abrupt("return");
            case 9:
              len = value.byteLength;
              onProgress && onProgress(bytes += len);
              controller.enqueue(new Uint8Array(value));
            case 12:
            case "end":
              return _context3.stop();
          }
        }, _callee2);
      }))();
    },
    cancel: function cancel(reason) {
      onFinish(reason);
      return iterator["return"]();
    }
  }, {
    highWaterMark: 2
  });
};

},{}],82:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _data = require("../env/data.js");
var _AxiosError = _interopRequireDefault(require("../core/AxiosError.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (type, i) {
  validators[type] = function validator(thing) {
    return _typeof(thing) === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});
var deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + _data.VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function (value, opt, opts) {
    if (validator === false) {
      throw new _AxiosError["default"](formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), _AxiosError["default"].ERR_DEPRECATED);
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
    }
    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (_typeof(options) !== 'object') {
    throw new _AxiosError["default"]('options must be an object', _AxiosError["default"].ERR_BAD_OPTION_VALUE);
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new _AxiosError["default"]('option ' + opt + ' must be ' + result, _AxiosError["default"].ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new _AxiosError["default"]('Unknown option ' + opt, _AxiosError["default"].ERR_BAD_OPTION);
    }
  }
}
var _default = exports["default"] = {
  assertOptions: assertOptions,
  validators: validators
};

},{"../core/AxiosError.js":49,"../env/data.js":59}],83:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = exports["default"] = typeof Blob !== 'undefined' ? Blob : null;

},{}],84:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _default = exports["default"] = typeof FormData !== 'undefined' ? FormData : null;

},{}],85:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _AxiosURLSearchParams = _interopRequireDefault(require("../../../helpers/AxiosURLSearchParams.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
var _default = exports["default"] = typeof URLSearchParams !== 'undefined' ? URLSearchParams : _AxiosURLSearchParams["default"];

},{"../../../helpers/AxiosURLSearchParams.js":60}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _URLSearchParams = _interopRequireDefault(require("./classes/URLSearchParams.js"));
var _FormData = _interopRequireDefault(require("./classes/FormData.js"));
var _Blob = _interopRequireDefault(require("./classes/Blob.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
var _default = exports["default"] = {
  isBrowser: true,
  classes: {
    URLSearchParams: _URLSearchParams["default"],
    FormData: _FormData["default"],
    Blob: _Blob["default"]
  },
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
};

},{"./classes/Blob.js":83,"./classes/FormData.js":84,"./classes/URLSearchParams.js":85}],87:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.origin = exports.hasStandardBrowserWebWorkerEnv = exports.hasStandardBrowserEnv = exports.hasBrowserEnv = void 0;
var hasBrowserEnv = exports.hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
var hasStandardBrowserEnv = exports.hasStandardBrowserEnv = function (product) {
  return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0;
}(typeof navigator !== 'undefined' && navigator.product);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
var hasStandardBrowserWebWorkerEnv = exports.hasStandardBrowserWebWorkerEnv = function () {
  return typeof WorkerGlobalScope !== 'undefined' &&
  // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === 'function';
}();
var origin = exports.origin = hasBrowserEnv && window.location.href || 'http://localhost';

},{}],88:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _index = _interopRequireDefault(require("./node/index.js"));
var utils = _interopRequireWildcard(require("./common/utils.js"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n["default"] = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var _default = exports["default"] = _objectSpread(_objectSpread({}, utils), _index["default"]);

},{"./common/utils.js":87,"./node/index.js":86}],89:[function(require,module,exports){
(function (global){(function (){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _bind = _interopRequireDefault(require("./helpers/bind.js"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { "default": e }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;
var getPrototypeOf = Object.getPrototypeOf;
var kindOf = function (cache) {
  return function (thing) {
    var str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
}(Object.create(null));
var kindOfTest = function kindOfTest(type) {
  type = type.toLowerCase();
  return function (thing) {
    return kindOf(thing) === type;
  };
};
var typeOfTest = function typeOfTest(type) {
  return function (thing) {
    return _typeof(thing) === type;
  };
};

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
var isArray = Array.isArray;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
var isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
var isArrayBuffer = kindOfTest('ArrayBuffer');

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
var isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
var isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
var isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
var isObject = function isObject(thing) {
  return thing !== null && _typeof(thing) === 'object';
};

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
var isBoolean = function isBoolean(thing) {
  return thing === true || thing === false;
};

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
var isPlainObject = function isPlainObject(val) {
  if (kindOf(val) !== 'object') {
    return false;
  }
  var prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
var isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
var isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
var isStream = function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
};

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
var isFormData = function isFormData(thing) {
  var kind;
  return thing && (typeof FormData === 'function' && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === 'formdata' ||
  // detect form-data instance
  kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]'));
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
var isURLSearchParams = kindOfTest('URLSearchParams');
var _map = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest),
  _map2 = _slicedToArray(_map, 4),
  isReadableStream = _map2[0],
  isRequest = _map2[1],
  isResponse = _map2[2],
  isHeaders = _map2[3];

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
var trim = function trim(str) {
  return str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
};

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    _ref$allOwnKeys = _ref.allOwnKeys,
    allOwnKeys = _ref$allOwnKeys === void 0 ? false : _ref$allOwnKeys;
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }
  var i;
  var l;

  // Force an array if not already something iterable
  if (_typeof(obj) !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }
  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    var keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    var len = keys.length;
    var key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  var keys = Object.keys(obj);
  var i = keys.length;
  var _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = function () {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== 'undefined' ? window : global;
}();
var isContextDefined = function isContextDefined(context) {
  return !isUndefined(context) && context !== _global;
};

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge( /* obj1, obj2, obj3, ... */
) {
  var _ref2 = isContextDefined(this) && this || {},
    caseless = _ref2.caseless;
  var result = {};
  var assignValue = function assignValue(val, key) {
    var targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (var i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
var extend = function extend(a, b, thisArg) {
  var _ref3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
    allOwnKeys = _ref3.allOwnKeys;
  forEach(b, function (val, key) {
    if (thisArg && isFunction(val)) {
      a[key] = (0, _bind["default"])(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {
    allOwnKeys: allOwnKeys
  });
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
var stripBOM = function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
var inherits = function inherits(constructor, superConstructor, props, descriptors) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
var toFlatObject = function toFlatObject(sourceObj, destObj, filter, propFilter) {
  var props;
  var i;
  var prop;
  var merged = {};
  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
var endsWith = function endsWith(str, searchString, position) {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};

/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
var toArray = function toArray(thing) {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  var i = thing.length;
  if (!isNumber(i)) return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
var isTypedArray = function (TypedArray) {
  // eslint-disable-next-line func-names
  return function (thing) {
    return TypedArray && thing instanceof TypedArray;
  };
}(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
var forEachEntry = function forEachEntry(obj, fn) {
  var generator = obj && obj[Symbol.iterator];
  var iterator = generator.call(obj);
  var result;
  while ((result = iterator.next()) && !result.done) {
    var pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
var matchAll = function matchAll(regExp, str) {
  var matches;
  var arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
var isHTMLForm = kindOfTest('HTMLFormElement');
var toCamelCase = function toCamelCase(str) {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
    return p1.toUpperCase() + p2;
  });
};

/* Creating a function that will check if an object has a property. */
var hasOwnProperty = function (_ref4) {
  var hasOwnProperty = _ref4.hasOwnProperty;
  return function (obj, prop) {
    return hasOwnProperty.call(obj, prop);
  };
}(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
var isRegExp = kindOfTest('RegExp');
var reduceDescriptors = function reduceDescriptors(obj, reducer) {
  var descriptors = Object.getOwnPropertyDescriptors(obj);
  var reducedDescriptors = {};
  forEach(descriptors, function (descriptor, name) {
    var ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

var freezeMethods = function freezeMethods(obj) {
  reduceDescriptors(obj, function (descriptor, name) {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }
    var value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = function () {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};
var toObjectSet = function toObjectSet(arrayOrString, delimiter) {
  var obj = {};
  var define = function define(arr) {
    arr.forEach(function (value) {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = function noop() {};
var toFiniteNumber = function toFiniteNumber(value, defaultValue) {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
var ALPHA = 'abcdefghijklmnopqrstuvwxyz';
var DIGIT = '0123456789';
var ALPHABET = {
  DIGIT: DIGIT,
  ALPHA: ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = function generateString() {
  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
  var alphabet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ALPHABET.ALPHA_DIGIT;
  var str = '';
  var length = alphabet.length;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
}
var toJSONObject = function toJSONObject(obj) {
  var stack = new Array(10);
  var visit = function visit(source, i) {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!('toJSON' in source)) {
        stack[i] = source;
        var target = isArray(source) ? [] : {};
        forEach(source, function (value, key) {
          var reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = undefined;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest('AsyncFunction');
var isThenable = function isThenable(thing) {
  return thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing["catch"]);
};
var _default = exports["default"] = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isBoolean: isBoolean,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isReadableStream: isReadableStream,
  isRequest: isRequest,
  isResponse: isResponse,
  isHeaders: isHeaders,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isRegExp: isRegExp,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isTypedArray: isTypedArray,
  isFileList: isFileList,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM,
  inherits: inherits,
  toFlatObject: toFlatObject,
  kindOf: kindOf,
  kindOfTest: kindOfTest,
  endsWith: endsWith,
  toArray: toArray,
  forEachEntry: forEachEntry,
  matchAll: matchAll,
  isHTMLForm: isHTMLForm,
  hasOwnProperty: hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: reduceDescriptors,
  freezeMethods: freezeMethods,
  toObjectSet: toObjectSet,
  toCamelCase: toCamelCase,
  noop: noop,
  toFiniteNumber: toFiniteNumber,
  findKey: findKey,
  global: _global,
  isContextDefined: isContextDefined,
  ALPHABET: ALPHABET,
  generateString: generateString,
  isSpecCompliantForm: isSpecCompliantForm,
  toJSONObject: toJSONObject,
  isAsyncFn: isAsyncFn,
  isThenable: isThenable
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./helpers/bind.js":62}],90:[function(require,module,exports){
"use strict";

},{}],91:[function(require,module,exports){
"use strict";

/**
 * cuid.js
 * Collision-resistant UID generator for browsers and node.
 * Sequential for fast db lookups and recency sorting.
 * Safe for element IDs and server-side lookups.
 *
 * Extracted from CLCTR
 *
 * Copyright (c) Eric Elliott 2012
 * MIT License
 */

var fingerprint = require('./lib/fingerprint.js');
var pad = require('./lib/pad.js');
var getRandomValue = require('./lib/getRandomValue.js');
var c = 0,
  blockSize = 4,
  base = 36,
  discreteValues = Math.pow(base, blockSize);
function randomBlock() {
  return pad((getRandomValue() * discreteValues << 0).toString(base), blockSize);
}
function safeCounter() {
  c = c < discreteValues ? c : 0;
  c++; // this is not subliminal
  return c - 1;
}
function cuid() {
  // Starting with a lowercase letter makes
  // it HTML element ID friendly.
  var letter = 'c',
    // hard-coded allows for sequential access

    // timestamp
    // warning: this exposes the exact date and time
    // that the uid was created.
    timestamp = new Date().getTime().toString(base),
    // Prevent same-machine collisions.
    counter = pad(safeCounter().toString(base), blockSize),
    // A few chars to generate distinct ids for different
    // clients (so different computers are far less
    // likely to generate the same id)
    print = fingerprint(),
    // Grab some more chars from Math.random()
    random = randomBlock() + randomBlock();
  return letter + timestamp + counter + print + random;
}
cuid.slug = function slug() {
  var date = new Date().getTime().toString(36),
    counter = safeCounter().toString(36).slice(-4),
    print = fingerprint().slice(0, 1) + fingerprint().slice(-1),
    random = randomBlock().slice(-2);
  return date.slice(-2) + counter + print + random;
};
cuid.isCuid = function isCuid(stringToCheck) {
  if (typeof stringToCheck !== 'string') return false;
  if (stringToCheck.startsWith('c')) return true;
  return false;
};
cuid.isSlug = function isSlug(stringToCheck) {
  if (typeof stringToCheck !== 'string') return false;
  var stringLength = stringToCheck.length;
  if (stringLength >= 7 && stringLength <= 10) return true;
  return false;
};
cuid.fingerprint = fingerprint;
module.exports = cuid;

},{"./lib/fingerprint.js":92,"./lib/getRandomValue.js":93,"./lib/pad.js":94}],92:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var pad = require('./pad.js');
var env = (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' ? window : self;
var globalCount = Object.keys(env).length;
var mimeTypesLength = navigator.mimeTypes ? navigator.mimeTypes.length : 0;
var clientId = pad((mimeTypesLength + navigator.userAgent.length).toString(36) + globalCount.toString(36), 4);
module.exports = function fingerprint() {
  return clientId;
};

},{"./pad.js":94}],93:[function(require,module,exports){
"use strict";

var getRandomValue;
var crypto = typeof window !== 'undefined' && (window.crypto || window.msCrypto) || typeof self !== 'undefined' && self.crypto;
if (crypto) {
  var lim = Math.pow(2, 32) - 1;
  getRandomValue = function getRandomValue() {
    return Math.abs(crypto.getRandomValues(new Uint32Array(1))[0] / lim);
  };
} else {
  getRandomValue = Math.random;
}
module.exports = getRandomValue;

},{}],94:[function(require,module,exports){
"use strict";

module.exports = function pad(num, size) {
  var s = '000000000' + num;
  return s.substr(s.length - size);
};

},{}],95:[function(require,module,exports){
(function (process){(function (){
"use strict";

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();

/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  }

  // Internet Explorer and Edge do not support colors.
  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  }

  // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
  // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
  // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 ||
  // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
  if (!this.useColors) {
    return;
  }
  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit');

  // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }
    index++;
    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || function () {};

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
  var r;
  try {
    r = exports.storage.getItem('debug');
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }
  return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
module.exports = require('./common')(exports);
var formatters = module.exports.formatters;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

}).call(this)}).call(this,require('_process'))
},{"./common":96,"_process":155}],96:[function(require,module,exports){
"use strict";

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
  createDebug.debug = createDebug;
  createDebug["default"] = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });

  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];

  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */
  createDebug.formatters = {};

  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */
  function selectColor(namespace) {
    var hash = 0;
    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;

  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */
  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;
    var namespacesCache;
    var enabledCache;
    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      // Disabled?
      if (!debug.enabled) {
        return;
      }
      var self = debug;

      // Set `diff` timestamp
      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      }

      // Apply any `formatters` transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }
        index++;
        var formatter = createDebug.formatters[format];
        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val);

          // Now we need to remove `args[index]` since it's inlined in the `format`
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      // Apply env-specific formatting (colors, etc.)
      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }
    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function get() {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: function set(v) {
        enableOverride = v;
      }
    });

    // Env-specific initialization logic for debug instances
    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }
    return debug;
  }
  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }

  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;
    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }
      namespaces = split[i].replace(/\*/g, '.*?');
      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }

  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */
  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }

  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */
  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }
    var i;
    var len;
    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }

  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }

  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }

  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */
  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
module.exports = setup;

},{"ms":154}],97:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasCORS = void 0;
// imported from https://github.com/component/has-cors
var value = false;
try {
  value = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
}
exports.hasCORS = value;

},{}],98:[function(require,module,exports){
"use strict";

// imported from https://github.com/galkn/querystring
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decode = exports.encode = void 0;
function encode(obj) {
  var str = '';
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }
  return str;
}
exports.encode = encode;
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */
function decode(qs) {
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}
exports.decode = decode;

},{}],99:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = void 0;
// imported from https://github.com/galkn/parseuri
/**
 * Parses a URI
 *
 * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
 *
 * See:
 * - https://developer.mozilla.org/en-US/docs/Web/API/URL
 * - https://caniuse.com/url
 * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
 *
 * History of the parse() method:
 * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
 * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
 * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */
var re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
function parse(str) {
  if (str.length > 2000) {
    throw "URI too long";
  }
  var src = str,
    b = str.indexOf('['),
    e = str.indexOf(']');
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
  }
  var m = re.exec(str || ''),
    uri = {},
    i = 14;
  while (i--) {
    uri[parts[i]] = m[i] || '';
  }
  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
    uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri['path']);
  uri.queryKey = queryKey(uri, uri['query']);
  return uri;
}
exports.parse = parse;
function pathNames(obj, path) {
  var regx = /\/{2,9}/g,
    names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == '/' || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == '/') {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  var data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}

},{}],100:[function(require,module,exports){
// imported from https://github.com/unshiftio/yeast
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.yeast = exports.decode = exports.encode = void 0;
var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
  length = 64,
  map = {};
var seed = 0,
  i = 0,
  prev;
/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';
  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);
  return encoded;
}
exports.encode = encode;
/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;
  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }
  return decoded;
}
exports.decode = decode;
/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());
  if (now !== prev) return seed = 0, prev = now;
  return now + '.' + encode(seed++);
}
exports.yeast = yeast;
//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

},{}],101:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.globalThisShim = void 0;
exports.globalThisShim = function () {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
}();

},{}],102:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nextTick = exports.parse = exports.installTimerFunctions = exports.transports = exports.TransportError = exports.Transport = exports.protocol = exports.Socket = void 0;
var socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", {
  enumerable: true,
  get: function get() {
    return socket_js_1.Socket;
  }
});
exports.protocol = socket_js_1.Socket.protocol;
var transport_js_1 = require("./transport.js");
Object.defineProperty(exports, "Transport", {
  enumerable: true,
  get: function get() {
    return transport_js_1.Transport;
  }
});
Object.defineProperty(exports, "TransportError", {
  enumerable: true,
  get: function get() {
    return transport_js_1.TransportError;
  }
});
var index_js_1 = require("./transports/index.js");
Object.defineProperty(exports, "transports", {
  enumerable: true,
  get: function get() {
    return index_js_1.transports;
  }
});
var util_js_1 = require("./util.js");
Object.defineProperty(exports, "installTimerFunctions", {
  enumerable: true,
  get: function get() {
    return util_js_1.installTimerFunctions;
  }
});
var parseuri_js_1 = require("./contrib/parseuri.js");
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function get() {
    return parseuri_js_1.parse;
  }
});
var websocket_constructor_js_1 = require("./transports/websocket-constructor.js");
Object.defineProperty(exports, "nextTick", {
  enumerable: true,
  get: function get() {
    return websocket_constructor_js_1.nextTick;
  }
});

},{"./contrib/parseuri.js":99,"./socket.js":103,"./transport.js":104,"./transports/index.js":105,"./transports/websocket-constructor.js":107,"./util.js":111}],103:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Socket = void 0;
var index_js_1 = require("./transports/index.js");
var util_js_1 = require("./util.js");
var parseqs_js_1 = require("./contrib/parseqs.js");
var parseuri_js_1 = require("./contrib/parseuri.js");
var debug_1 = __importDefault(require("debug")); // debug()
var component_emitter_1 = require("@socket.io/component-emitter");
var engine_io_parser_1 = require("engine.io-parser");
var websocket_constructor_js_1 = require("./transports/websocket-constructor.js");
var debug = (0, debug_1["default"])("engine.io-client:socket"); // debug()
var Socket = /*#__PURE__*/function (_component_emitter_1$) {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  function Socket(uri) {
    var _this;
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Socket);
    _this = _callSuper(this, Socket);
    _this.binaryType = websocket_constructor_js_1.defaultBinaryType;
    _this.writeBuffer = [];
    if (uri && "object" === _typeof(uri)) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      uri = (0, parseuri_js_1.parse)(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query) opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;
    }
    (0, util_js_1.installTimerFunctions)(_this, opts);
    _this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = _this.secure ? "443" : "80";
    }
    _this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    _this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : _this.secure ? "443" : "80");
    _this.transports = opts.transports || ["polling", "websocket", "webtransport"];
    _this.writeBuffer = [];
    _this.prevBufferLen = 0;
    _this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    _this.opts.path = _this.opts.path.replace(/\/$/, "") + (_this.opts.addTrailingSlash ? "/" : "");
    if (typeof _this.opts.query === "string") {
      _this.opts.query = (0, parseqs_js_1.decode)(_this.opts.query);
    }
    // set on handshake
    _this.id = null;
    _this.upgrades = null;
    _this.pingInterval = null;
    _this.pingTimeout = null;
    // set on heartbeat
    _this.pingTimeoutTimer = null;
    if (typeof addEventListener === "function") {
      if (_this.opts.closeOnBeforeunload) {
        // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
        // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
        // closed/reloaded)
        _this.beforeunloadEventListener = function () {
          if (_this.transport) {
            // silently close the transport
            _this.transport.removeAllListeners();
            _this.transport.close();
          }
        };
        addEventListener("beforeunload", _this.beforeunloadEventListener, false);
      }
      if (_this.hostname !== "localhost") {
        _this.offlineEventListener = function () {
          _this.onClose("transport close", {
            description: "network connection lost"
          });
        };
        addEventListener("offline", _this.offlineEventListener, false);
      }
    }
    _this.open();
    return _this;
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  _inherits(Socket, _component_emitter_1$);
  return _createClass(Socket, [{
    key: "createTransport",
    value: function createTransport(name) {
      debug('creating transport "%s"', name);
      var query = Object.assign({}, this.opts.query);
      // append engine.io protocol identifier
      query.EIO = engine_io_parser_1.protocol;
      // transport name
      query.transport = name;
      // session id if we already have one
      if (this.id) query.sid = this.id;
      var opts = Object.assign({}, this.opts, {
        query: query,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      }, this.opts.transportOptions[name]);
      debug("options: %j", opts);
      return new index_js_1.transports[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */
  }, {
    key: "open",
    value: function open() {
      var _this2 = this;
      var transport;
      if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
        transport = "websocket";
      } else if (0 === this.transports.length) {
        // Emit error on next tick so it can be listened to
        this.setTimeoutFn(function () {
          _this2.emitReserved("error", "No transports available");
        }, 0);
        return;
      } else {
        transport = this.transports[0];
      }
      this.readyState = "opening";
      // Retry with the next transport if the transport is disabled (jsonp: false)
      try {
        transport = this.createTransport(transport);
      } catch (e) {
        debug("error while creating transport: %s", e);
        this.transports.shift();
        this.open();
        return;
      }
      transport.open();
      this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */
  }, {
    key: "setTransport",
    value: function setTransport(transport) {
      var _this3 = this;
      debug("setting transport %s", transport.name);
      if (this.transport) {
        debug("clearing existing transport %s", this.transport.name);
        this.transport.removeAllListeners();
      }
      // set up transport
      this.transport = transport;
      // set up transport listeners
      transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", function (reason) {
        return _this3.onClose("transport close", reason);
      });
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
  }, {
    key: "probe",
    value: function probe(name) {
      var _this4 = this;
      debug('probing transport "%s"', name);
      var transport = this.createTransport(name);
      var failed = false;
      Socket.priorWebsocketSuccess = false;
      var onTransportOpen = function onTransportOpen() {
        if (failed) return;
        debug('probe transport "%s" opened', name);
        transport.send([{
          type: "ping",
          data: "probe"
        }]);
        transport.once("packet", function (msg) {
          if (failed) return;
          if ("pong" === msg.type && "probe" === msg.data) {
            debug('probe transport "%s" pong', name);
            _this4.upgrading = true;
            _this4.emitReserved("upgrading", transport);
            if (!transport) return;
            Socket.priorWebsocketSuccess = "websocket" === transport.name;
            debug('pausing current transport "%s"', _this4.transport.name);
            _this4.transport.pause(function () {
              if (failed) return;
              if ("closed" === _this4.readyState) return;
              debug("changing transport and sending upgrade packet");
              cleanup();
              _this4.setTransport(transport);
              transport.send([{
                type: "upgrade"
              }]);
              _this4.emitReserved("upgrade", transport);
              transport = null;
              _this4.upgrading = false;
              _this4.flush();
            });
          } else {
            debug('probe transport "%s" failed', name);
            var err = new Error("probe error");
            // @ts-ignore
            err.transport = transport.name;
            _this4.emitReserved("upgradeError", err);
          }
        });
      };
      function freezeTransport() {
        if (failed) return;
        // Any callback called by transport should be ignored since now
        failed = true;
        cleanup();
        transport.close();
        transport = null;
      }
      // Handle any error that happens while probing
      var onerror = function onerror(err) {
        var error = new Error("probe error: " + err);
        // @ts-ignore
        error.transport = transport.name;
        freezeTransport();
        debug('probe transport "%s" failed because of error: %s', name, err);
        _this4.emitReserved("upgradeError", error);
      };
      function onTransportClose() {
        onerror("transport closed");
      }
      // When the socket is closed while we're probing
      function onclose() {
        onerror("socket closed");
      }
      // When the socket is upgraded while we're probing
      function onupgrade(to) {
        if (transport && to.name !== transport.name) {
          debug('"%s" works - aborting "%s"', to.name, transport.name);
          freezeTransport();
        }
      }
      // Remove all listeners on the transport and on self
      var cleanup = function cleanup() {
        transport.removeListener("open", onTransportOpen);
        transport.removeListener("error", onerror);
        transport.removeListener("close", onTransportClose);
        _this4.off("close", onclose);
        _this4.off("upgrading", onupgrade);
      };
      transport.once("open", onTransportOpen);
      transport.once("error", onerror);
      transport.once("close", onTransportClose);
      this.once("close", onclose);
      this.once("upgrading", onupgrade);
      if (this.upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
        // favor WebTransport
        this.setTimeoutFn(function () {
          if (!failed) {
            transport.open();
          }
        }, 200);
      } else {
        transport.open();
      }
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */
  }, {
    key: "onOpen",
    value: function onOpen() {
      debug("socket open");
      this.readyState = "open";
      Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
      this.emitReserved("open");
      this.flush();
      // we check for `readyState` in case an `open`
      // listener already closed the socket
      if ("open" === this.readyState && this.opts.upgrade) {
        debug("starting upgrade probes");
        var i = 0;
        var l = this.upgrades.length;
        for (; i < l; i++) {
          this.probe(this.upgrades[i]);
        }
      }
    }
    /**
     * Handles a packet.
     *
     * @private
     */
  }, {
    key: "onPacket",
    value: function onPacket(packet) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
        this.emitReserved("packet", packet);
        // Socket is live - any packet counts
        this.emitReserved("heartbeat");
        this.resetPingTimeout();
        switch (packet.type) {
          case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;
          case "ping":
            this.sendPacket("pong");
            this.emitReserved("ping");
            this.emitReserved("pong");
            break;
          case "error":
            var err = new Error("server error");
            // @ts-ignore
            err.code = packet.data;
            this.onError(err);
            break;
          case "message":
            this.emitReserved("data", packet.data);
            this.emitReserved("message", packet.data);
            break;
        }
      } else {
        debug('packet received with socket readyState "%s"', this.readyState);
      }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */
  }, {
    key: "onHandshake",
    value: function onHandshake(data) {
      this.emitReserved("handshake", data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this.upgrades = this.filterUpgrades(data.upgrades);
      this.pingInterval = data.pingInterval;
      this.pingTimeout = data.pingTimeout;
      this.maxPayload = data.maxPayload;
      this.onOpen();
      // In case open handler closes socket
      if ("closed" === this.readyState) return;
      this.resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */
  }, {
    key: "resetPingTimeout",
    value: function resetPingTimeout() {
      var _this5 = this;
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.pingTimeoutTimer = this.setTimeoutFn(function () {
        _this5.onClose("ping timeout");
      }, this.pingInterval + this.pingTimeout);
      if (this.opts.autoUnref) {
        this.pingTimeoutTimer.unref();
      }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */
  }, {
    key: "onDrain",
    value: function onDrain() {
      this.writeBuffer.splice(0, this.prevBufferLen);
      // setting prevBufferLen = 0 is very important
      // for example, when upgrading, upgrade packet is sent over,
      // and a nonzero prevBufferLen could cause problems on `drain`
      this.prevBufferLen = 0;
      if (0 === this.writeBuffer.length) {
        this.emitReserved("drain");
      } else {
        this.flush();
      }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */
  }, {
    key: "flush",
    value: function flush() {
      if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        var packets = this.getWritablePackets();
        debug("flushing %d packets in socket", packets.length);
        this.transport.send(packets);
        // keep track of current length of writeBuffer
        // splice writeBuffer and callbackBuffer on `drain`
        this.prevBufferLen = packets.length;
        this.emitReserved("flush");
      }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */
  }, {
    key: "getWritablePackets",
    value: function getWritablePackets() {
      var shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
      if (!shouldCheckPayloadSize) {
        return this.writeBuffer;
      }
      var payloadSize = 1; // first packet type
      for (var i = 0; i < this.writeBuffer.length; i++) {
        var data = this.writeBuffer[i].data;
        if (data) {
          payloadSize += (0, util_js_1.byteLength)(data);
        }
        if (i > 0 && payloadSize > this.maxPayload) {
          debug("only send %d out of %d packets", i, this.writeBuffer.length);
          return this.writeBuffer.slice(0, i);
        }
        payloadSize += 2; // separator + packet type
      }
      debug("payload size is %d (max: %d)", payloadSize, this.maxPayload);
      return this.writeBuffer;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} callback function.
     * @return {Socket} for chaining.
     */
  }, {
    key: "write",
    value: function write(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
  }, {
    key: "send",
    value: function send(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */
  }, {
    key: "sendPacket",
    value: function sendPacket(type, data, options, fn) {
      if ("function" === typeof data) {
        fn = data;
        data = undefined;
      }
      if ("function" === typeof options) {
        fn = options;
        options = null;
      }
      if ("closing" === this.readyState || "closed" === this.readyState) {
        return;
      }
      options = options || {};
      options.compress = false !== options.compress;
      var packet = {
        type: type,
        data: data,
        options: options
      };
      this.emitReserved("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (fn) this.once("flush", fn);
      this.flush();
    }
    /**
     * Closes the connection.
     */
  }, {
    key: "close",
    value: function close() {
      var _this6 = this;
      var close = function close() {
        _this6.onClose("forced close");
        debug("socket closing - telling transport to close");
        _this6.transport.close();
      };
      var cleanupAndClose = function cleanupAndClose() {
        _this6.off("upgrade", cleanupAndClose);
        _this6.off("upgradeError", cleanupAndClose);
        close();
      };
      var waitForUpgrade = function waitForUpgrade() {
        // wait for upgrade to finish since we can't send packets while pausing a transport
        _this6.once("upgrade", cleanupAndClose);
        _this6.once("upgradeError", cleanupAndClose);
      };
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.readyState = "closing";
        if (this.writeBuffer.length) {
          this.once("drain", function () {
            if (_this6.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }
      return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */
  }, {
    key: "onError",
    value: function onError(err) {
      debug("socket error %j", err);
      Socket.priorWebsocketSuccess = false;
      this.emitReserved("error", err);
      this.onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */
  }, {
    key: "onClose",
    value: function onClose(reason, description) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket close with reason: "%s"', reason);
        // clear timers
        this.clearTimeoutFn(this.pingTimeoutTimer);
        // stop event from firing again for transport
        this.transport.removeAllListeners("close");
        // ensure transport won't stay open
        this.transport.close();
        // ignore further transport communication
        this.transport.removeAllListeners();
        if (typeof removeEventListener === "function") {
          removeEventListener("beforeunload", this.beforeunloadEventListener, false);
          removeEventListener("offline", this.offlineEventListener, false);
        }
        // set ready state
        this.readyState = "closed";
        // clear session id
        this.id = null;
        // emit close event
        this.emitReserved("close", reason, description);
        // clean buffers after, so users can still
        // grab the buffers on `close` event
        this.writeBuffer = [];
        this.prevBufferLen = 0;
      }
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */
  }, {
    key: "filterUpgrades",
    value: function filterUpgrades(upgrades) {
      var filteredUpgrades = [];
      var i = 0;
      var j = upgrades.length;
      for (; i < j; i++) {
        if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);
      }
      return filteredUpgrades;
    }
  }]);
}(component_emitter_1.Emitter);
exports.Socket = Socket;
Socket.protocol = engine_io_parser_1.protocol;

},{"./contrib/parseqs.js":98,"./contrib/parseuri.js":99,"./transports/index.js":105,"./transports/websocket-constructor.js":107,"./util.js":111,"@socket.io/component-emitter":39,"debug":95,"engine.io-parser":116}],104:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transport = exports.TransportError = void 0;
var engine_io_parser_1 = require("engine.io-parser");
var component_emitter_1 = require("@socket.io/component-emitter");
var util_js_1 = require("./util.js");
var debug_1 = __importDefault(require("debug")); // debug()
var parseqs_js_1 = require("./contrib/parseqs.js");
var debug = (0, debug_1["default"])("engine.io-client:transport"); // debug()
var TransportError = /*#__PURE__*/function (_Error) {
  function TransportError(reason, description, context) {
    var _this;
    _classCallCheck(this, TransportError);
    _this = _callSuper(this, TransportError, [reason]);
    _this.description = description;
    _this.context = context;
    _this.type = "TransportError";
    return _this;
  }
  _inherits(TransportError, _Error);
  return _createClass(TransportError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
exports.TransportError = TransportError;
var Transport = /*#__PURE__*/function (_component_emitter_1$) {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  function Transport(opts) {
    var _this2;
    _classCallCheck(this, Transport);
    _this2 = _callSuper(this, Transport);
    _this2.writable = false;
    (0, util_js_1.installTimerFunctions)(_this2, opts);
    _this2.opts = opts;
    _this2.query = opts.query;
    _this2.socket = opts.socket;
    return _this2;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  _inherits(Transport, _component_emitter_1$);
  return _createClass(Transport, [{
    key: "onError",
    value: function onError(reason, description, context) {
      _get(_getPrototypeOf(Transport.prototype), "emitReserved", this).call(this, "error", new TransportError(reason, description, context));
      return this;
    }
    /**
     * Opens the transport.
     */
  }, {
    key: "open",
    value: function open() {
      this.readyState = "opening";
      this.doOpen();
      return this;
    }
    /**
     * Closes the transport.
     */
  }, {
    key: "close",
    value: function close() {
      if (this.readyState === "opening" || this.readyState === "open") {
        this.doClose();
        this.onClose();
      }
      return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */
  }, {
    key: "send",
    value: function send(packets) {
      if (this.readyState === "open") {
        this.write(packets);
      } else {
        // this might happen if the transport was silently closed in the beforeunload event handler
        debug("transport is not open, discarding packets");
      }
    }
    /**
     * Called upon open
     *
     * @protected
     */
  }, {
    key: "onOpen",
    value: function onOpen() {
      this.readyState = "open";
      this.writable = true;
      _get(_getPrototypeOf(Transport.prototype), "emitReserved", this).call(this, "open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */
  }, {
    key: "onData",
    value: function onData(data) {
      var packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);
      this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */
  }, {
    key: "onPacket",
    value: function onPacket(packet) {
      _get(_getPrototypeOf(Transport.prototype), "emitReserved", this).call(this, "packet", packet);
    }
    /**
     * Called upon close.
     *
     * @protected
     */
  }, {
    key: "onClose",
    value: function onClose(details) {
      this.readyState = "closed";
      _get(_getPrototypeOf(Transport.prototype), "emitReserved", this).call(this, "close", details);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */
  }, {
    key: "pause",
    value: function pause(onPause) {}
  }, {
    key: "createUri",
    value: function createUri(schema) {
      var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
    }
  }, {
    key: "_hostname",
    value: function _hostname() {
      var hostname = this.opts.hostname;
      return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
    }
  }, {
    key: "_port",
    value: function _port() {
      if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
        return ":" + this.opts.port;
      } else {
        return "";
      }
    }
  }, {
    key: "_query",
    value: function _query(query) {
      var encodedQuery = (0, parseqs_js_1.encode)(query);
      return encodedQuery.length ? "?" + encodedQuery : "";
    }
  }]);
}(component_emitter_1.Emitter);
exports.Transport = Transport;

},{"./contrib/parseqs.js":98,"./util.js":111,"@socket.io/component-emitter":39,"debug":95,"engine.io-parser":116}],105:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transports = void 0;
var polling_js_1 = require("./polling.js");
var websocket_js_1 = require("./websocket.js");
var webtransport_js_1 = require("./webtransport.js");
exports.transports = {
  websocket: websocket_js_1.WS,
  webtransport: webtransport_js_1.WT,
  polling: polling_js_1.Polling
};

},{"./polling.js":106,"./websocket.js":108,"./webtransport.js":109}],106:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Request = exports.Polling = void 0;
var transport_js_1 = require("../transport.js");
var debug_1 = __importDefault(require("debug")); // debug()
var yeast_js_1 = require("../contrib/yeast.js");
var engine_io_parser_1 = require("engine.io-parser");
var xmlhttprequest_js_1 = require("./xmlhttprequest.js");
var component_emitter_1 = require("@socket.io/component-emitter");
var util_js_1 = require("../util.js");
var globalThis_js_1 = require("../globalThis.js");
var debug = (0, debug_1["default"])("engine.io-client:polling"); // debug()
function empty() {}
var hasXHR2 = function () {
  var xhr = new xmlhttprequest_js_1.XHR({
    xdomain: false
  });
  return null != xhr.responseType;
}();
var Polling = /*#__PURE__*/function (_transport_js_1$Trans) {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  function Polling(opts) {
    var _this;
    _classCallCheck(this, Polling);
    _this = _callSuper(this, Polling, [opts]);
    _this.polling = false;
    if (typeof location !== "undefined") {
      var isSSL = "https:" === location.protocol;
      var port = location.port;
      // some user agents have empty `location.port`
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      _this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
    /**
     * XHR supports binary
     */
    var forceBase64 = opts && opts.forceBase64;
    _this.supportsBinary = hasXHR2 && !forceBase64;
    if (_this.opts.withCredentials) {
      _this.cookieJar = (0, xmlhttprequest_js_1.createCookieJar)();
    }
    return _this;
  }
  _inherits(Polling, _transport_js_1$Trans);
  return _createClass(Polling, [{
    key: "name",
    get: function get() {
      return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */
  }, {
    key: "doOpen",
    value: function doOpen() {
      this.poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */
  }, {
    key: "pause",
    value: function pause(onPause) {
      var _this2 = this;
      this.readyState = "pausing";
      var pause = function pause() {
        debug("paused");
        _this2.readyState = "paused";
        onPause();
      };
      if (this.polling || !this.writable) {
        var total = 0;
        if (this.polling) {
          debug("we are currently polling - waiting to pause");
          total++;
          this.once("pollComplete", function () {
            debug("pre-pause polling complete");
            --total || pause();
          });
        }
        if (!this.writable) {
          debug("we are currently writing - waiting to pause");
          total++;
          this.once("drain", function () {
            debug("pre-pause writing complete");
            --total || pause();
          });
        }
      } else {
        pause();
      }
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */
  }, {
    key: "poll",
    value: function poll() {
      debug("polling");
      this.polling = true;
      this.doPoll();
      this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */
  }, {
    key: "onData",
    value: function onData(data) {
      var _this3 = this;
      debug("polling got data %s", data);
      var callback = function callback(packet) {
        // if its the first message we consider the transport open
        if ("opening" === _this3.readyState && packet.type === "open") {
          _this3.onOpen();
        }
        // if its a close packet, we close the ongoing requests
        if ("close" === packet.type) {
          _this3.onClose({
            description: "transport closed by the server"
          });
          return false;
        }
        // otherwise bypass onData and handle the message
        _this3.onPacket(packet);
      };
      // decode payload
      (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);
      // if an event did not trigger closing
      if ("closed" !== this.readyState) {
        // if we got data we're not polling
        this.polling = false;
        this.emitReserved("pollComplete");
        if ("open" === this.readyState) {
          this.poll();
        } else {
          debug('ignoring poll - transport state "%s"', this.readyState);
        }
      }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */
  }, {
    key: "doClose",
    value: function doClose() {
      var _this4 = this;
      var close = function close() {
        debug("writing close packet");
        _this4.write([{
          type: "close"
        }]);
      };
      if ("open" === this.readyState) {
        debug("transport open - closing");
        close();
      } else {
        // in case we're trying to close while
        // handshaking is in progress (GH-164)
        debug("transport not open - deferring close");
        this.once("open", close);
      }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */
  }, {
    key: "write",
    value: function write(packets) {
      var _this5 = this;
      this.writable = false;
      (0, engine_io_parser_1.encodePayload)(packets, function (data) {
        _this5.doWrite(data, function () {
          _this5.writable = true;
          _this5.emitReserved("drain");
        });
      });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
  }, {
    key: "uri",
    value: function uri() {
      var schema = this.opts.secure ? "https" : "http";
      var query = this.query || {};
      // cache busting is forced
      if (false !== this.opts.timestampRequests) {
        query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();
      }
      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }
      return this.createUri(schema, query);
    }
    /**
     * Creates a request.
     *
     * @param {String} method
     * @private
     */
  }, {
    key: "request",
    value: function request() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      Object.assign(opts, {
        xd: this.xd,
        cookieJar: this.cookieJar
      }, this.opts);
      return new Request(this.uri(), opts);
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @private
     */
  }, {
    key: "doWrite",
    value: function doWrite(data, fn) {
      var _this6 = this;
      var req = this.request({
        method: "POST",
        data: data
      });
      req.on("success", fn);
      req.on("error", function (xhrStatus, context) {
        _this6.onError("xhr post error", xhrStatus, context);
      });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */
  }, {
    key: "doPoll",
    value: function doPoll() {
      var _this7 = this;
      debug("xhr poll");
      var req = this.request();
      req.on("data", this.onData.bind(this));
      req.on("error", function (xhrStatus, context) {
        _this7.onError("xhr poll error", xhrStatus, context);
      });
      this.pollXhr = req;
    }
  }]);
}(transport_js_1.Transport);
exports.Polling = Polling;
var Request = /*#__PURE__*/function (_component_emitter_1$) {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  function Request(uri, opts) {
    var _this8;
    _classCallCheck(this, Request);
    _this8 = _callSuper(this, Request);
    (0, util_js_1.installTimerFunctions)(_this8, opts);
    _this8.opts = opts;
    _this8.method = opts.method || "GET";
    _this8.uri = uri;
    _this8.data = undefined !== opts.data ? opts.data : null;
    _this8.create();
    return _this8;
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _inherits(Request, _component_emitter_1$);
  return _createClass(Request, [{
    key: "create",
    value: function create() {
      var _this9 = this;
      var _a;
      var opts = (0, util_js_1.pick)(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
      opts.xdomain = !!this.opts.xd;
      var xhr = this.xhr = new xmlhttprequest_js_1.XHR(opts);
      try {
        debug("xhr open %s: %s", this.method, this.uri);
        xhr.open(this.method, this.uri, true);
        try {
          if (this.opts.extraHeaders) {
            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
            for (var i in this.opts.extraHeaders) {
              if (this.opts.extraHeaders.hasOwnProperty(i)) {
                xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
              }
            }
          }
        } catch (e) {}
        if ("POST" === this.method) {
          try {
            xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
          } catch (e) {}
        }
        try {
          xhr.setRequestHeader("Accept", "*/*");
        } catch (e) {}
        (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
        // ie6 check
        if ("withCredentials" in xhr) {
          xhr.withCredentials = this.opts.withCredentials;
        }
        if (this.opts.requestTimeout) {
          xhr.timeout = this.opts.requestTimeout;
        }
        xhr.onreadystatechange = function () {
          var _a;
          if (xhr.readyState === 3) {
            (_a = _this9.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(xhr);
          }
          if (4 !== xhr.readyState) return;
          if (200 === xhr.status || 1223 === xhr.status) {
            _this9.onLoad();
          } else {
            // make sure the `error` event handler that's user-set
            // does not throw in the same tick and gets caught here
            _this9.setTimeoutFn(function () {
              _this9.onError(typeof xhr.status === "number" ? xhr.status : 0);
            }, 0);
          }
        };
        debug("xhr data %s", this.data);
        xhr.send(this.data);
      } catch (e) {
        // Need to defer since .create() is called directly from the constructor
        // and thus the 'error' event can only be only bound *after* this exception
        // occurs.  Therefore, also, we cannot throw here at all.
        this.setTimeoutFn(function () {
          _this9.onError(e);
        }, 0);
        return;
      }
      if (typeof document !== "undefined") {
        this.index = Request.requestsCount++;
        Request.requests[this.index] = this;
      }
    }
    /**
     * Called upon error.
     *
     * @private
     */
  }, {
    key: "onError",
    value: function onError(err) {
      this.emitReserved("error", err, this.xhr);
      this.cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */
  }, {
    key: "cleanup",
    value: function cleanup(fromError) {
      if ("undefined" === typeof this.xhr || null === this.xhr) {
        return;
      }
      this.xhr.onreadystatechange = empty;
      if (fromError) {
        try {
          this.xhr.abort();
        } catch (e) {}
      }
      if (typeof document !== "undefined") {
        delete Request.requests[this.index];
      }
      this.xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */
  }, {
    key: "onLoad",
    value: function onLoad() {
      var data = this.xhr.responseText;
      if (data !== null) {
        this.emitReserved("data", data);
        this.emitReserved("success");
        this.cleanup();
      }
    }
    /**
     * Aborts the request.
     *
     * @package
     */
  }, {
    key: "abort",
    value: function abort() {
      this.cleanup();
    }
  }]);
}(component_emitter_1.Emitter);
exports.Request = Request;
Request.requestsCount = 0;
Request.requests = {};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */
if (typeof document !== "undefined") {
  // @ts-ignore
  if (typeof attachEvent === "function") {
    // @ts-ignore
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    var terminationEvent = "onpagehide" in globalThis_js_1.globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

},{"../contrib/yeast.js":100,"../globalThis.js":101,"../transport.js":104,"../util.js":111,"./xmlhttprequest.js":110,"@socket.io/component-emitter":39,"debug":95,"engine.io-parser":116}],107:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultBinaryType = exports.usingBrowserWebSocket = exports.WebSocket = exports.nextTick = void 0;
var globalThis_js_1 = require("../globalThis.js");
exports.nextTick = function () {
  var isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return function (cb) {
      return Promise.resolve().then(cb);
    };
  } else {
    return function (cb, setTimeoutFn) {
      return setTimeoutFn(cb, 0);
    };
  }
}();
exports.WebSocket = globalThis_js_1.globalThisShim.WebSocket || globalThis_js_1.globalThisShim.MozWebSocket;
exports.usingBrowserWebSocket = true;
exports.defaultBinaryType = "arraybuffer";

},{"../globalThis.js":101}],108:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WS = void 0;
var transport_js_1 = require("../transport.js");
var yeast_js_1 = require("../contrib/yeast.js");
var util_js_1 = require("../util.js");
var websocket_constructor_js_1 = require("./websocket-constructor.js");
var debug_1 = __importDefault(require("debug")); // debug()
var engine_io_parser_1 = require("engine.io-parser");
var debug = (0, debug_1["default"])("engine.io-client:websocket"); // debug()
// detect ReactNative environment
var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
var WS = /*#__PURE__*/function (_transport_js_1$Trans) {
  /**
   * WebSocket transport constructor.
   *
   * @param {Object} opts - connection options
   * @protected
   */
  function WS(opts) {
    var _this;
    _classCallCheck(this, WS);
    _this = _callSuper(this, WS, [opts]);
    _this.supportsBinary = !opts.forceBase64;
    return _this;
  }
  _inherits(WS, _transport_js_1$Trans);
  return _createClass(WS, [{
    key: "name",
    get: function get() {
      return "websocket";
    }
  }, {
    key: "doOpen",
    value: function doOpen() {
      if (!this.check()) {
        // let probe timeout
        return;
      }
      var uri = this.uri();
      var protocols = this.opts.protocols;
      // React Native only supports the 'headers' option, and will print a warning if anything else is passed
      var opts = isReactNative ? {} : (0, util_js_1.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
      if (this.opts.extraHeaders) {
        opts.headers = this.opts.extraHeaders;
      }
      try {
        this.ws = websocket_constructor_js_1.usingBrowserWebSocket && !isReactNative ? protocols ? new websocket_constructor_js_1.WebSocket(uri, protocols) : new websocket_constructor_js_1.WebSocket(uri) : new websocket_constructor_js_1.WebSocket(uri, protocols, opts);
      } catch (err) {
        return this.emitReserved("error", err);
      }
      this.ws.binaryType = this.socket.binaryType;
      this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */
  }, {
    key: "addEventListeners",
    value: function addEventListeners() {
      var _this2 = this;
      this.ws.onopen = function () {
        if (_this2.opts.autoUnref) {
          _this2.ws._socket.unref();
        }
        _this2.onOpen();
      };
      this.ws.onclose = function (closeEvent) {
        return _this2.onClose({
          description: "websocket connection closed",
          context: closeEvent
        });
      };
      this.ws.onmessage = function (ev) {
        return _this2.onData(ev.data);
      };
      this.ws.onerror = function (e) {
        return _this2.onError("websocket error", e);
      };
    }
  }, {
    key: "write",
    value: function write(packets) {
      var _this3 = this;
      this.writable = false;
      // encodePacket efficient as it uses WS framing
      // no need for encodePayload
      var _loop = function _loop() {
        var packet = packets[i];
        var lastPacket = i === packets.length - 1;
        (0, engine_io_parser_1.encodePacket)(packet, _this3.supportsBinary, function (data) {
          // always create a new object (GH-437)
          var opts = {};
          if (!websocket_constructor_js_1.usingBrowserWebSocket) {
            if (packet.options) {
              opts.compress = packet.options.compress;
            }
            if (_this3.opts.perMessageDeflate) {
              var len =
              // @ts-ignore
              "string" === typeof data ? Buffer.byteLength(data) : data.length;
              if (len < _this3.opts.perMessageDeflate.threshold) {
                opts.compress = false;
              }
            }
          }
          // Sometimes the websocket has already been closed but the browser didn't
          // have a chance of informing us about it yet, in that case send will
          // throw an error
          try {
            if (websocket_constructor_js_1.usingBrowserWebSocket) {
              // TypeError is thrown when passing the second argument on Safari
              _this3.ws.send(data);
            } else {
              _this3.ws.send(data, opts);
            }
          } catch (e) {
            debug("websocket closed before onclose event");
          }
          if (lastPacket) {
            // fake drain
            // defer to next tick to allow Socket to clear writeBuffer
            (0, websocket_constructor_js_1.nextTick)(function () {
              _this3.writable = true;
              _this3.emitReserved("drain");
            }, _this3.setTimeoutFn);
          }
        });
      };
      for (var i = 0; i < packets.length; i++) {
        _loop();
      }
    }
  }, {
    key: "doClose",
    value: function doClose() {
      if (typeof this.ws !== "undefined") {
        this.ws.close();
        this.ws = null;
      }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
  }, {
    key: "uri",
    value: function uri() {
      var schema = this.opts.secure ? "wss" : "ws";
      var query = this.query || {};
      // append timestamp to URI
      if (this.opts.timestampRequests) {
        query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();
      }
      // communicate binary support capabilities
      if (!this.supportsBinary) {
        query.b64 = 1;
      }
      return this.createUri(schema, query);
    }
    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @private
     */
  }, {
    key: "check",
    value: function check() {
      return !!websocket_constructor_js_1.WebSocket;
    }
  }]);
}(transport_js_1.Transport);
exports.WS = WS;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../contrib/yeast.js":100,"../transport.js":104,"../util.js":111,"./websocket-constructor.js":107,"buffer":90,"debug":95,"engine.io-parser":116}],109:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WT = void 0;
var transport_js_1 = require("../transport.js");
var websocket_constructor_js_1 = require("./websocket-constructor.js");
var engine_io_parser_1 = require("engine.io-parser");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = (0, debug_1["default"])("engine.io-client:webtransport"); // debug()
var WT = /*#__PURE__*/function (_transport_js_1$Trans) {
  function WT() {
    _classCallCheck(this, WT);
    return _callSuper(this, WT, arguments);
  }
  _inherits(WT, _transport_js_1$Trans);
  return _createClass(WT, [{
    key: "name",
    get: function get() {
      return "webtransport";
    }
  }, {
    key: "doOpen",
    value: function doOpen() {
      var _this = this;
      // @ts-ignore
      if (typeof WebTransport !== "function") {
        return;
      }
      // @ts-ignore
      this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
      this.transport.closed.then(function () {
        debug("transport closed gracefully");
        _this.onClose();
      })["catch"](function (err) {
        debug("transport closed due to %s", err);
        _this.onError("webtransport error", err);
      });
      // note: we could have used async/await, but that would require some additional polyfills
      this.transport.ready.then(function () {
        _this.transport.createBidirectionalStream().then(function (stream) {
          var decoderStream = (0, engine_io_parser_1.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, _this.socket.binaryType);
          var reader = stream.readable.pipeThrough(decoderStream).getReader();
          var encoderStream = (0, engine_io_parser_1.createPacketEncoderStream)();
          encoderStream.readable.pipeTo(stream.writable);
          _this.writer = encoderStream.writable.getWriter();
          var read = function read() {
            reader.read().then(function (_ref) {
              var done = _ref.done,
                value = _ref.value;
              if (done) {
                debug("session is closed");
                return;
              }
              debug("received chunk: %o", value);
              _this.onPacket(value);
              read();
            })["catch"](function (err) {
              debug("an error occurred while reading: %s", err);
            });
          };
          read();
          var packet = {
            type: "open"
          };
          if (_this.query.sid) {
            packet.data = "{\"sid\":\"".concat(_this.query.sid, "\"}");
          }
          _this.writer.write(packet).then(function () {
            return _this.onOpen();
          });
        });
      });
    }
  }, {
    key: "write",
    value: function write(packets) {
      var _this2 = this;
      this.writable = false;
      var _loop = function _loop() {
        var packet = packets[i];
        var lastPacket = i === packets.length - 1;
        _this2.writer.write(packet).then(function () {
          if (lastPacket) {
            (0, websocket_constructor_js_1.nextTick)(function () {
              _this2.writable = true;
              _this2.emitReserved("drain");
            }, _this2.setTimeoutFn);
          }
        });
      };
      for (var i = 0; i < packets.length; i++) {
        _loop();
      }
    }
  }, {
    key: "doClose",
    value: function doClose() {
      var _a;
      (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();
    }
  }]);
}(transport_js_1.Transport);
exports.WT = WT;

},{"../transport.js":104,"./websocket-constructor.js":107,"debug":95,"engine.io-parser":116}],110:[function(require,module,exports){
"use strict";

// browser shim for xmlhttprequest module
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCookieJar = exports.XHR = void 0;
var has_cors_js_1 = require("../contrib/has-cors.js");
var globalThis_js_1 = require("../globalThis.js");
function XHR(opts) {
  var xdomain = opts.xdomain;
  // XMLHttpRequest can be disabled on IE
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || has_cors_js_1.hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {}
  if (!xdomain) {
    try {
      return new globalThis_js_1.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {}
  }
}
exports.XHR = XHR;
function createCookieJar() {}
exports.createCookieJar = createCookieJar;

},{"../contrib/has-cors.js":97,"../globalThis.js":101}],111:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.byteLength = exports.installTimerFunctions = exports.pick = void 0;
var globalThis_js_1 = require("./globalThis.js");
function pick(obj) {
  for (var _len = arguments.length, attr = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    attr[_key - 1] = arguments[_key];
  }
  return attr.reduce(function (acc, k) {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
exports.pick = pick;
// Keep a reference to the real timeout functions so they can be used when overridden
var NATIVE_SET_TIMEOUT = globalThis_js_1.globalThisShim.setTimeout;
var NATIVE_CLEAR_TIMEOUT = globalThis_js_1.globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis_js_1.globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis_js_1.globalThisShim);
  } else {
    obj.setTimeoutFn = globalThis_js_1.globalThisShim.setTimeout.bind(globalThis_js_1.globalThisShim);
    obj.clearTimeoutFn = globalThis_js_1.globalThisShim.clearTimeout.bind(globalThis_js_1.globalThisShim);
  }
}
exports.installTimerFunctions = installTimerFunctions;
// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
var BASE64_OVERHEAD = 1.33;
// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  // arraybuffer or blob
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
exports.byteLength = byteLength;
function utf8Length(str) {
  var c = 0,
    length = 0;
  for (var i = 0, l = str.length; i < l; i++) {
    c = str.charCodeAt(i);
    if (c < 0x80) {
      length += 1;
    } else if (c < 0x800) {
      length += 2;
    } else if (c < 0xd800 || c >= 0xe000) {
      length += 3;
    } else {
      i++;
      length += 4;
    }
  }
  return length;
}

},{"./globalThis.js":101}],112:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;
var PACKET_TYPES = Object.create(null); // no Map = no polyfill
exports.PACKET_TYPES = PACKET_TYPES;
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = Object.create(null);
exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
Object.keys(PACKET_TYPES).forEach(function (key) {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = {
  type: "error",
  data: "parser error"
};
exports.ERROR_PACKET = ERROR_PACKET;

},{}],113:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decode = exports.encode = void 0;
// imported from https://github.com/socketio/base64-arraybuffer
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (var i = 0; i < chars.length; i++) {
  lookup[chars.charCodeAt(i)] = i;
}
var encode = function encode(arraybuffer) {
  var bytes = new Uint8Array(arraybuffer),
    i,
    len = bytes.length,
    base64 = '';
  for (i = 0; i < len; i += 3) {
    base64 += chars[bytes[i] >> 2];
    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
    base64 += chars[bytes[i + 2] & 63];
  }
  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + '=';
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + '==';
  }
  return base64;
};
exports.encode = encode;
var decode = function decode(base64) {
  var bufferLength = base64.length * 0.75,
    len = base64.length,
    i,
    p = 0,
    encoded1,
    encoded2,
    encoded3,
    encoded4;
  if (base64[base64.length - 1] === '=') {
    bufferLength--;
    if (base64[base64.length - 2] === '=') {
      bufferLength--;
    }
  }
  var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup[base64.charCodeAt(i)];
    encoded2 = lookup[base64.charCodeAt(i + 1)];
    encoded3 = lookup[base64.charCodeAt(i + 2)];
    encoded4 = lookup[base64.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
exports.decode = decode;

},{}],114:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodePacket = void 0;
var commons_js_1 = require("./commons.js");
var base64_arraybuffer_js_1 = require("./contrib/base64-arraybuffer.js");
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var decodePacket = function decodePacket(encodedPacket, binaryType) {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  var type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  var packetType = commons_js_1.PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return commons_js_1.ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: commons_js_1.PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: commons_js_1.PACKET_TYPES_REVERSE[type]
  };
};
exports.decodePacket = decodePacket;
var decodeBase64Packet = function decodeBase64Packet(data, binaryType) {
  if (withNativeArrayBuffer) {
    var decoded = (0, base64_arraybuffer_js_1.decode)(data);
    return mapBinary(decoded, binaryType);
  } else {
    return {
      base64: true,
      data: data
    }; // fallback for old browsers
  }
};
var mapBinary = function mapBinary(data, binaryType) {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        // from WebSocket + binaryType "blob"
        return data;
      } else {
        // from HTTP long-polling or WebTransport
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        // from HTTP long-polling (base64) or WebSocket + binaryType "arraybuffer"
        return data;
      } else {
        // from WebTransport (Uint8Array)
        return data.buffer;
      }
  }
};

},{"./commons.js":112,"./contrib/base64-arraybuffer.js":113}],115:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodePacket = exports.encodePacketToBinary = void 0;
var commons_js_1 = require("./commons.js");
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
// ArrayBuffer.isView method is not defined in IE10
var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
var encodePacket = function encodePacket(_ref, supportsBinary, callback) {
  var type = _ref.type,
    data = _ref.data;
  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  // plain string
  return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
};
exports.encodePacket = encodePacket;
var encodeBlobAsBase64 = function encodeBlobAsBase64(data, callback) {
  var fileReader = new FileReader();
  fileReader.onload = function () {
    var content = fileReader.result.split(",")[1];
    callback("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
var TEXT_ENCODER;
function encodePacketToBinary(packet, callback) {
  if (withNativeBlob && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback);
  } else if (withNativeArrayBuffer && (packet.data instanceof ArrayBuffer || isView(packet.data))) {
    return callback(toArray(packet.data));
  }
  encodePacket(packet, false, function (encoded) {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}
exports.encodePacketToBinary = encodePacketToBinary;

},{"./commons.js":112}],116:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = exports.createPacketDecoderStream = exports.createPacketEncoderStream = void 0;
var encodePacket_js_1 = require("./encodePacket.js");
Object.defineProperty(exports, "encodePacket", {
  enumerable: true,
  get: function get() {
    return encodePacket_js_1.encodePacket;
  }
});
var decodePacket_js_1 = require("./decodePacket.js");
Object.defineProperty(exports, "decodePacket", {
  enumerable: true,
  get: function get() {
    return decodePacket_js_1.decodePacket;
  }
});
var commons_js_1 = require("./commons.js");
var SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
var encodePayload = function encodePayload(packets, callback) {
  // some packets may be added to the array while encoding, so the initial length must be saved
  var length = packets.length;
  var encodedPackets = new Array(length);
  var count = 0;
  packets.forEach(function (packet, i) {
    // force base64 encoding for binary packets
    (0, encodePacket_js_1.encodePacket)(packet, false, function (encodedPacket) {
      encodedPackets[i] = encodedPacket;
      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
exports.encodePayload = encodePayload;
var decodePayload = function decodePayload(encodedPayload, binaryType) {
  var encodedPackets = encodedPayload.split(SEPARATOR);
  var packets = [];
  for (var i = 0; i < encodedPackets.length; i++) {
    var decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
exports.decodePayload = decodePayload;
function createPacketEncoderStream() {
  // @ts-expect-error
  return new TransformStream({
    transform: function transform(packet, controller) {
      (0, encodePacket_js_1.encodePacketToBinary)(packet, function (encodedPacket) {
        var payloadLength = encodedPacket.length;
        var header;
        // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          var view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          var _view = new DataView(header.buffer);
          _view.setUint8(0, 127);
          _view.setBigUint64(1, BigInt(payloadLength));
        }
        // first bit indicates whether the payload is plain text (0) or binary (1)
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 0x80;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
exports.createPacketEncoderStream = createPacketEncoderStream;
var TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce(function (acc, chunk) {
    return acc + chunk.length;
  }, 0);
}
function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  var buffer = new Uint8Array(size);
  var j = 0;
  for (var i = 0; i < size; i++) {
    buffer[i] = chunks[0][j++];
    if (j === chunks[0].length) {
      chunks.shift();
      j = 0;
    }
  }
  if (chunks.length && j < chunks[0].length) {
    chunks[0] = chunks[0].slice(j);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  var chunks = [];
  var state = 0 /* READ_HEADER */;
  var expectedLength = -1;
  var isBinary = false;
  // @ts-expect-error
  return new TransformStream({
    transform: function transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0 /* READ_HEADER */) {
          if (totalLength(chunks) < 1) {
            break;
          }
          var header = concatChunks(chunks, 1);
          isBinary = (header[0] & 0x80) === 0x80;
          expectedLength = header[0] & 0x7f;
          if (expectedLength < 126) {
            state = 3 /* READ_PAYLOAD */;
          } else if (expectedLength === 126) {
            state = 1 /* READ_EXTENDED_LENGTH_16 */;
          } else {
            state = 2 /* READ_EXTENDED_LENGTH_64 */;
          }
        } else if (state === 1 /* READ_EXTENDED_LENGTH_16 */) {
          if (totalLength(chunks) < 2) {
            break;
          }
          var headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3 /* READ_PAYLOAD */;
        } else if (state === 2 /* READ_EXTENDED_LENGTH_64 */) {
          if (totalLength(chunks) < 8) {
            break;
          }
          var _headerArray = concatChunks(chunks, 8);
          var view = new DataView(_headerArray.buffer, _headerArray.byteOffset, _headerArray.length);
          var n = view.getUint32(0);
          if (n > Math.pow(2, 53 - 32) - 1) {
            // the maximum safe integer in JavaScript is 2^53 - 1
            controller.enqueue(commons_js_1.ERROR_PACKET);
            break;
          }
          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
          state = 3 /* READ_PAYLOAD */;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          var data = concatChunks(chunks, expectedLength);
          controller.enqueue((0, decodePacket_js_1.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0 /* READ_HEADER */;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(commons_js_1.ERROR_PACKET);
          break;
        }
      }
    }
  });
}
exports.createPacketDecoderStream = createPacketDecoderStream;
exports.protocol = 4;

},{"./commons.js":112,"./decodePacket.js":114,"./encodePacket.js":115}],117:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function c(input, length, result) {
  var b = [0, 0, 0, 0, 0];
  for (var i = 0; i < length; i += 4) {
    var n = ((input[i] * 256 + input[i + 1]) * 256 + input[i + 2]) * 256 + input[i + 3];
    if (!n) {
      result.push("z");
    } else {
      for (var j = 0; j < 5; b[j++] = n % 85 + 33, n = Math.floor(n / 85)) {}
      result.push(String.fromCharCode(b[4], b[3], b[2], b[1], b[0]));
    }
  }
}
function _encode(arr) {
  // summary: encodes input data in ascii85 string
  // input: ArrayLike
  var _a;
  var input = arr,
    result = [],
    remainder = input.length % 4,
    length = input.length - remainder;
  c(input, length, result);
  if (remainder) {
    var t = new Uint8Array(4);
    t.set(input.slice(length), 0);
    c(t, 4, result);
    var x = (_a = result.pop()) !== null && _a !== void 0 ? _a : "";
    if (x == "z") {
      x = "!!!!!";
    }
    result.push(x.substr(0, remainder + 1));
  }
  var ret = result.join(""); // String
  ret = "<~" + ret + "~>";
  return ret;
}
var ascii85 = {
  encode: function encode(arr) {
    if (arr instanceof ArrayBuffer) {
      arr = new Uint8Array(arr, 0, arr.byteLength);
    }
    return _encode(arr);
  },
  decode: function decode(input) {
    // summary: decodes the input string back to an ArrayBuffer
    // input: String: the input string to decode
    if (!input.startsWith("<~") || !input.endsWith("~>")) {
      throw new Error("Invalid input string");
    }
    input = input.substr(2, input.length - 4);
    var n = input.length,
      r = [],
      b = [0, 0, 0, 0, 0];
    var t, x, y, d;
    for (var i = 0; i < n; ++i) {
      if (input.charAt(i) == "z") {
        r.push(0, 0, 0, 0);
        continue;
      }
      for (var j = 0; j < 5; ++j) {
        b[j] = input.charCodeAt(i + j) - 33;
      }
      d = n - i;
      if (d < 5) {
        for (var _j = d; _j < 4; b[++_j] = 0) {}
        b[d] = 85;
      }
      t = (((b[0] * 85 + b[1]) * 85 + b[2]) * 85 + b[3]) * 85 + b[4];
      x = t & 255;
      t >>>= 8;
      y = t & 255;
      t >>>= 8;
      r.push(t >>> 8, t & 255, y, x);
      for (var _j2 = d; _j2 < 5; ++_j2, r.pop()) {}
      i += 4;
    }
    var data = new Uint8Array(r);
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
};
exports["default"] = ascii85;

},{}],118:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Base64 = /*#__PURE__*/function () {
  function Base64(value) {
    _classCallCheck(this, Base64);
    this.value = value;
    this.keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  }
  return _createClass(Base64, [{
    key: "encode",
    value: function encode() {
      var t = "";
      var n, r, i, s, o, u, a;
      var f = 0;
      var e = Base64.utf8_encode(this.value);
      while (f < e.length) {
        n = e.charCodeAt(f++);
        r = e.charCodeAt(f++);
        i = e.charCodeAt(f++);
        s = n >> 2;
        o = (n & 3) << 4 | r >> 4;
        u = (r & 15) << 2 | i >> 6;
        a = i & 63;
        if (isNaN(r)) {
          u = a = 64;
        } else if (isNaN(i)) {
          a = 64;
        }
        t = t + this.keyStr.charAt(s) + this.keyStr.charAt(o) + this.keyStr.charAt(u) + this.keyStr.charAt(a);
      }
      return t;
    }
  }, {
    key: "decode",
    value: function decode() {
      var t = "";
      var n, r, i;
      var s, o, u, a;
      var f = 0;
      var e = this.value.replace(/[^A-Za-z0-9+/=]/g, "");
      while (f < e.length) {
        s = this.keyStr.indexOf(e.charAt(f++));
        o = this.keyStr.indexOf(e.charAt(f++));
        u = this.keyStr.indexOf(e.charAt(f++));
        a = this.keyStr.indexOf(e.charAt(f++));
        n = s << 2 | o >> 4;
        r = (o & 15) << 4 | u >> 2;
        i = (u & 3) << 6 | a;
        t = t + String.fromCharCode(n);
        if (u != 64) {
          t = t + String.fromCharCode(r);
        }
        if (a != 64) {
          t = t + String.fromCharCode(i);
        }
      }
      t = Base64.utf8_decode(t);
      return t;
    }
  }], [{
    key: "utf8_encode",
    value: function utf8_encode(value) {
      var e = value.replace(/rn/g, "n");
      var t = "";
      for (var n = 0; n < e.length; n++) {
        var r = e.charCodeAt(n);
        if (r < 128) {
          t += String.fromCharCode(r);
        } else if (r > 127 && r < 2048) {
          t += String.fromCharCode(r >> 6 | 192);
          t += String.fromCharCode(r & 63 | 128);
        } else {
          t += String.fromCharCode(r >> 12 | 224);
          t += String.fromCharCode(r >> 6 & 63 | 128);
          t += String.fromCharCode(r & 63 | 128);
        }
      }
      return t;
    }
  }, {
    key: "utf8_decode",
    value: function utf8_decode(value) {
      var t = "";
      var n = 0;
      var r = 0,
        c1 = 0,
        c2 = 0,
        c3 = 0;
      while (n < value.length) {
        r = value.charCodeAt(n);
        if (r < 128) {
          t += String.fromCharCode(r);
          n++;
        } else if (r > 191 && r < 224) {
          c2 = value.charCodeAt(n + 1);
          t += String.fromCharCode((r & 31) << 6 | c2 & 63);
          n += 2;
        } else {
          c2 = value.charCodeAt(n + 1);
          c3 = value.charCodeAt(n + 2);
          t += String.fromCharCode((r & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
          n += 3;
        }
      }
      return t;
    }
  }, {
    key: "encode",
    value: function encode(value) {
      return new Base64(value).encode();
    }
  }, {
    key: "decode",
    value: function decode(value) {
      return new Base64(value).decode();
    }
  }]);
}();
exports["default"] = Base64;

},{}],119:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var A = function A(a, b) {
  return 1.0 - 3.0 * b + 3.0 * a;
};
var B = function B(a, b) {
  return 3.0 * b - 6.0 * a;
};
var C = function C(a) {
  return 3.0 * a;
};
var calcBezier = function calcBezier(a, b, c) {
  return ((A(b, c) * a + B(b, c)) * a + C(b)) * a;
};
var getSlope = function getSlope(a, b, c) {
  return 3.0 * A(b, c) * a * a + 2.0 * B(b, c) * a + C(b);
};
var binarySubdivide = function binarySubdivide(a, b, c, d, e) {
  var f,
    g,
    i = 0;
  do {
    g = b + (c - b) / 2.0;
    f = calcBezier(g, d, e) - a;
    if (f > 0.0) {
      c = g;
    } else {
      b = g;
    }
  } while (Math.abs(f) > 0.0000001 && ++i < 10);
  return g;
};
var newtonRaphsonIterate = function newtonRaphsonIterate(a, b, c, d) {
  for (var i = 0; i < 4; ++i) {
    var currentSlope = getSlope(b, c, d);
    if (currentSlope === 0.0) {
      return b;
    }
    var currentX = calcBezier(b, c, d) - a;
    b -= currentX / currentSlope;
  }
  return b;
};
var getTForX = function getTForX(a, props) {
  var b = 0.0,
    c = 1,
    d = props.kSplineTableSize - 1;
  for (; c !== d && props.sampleValues[c] <= a; ++c) {
    b += props.kSampleStepSize;
  }
  --c;
  var e = (a - props.sampleValues[c]) / (props.sampleValues[c + 1] - props.sampleValues[c]),
    f = b + e * props.kSampleStepSize,
    g = getSlope(f, props.x1, props.x2);
  if (g >= 0.001) {
    return newtonRaphsonIterate(a, f, props.x1, props.x2);
  } else if (g === 0.0) {
    return f;
  } else {
    return binarySubdivide(a, b, b + props.kSampleStepSize, props.x1, props.x2);
  }
};
var _elastic = function elastic(x) {
  return x * (33 * x * x * x * x - 106 * x * x * x + 126 * x * x - 67 * x + 15);
};
var _easeInElastic = function easeInElastic(x) {
  var c4 = 2 * Math.PI / 3;
  return x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4);
};
var _easeInOutElastic = function easeInOutElastic(x) {
  var c5 = 2 * Math.PI / 4.5;
  return x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1;
};
var _easeOutElastic = function easeOutElastic(x) {
  var c4 = 2 * Math.PI / 3;
  return x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1;
};
var _easeOutBounce = function easeOutBounce(x) {
  var n1 = 7.5625;
  var d1 = 2.75;
  return x < 1 / d1 ? n1 * x * x : x < 2 / d1 ? n1 * (x -= 1.5 / d1) * x + 0.75 : x < 2.5 / d1 ? n1 * (x -= 2.25 / d1) * x + 0.9375 : n1 * (x -= 2.625 / d1) * x + 0.984375;
};
var _easeInBounce = function easeInBounce(x) {
  return 1 - _easeOutBounce(1 - x);
};
var _easeInOutBounce = function easeInOutBounce(x) {
  return x < 0.5 ? (1 - _easeOutBounce(1 - 2 * x)) / 2 : (1 + _easeOutBounce(2 * x - 1)) / 2;
};
// Define um objeto que mapeia os nomes das animações para suas formas em camelCase
var easingList = {
  "linear": "linear",
  "elastic": "elastic",
  "ease": "ease",
  "ease-in": "easeIn",
  "ease-in-elastic": "easeInElastic",
  "ease-in-bounce": "easeInBounce",
  "ease-in-expo": "easeInExpo",
  "ease-in-sine": "easeInSine",
  "ease-in-quad": "easeInQuad",
  "ease-in-cubic": "easeInCubic",
  "ease-in-back": "easeInBack",
  "ease-in-quart": "easeInQuart",
  "ease-in-quint": "easeInQuint",
  "ease-in-circ": "easeInCirc",
  "ease-in-out": "easeInOut",
  "ease-in-out-elastic": "easeInOutElastic",
  "ease-in-out-bounce": "easeInOutBounce",
  "ease-in-out-sine": "easeInOutSine",
  "ease-in-out-quad": "easeInOutQuad",
  "ease-in-out-cubic": "easeInOutCubic",
  "ease-in-out-back": "easeInOutBack",
  "ease-in-out-quart": "easeInOutQuart",
  "ease-in-out-quint": "easeInOutQuint",
  "ease-in-out-expo": "easeInOutExpo",
  "ease-in-out-circ": "easeInOutCirc",
  "ease-out": "easeOut",
  "ease-out-elastic": "easeOutElastic",
  "ease-out-bounce": "easeOutBounce",
  "ease-out-sine": "easeOutSine",
  "ease-out-quad": "easeOutQuad",
  "ease-out-cubic": "easeOutCubic",
  "ease-out-back": "easeOutBack",
  "ease-out-quart": "easeOutQuart",
  "ease-out-quint": "easeOutQuint",
  "ease-out-expo": "easeOutExpo",
  "ease-out-circ": "easeOutCirc",
  "fast-out-slow-in": "fastOutSlowIn",
  "fast-out-linear-in": "fastOutLinearIn",
  "linear-out-slow-in": "linearOutSlowIn"
};
/**
 * Classe que implementa as funções de easing de Bezier
 */
var BezierEasing = /*#__PURE__*/function () {
  /**
   * Cria uma nova instância de BezierEasing com os parâmetros de controle da curva de Bezier.
   *
   * @param {number} x1 - O valor x do primeiro ponto de controle (deve estar no intervalo [0, 1])
   * @param {number} y1 - O valor y do primeiro ponto de controle
   * @param {number} x2 - O valor x do segundo ponto de controle (deve estar no intervalo [0, 1])
   * @param {number} y2 - O valor y do segundo ponto de controle
   * @throws {Error} Se os valores x1 e x2 estiverem fora do intervalo [0, 1]
   * @constructor
   */
  function BezierEasing(x1, y1, x2, y2) {
    _classCallCheck(this, BezierEasing);
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.kSplineTableSize = 11;
    this.kSampleStepSize = 1.0 / (this.kSplineTableSize - 1.0);
    this.sampleValues = typeof Float32Array === "function" ? new Float32Array(this.kSplineTableSize) : new Array(this.kSplineTableSize);
    if (!(0 <= x1 && x1 <= 1 && 0 <= x2 && x2 <= 1)) {
      throw new Error("bezier x values must be in [0, 1] range");
    }
    for (var i = 0; i < this.kSplineTableSize; ++i) {
      this.sampleValues[i] = calcBezier(i * this.kSampleStepSize, x1, x2);
    }
  }
  /**
   * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
   *
   * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
   * @returns {number} - O valor interpolado correspondente à curva de Bezier
   */
  return _createClass(BezierEasing, [{
    key: "to",
    value: function to(t) {
      if (this.x1 === this.y1 && this.x2 === this.y2) {
        return t;
      }
      var props = {
        x1: this.x1,
        y1: this.y1,
        x2: this.x2,
        y2: this.y2,
        kSplineTableSize: this.kSplineTableSize,
        kSampleStepSize: this.kSampleStepSize,
        sampleValues: this.sampleValues
      };
      return t === 0 ? 0 : t === 1 ? 1 : calcBezier(getTForX(t, props), this.y1, this.y2);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }], [{
    key: "linear",
    value: function linear(t) {
      return t;
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "elastic",
    value: function elastic(t) {
      return _elastic(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "ease",
    value: function ease(t) {
      return new BezierEasing(0.25, 0.1, 0.25, 1.0).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeIn",
    value: function easeIn(t) {
      return new BezierEasing(0.42, 0.0, 1.0, 1.0).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInElastic",
    value: function easeInElastic(t) {
      return _easeInElastic(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInBounce",
    value: function easeInBounce(t) {
      return _easeInBounce(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInExpo",
    value: function easeInExpo(t) {
      return new BezierEasing(0.95, 0.05, 0.795, 0.035).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInSine",
    value: function easeInSine(t) {
      return new BezierEasing(0.47, 0, 0.75, 0.72).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInQuad",
    value: function easeInQuad(t) {
      return new BezierEasing(0.55, 0.09, 0.68, 0.53).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInCubic",
    value: function easeInCubic(t) {
      return new BezierEasing(0.55, 0.06, 0.68, 0.19).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInBack",
    value: function easeInBack(t) {
      return new BezierEasing(0.6, -0.28, 0.74, 0.05).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInQuart",
    value: function easeInQuart(t) {
      return new BezierEasing(0.895, 0.03, 0.685, 0.22).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInQuint",
    value: function easeInQuint(t) {
      return new BezierEasing(0.755, 0.05, 0.855, 0.06).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInCirc",
    value: function easeInCirc(t) {
      return new BezierEasing(0.6, 0.04, 0.98, 0.335).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInOut",
    value: function easeInOut(t) {
      return new BezierEasing(0.42, 0.0, 0.58, 1.0).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInOutElastic",
    value: function easeInOutElastic(t) {
      return _easeInOutElastic(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInOutBounce",
    value: function easeInOutBounce(t) {
      return _easeInOutBounce(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInOutSine",
    value: function easeInOutSine(t) {
      return new BezierEasing(0.45, 0.05, 0.55, 0.95).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInOutQuad",
    value: function easeInOutQuad(t) {
      return new BezierEasing(0.46, 0.03, 0.52, 0.96).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInOutCubic",
    value: function easeInOutCubic(t) {
      return new BezierEasing(0.65, 0.05, 0.36, 1).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInOutBack",
    value: function easeInOutBack(t) {
      return new BezierEasing(0.68, -0.55, 0.27, 1.55).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInOutQuart",
    value: function easeInOutQuart(t) {
      return new BezierEasing(0.77, 0, 0.175, 1).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInOutQuint",
    value: function easeInOutQuint(t) {
      return new BezierEasing(0.86, 0, 0.07, 1).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInOutExpo",
    value: function easeInOutExpo(t) {
      return new BezierEasing(1, 0, 0, 1).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeInOutCirc",
    value: function easeInOutCirc(t) {
      return new BezierEasing(0.785, 0.135, 0.15, 0.86).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeOut",
    value: function easeOut(t) {
      return new BezierEasing(0.0, 0.0, 0.58, 1.0).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeOutElastic",
    value: function easeOutElastic(t) {
      return _easeOutElastic(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeOutBounce",
    value: function easeOutBounce(t) {
      return _easeOutBounce(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeOutSine",
    value: function easeOutSine(t) {
      return new BezierEasing(0.39, 0.58, 0.57, 1).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeOutQuad",
    value: function easeOutQuad(t) {
      return new BezierEasing(0.25, 0.46, 0.45, 0.94).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeOutCubic",
    value: function easeOutCubic(t) {
      return new BezierEasing(0.22, 0.61, 0.36, 1).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeOutBack",
    value: function easeOutBack(t) {
      return new BezierEasing(0.18, 0.89, 0.32, 1.28).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeOutQuart",
    value: function easeOutQuart(t) {
      return new BezierEasing(0.165, 0.84, 0.44, 1).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeOutQuint",
    value: function easeOutQuint(t) {
      return new BezierEasing(0.23, 1, 0.32, 1).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeOutExpo",
    value: function easeOutExpo(t) {
      return new BezierEasing(0.19, 1, 0.22, 1).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "easeOutCirc",
    value: function easeOutCirc(t) {
      return new BezierEasing(0.075, 0.82, 0.165, 1).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "fastOutSlowIn",
    value: function fastOutSlowIn(t) {
      return new BezierEasing(0.4, 0, 0.2, 1).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "fastOutLinearIn",
    value: function fastOutLinearIn(t) {
      return new BezierEasing(0.4, 0, 1, 1).to(t);
    }
    /**
     * Calcula e retorna o valor interpolado correspondente à curva de Bezier para o valor t fornecido.
     *
     * @param {number} t - O valor t para o qual a interpolação deve ser calculada (deve estar no intervalo [0, 1])
     * @returns {number} - O valor interpolado correspondente à curva de Bezier
     */
  }, {
    key: "linearOutSlowIn",
    value: function linearOutSlowIn(t) {
      return new BezierEasing(0, 0, 0.2, 1).to(t);
    }
    /**
     * Função personalizada para agendar uma animação
     * @param {Function} func - A função a ser executada a cada quadro de animação
     * @param {number} delay - Atraso inicial antes da animação começar
     * @param {number} duration - Duração total da animação
     * @param {BezierEasing | keyof typeof easingList} easing - Objeto BezierEasing ou nome de animação de easing
     * @returns {number} - ID do temporizador para cancelar a animação
     */
  }, {
    key: "setInterval",
    value: function setInterval(func) {
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
      var easing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "linear";
      var elapsed = 0;
      var timerDelay,
        start = Date.now();
      var loop = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var _a, t;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!(elapsed > duration)) {
                  _context.next = 3;
                  break;
                }
                clearTimeout(timerDelay);
                return _context.abrupt("return");
              case 3:
                t = Math.min(1, elapsed / duration);
                if (!(easing instanceof BezierEasing)) {
                  _context.next = 9;
                  break;
                }
                _context.next = 7;
                return func(easing.to(t));
              case 7:
                _context.next = 21;
                break;
              case 9:
                if (!(typeof easing === "function")) {
                  _context.next = 14;
                  break;
                }
                _context.next = 12;
                return func((_a = easing(t)) !== null && _a !== void 0 ? _a : 1);
              case 12:
                _context.next = 21;
                break;
              case 14:
                if (!(easing in easingList)) {
                  _context.next = 19;
                  break;
                }
                _context.next = 17;
                return func(BezierEasing[easingList[easing]](t));
              case 17:
                _context.next = 21;
                break;
              case 19:
                _context.next = 21;
                return func(t);
              case 21:
                elapsed = Date.now() - start;
                timerDelay = setTimeout(loop, delay - elapsed % delay);
              case 23:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        return function loop() {
          return _ref.apply(this, arguments);
        };
      }();
      loop();
      return timerDelay;
    }
  }]);
}();
exports["default"] = BezierEasing;

},{}],120:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.infoColor = exports.hslDistance = exports.negative = exports.growing = exports.watershed = exports.colorScale = exports.grayScale = exports.lighten = exports.darken = exports.blend = exports.hwbToRgb = exports.cmykToRgb = exports.hsvToRgb = exports.hslToRgb = exports.rgbToHwb = exports.rgbToCmyk = exports.rgbToHsv = exports.rgbToHsl = exports.rgbToHex = exports.hexToRgb = exports.colorNames = void 0;
exports.colorNames = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
var prependZeroIfNecessaryHelper = function prependZeroIfNecessaryHelper(a) {
  return 1 == a.length ? "0" + a : a;
};
var hexToRgb = function hexToRgb(a) {
  var b = parseInt(a.substring(1, 3), 16),
    c = parseInt(a.substring(3, 5), 16),
    d = parseInt(a.substring(5, 7), 16);
  return [b, c, d];
};
exports.hexToRgb = hexToRgb;
var rgbToHex = function rgbToHex(a, b, c) {
  if (isNaN(a) || 0 > a || 255 < a || isNaN(b) || 0 > b || 255 < b || isNaN(c) || 0 > c || 255 < c) {
    return "#000000";
  }
  return "#" + [prependZeroIfNecessaryHelper(a.toString(16)), prependZeroIfNecessaryHelper(b.toString(16)), prependZeroIfNecessaryHelper(c.toString(16))].join("");
};
exports.rgbToHex = rgbToHex;
var rgbToHsl = function rgbToHsl(a, b, c) {
  a /= 255;
  b /= 255;
  c /= 255;
  var d = Math.max(a, b, c),
    e = Math.min(a, b, c),
    f = 0,
    g = 0,
    h = 0.5 * (d + e);
  if (d != e) {
    if (d == a) {
      f = 60 * (b - c) / (d - e);
    } else if (d == b) {
      f = 60 * (c - a) / (d - e) + 120;
    } else if (d == c) {
      f = 60 * (a - b) / (d - e) + 240;
    }
  }
  g = 0 < h && 0.5 >= h ? (d - e) / (2 * h) : (d - e) / (2 - 2 * h);
  return [Math.round(f + 360) % 360, Math.round(g * 100), Math.round(h * 100)];
};
exports.rgbToHsl = rgbToHsl;
var rgbToHsv = function rgbToHsv(a, b, c) {
  var d = Math.max(Math.max(a, b), c),
    e = Math.min(Math.min(a, b), c),
    f;
  if (e == d) {
    e = a = 0;
  } else {
    f = d - e;
    e = f / d;
    a = 60 * (a == d ? (b - c) / f : b == d ? 2 + (c - a) / f : 4 + (a - b) / f);
    if (0 > a) {
      a += 360;
    } else if (360 < a) {
      a -= 360;
    }
  }
  return [Math.round(a), Math.round(e * 100), Math.round(d * 100 / 255)];
};
exports.rgbToHsv = rgbToHsv;
var rgbToCmyk = function rgbToCmyk(a, b, c) {
  var d, e, f, g, h, i, j;
  if (a == 0 && b == 0 && c == 0) {
    d = e = f = 0;
    g = 1;
  } else {
    h = 1 - a / 255;
    i = 1 - b / 255;
    j = 1 - c / 255;
    g = Math.min(h, Math.min(i, j));
    d = (h - g) / (1 - g);
    e = (i - g) / (1 - g);
    f = (j - g) / (1 - g);
  }
  return [Math.round(d * 100), Math.round(e * 100), Math.round(f * 100), Math.round(g * 100)];
};
exports.rgbToCmyk = rgbToCmyk;
var rgbToHwb = function rgbToHwb(a, b, c) {
  var d, e, f, g, h, i, j;
  h = (0, exports.rgbToHsv)(a, b, c)[0];
  a /= 255;
  b /= 255;
  c /= 255;
  f = Math.min(a, b, c);
  g = Math.max(a, b, c);
  c = 1 - g;
  if (g === f) {
    /*h = 0;*/i = Math.round(f * 100);
    j = Math.round(c * 100);
  } else {
    d = a === f ? b - c : b === f ? c - a : a - b;
    e = a === f ? 3 : b === f ? 5 : 1;
    h = Math.round((e - d / (g - f)) / 6 * 100 * 360 / 100);
    if (0 > h) {
      h += 360;
    } else if (360 < h) {
      h -= 360;
    }
    i = Math.round(f * 100);
    j = Math.round(c * 100);
  }
  return [Math.round(h), Math.round(i), Math.round(j)];
};
exports.rgbToHwb = rgbToHwb;
var hueToRgb_ = function hueToRgb_(a, b, c) {
  0 > c ? c += 1 : 1 < c && (c -= 1);
  return 1 > 6 * c ? a + 6 * (b - a) * c : 1 > 2 * c ? b : 2 > 3 * c ? a + (b - a) * (2 / 3 - c) * 6 : a;
};
var hslToRgb = function hslToRgb(a, b, c) {
  var d = 0,
    e = 0,
    f = 0,
    g;
  a /= 360;
  if (0 == b) {
    d = e = f = 255 * c;
  } else {
    g = f = 0;
    g = 0.5 > c ? c * (1 + b) : c + b - b * c;
    f = 2 * c - g;
    d = 255 * hueToRgb_(f, g, a + 1 / 3);
    e = 255 * hueToRgb_(f, g, a);
    f = 255 * hueToRgb_(f, g, a - 1 / 3);
  }
  return [Math.round(d), Math.round(e), Math.round(f)];
};
exports.hslToRgb = hslToRgb;
var hsvToRgb = function hsvToRgb(a, b_, c) {
  var r, g, b, d, e, f, h, i, k, l, m;
  if (b_ == 0) {
    r = g = b = Math.round(c * 255);
  } else {
    h = a * 6 == 6 ? 0 : a * 6;
    i = Math.floor(h);
    k = c * (1 - b_);
    l = c * (1 - b_ * (h - i));
    m = c * (1 - b_ * (1 - (h - i)));
    if (i == 0) {
      d = c;
      e = m;
      f = k;
    } else if (i == 1) {
      d = l;
      e = c;
      f = k;
    } else if (i == 2) {
      d = k;
      e = c;
      f = m;
    } else if (i == 3) {
      d = k;
      e = l;
      f = c;
    } else if (i == 4) {
      d = m;
      e = k;
      f = c;
    } else {
      d = c;
      e = k;
      f = l;
    }
    r = Math.round(d * 255);
    g = Math.round(e * 255);
    b = Math.round(f * 255);
  }
  return [r, g, b];
};
exports.hsvToRgb = hsvToRgb;
var cmykToRgb = function cmykToRgb(a, b, c, d) {
  var e = 255 * (1 - a) * (1 - d),
    f = 255 * (1 - b) * (1 - d),
    g = 255 * (1 - c) * (1 - d);
  return [Math.round(e), Math.round(f), Math.round(g)];
};
exports.cmykToRgb = cmykToRgb;
var hwbToRgb = function hwbToRgb(a, b, c) {
  var d, e, f, g, h, i, j;
  a = a * 6;
  g = 1 - c;
  j = a | 0;
  i = a - j;
  if (j & 1) {
    i = 1 - i;
  }
  h = b + i * (g - b);
  g = g * 255 | 0;
  h = h * 255 | 0;
  b = b * 255 | 0;
  if (j == 0) {
    d = g;
    e = h;
    f = b;
  } else if (j == 1) {
    d = h;
    e = g;
    f = b;
  } else if (j == 2) {
    d = b;
    e = g;
    f = h;
  } else if (j == 3) {
    d = b;
    e = h;
    f = g;
  } else if (j == 4) {
    d = h;
    e = b;
    f = g;
  } else if (j == 5) {
    d = g;
    e = b;
    f = h;
  } else {
    d = e = f = g;
  }
  return [Math.round(d), Math.round(e), Math.round(f)];
};
exports.hwbToRgb = hwbToRgb;
var blend = function blend(a, b, c) {
  c = Math.min(Math.max(c, 0), 1);
  return [Math.round(c * a[0] + (1 - c) * b[0]), Math.round(c * a[1] + (1 - c) * b[1]), Math.round(c * a[2] + (1 - c) * b[2])];
};
exports.blend = blend;
var darken = function darken(a, b) {
  return (0, exports.blend)([0, 0, 0], a, b);
};
exports.darken = darken;
var lighten = function lighten(a, b) {
  return (0, exports.blend)([255, 255, 255], a, b);
};
exports.lighten = lighten;
var grayScale = function grayScale(a) {
  var b = Math.round((a[0] + a[1] + a[2]) / 3);
  return [b, b, b];
};
exports.grayScale = grayScale;
var colorScale = function colorScale(a, b, c) {
  var s = (0, exports.grayScale)(a)[0];
  b = b == undefined ? [255, 255, 255] : b;
  c = c == undefined ? [0, 0, 0] : c;
  var d = s * 100 / 255;
  return (0, exports.blend)(b, c, d);
};
exports.colorScale = colorScale;
var watershed = function watershed(a) {
  var b = (0, exports.grayScale)(a),
    c = b[0],
    e = 255 / 2;
  if (c >= e) {
    return [255, 255, 255];
  } else {
    return [0, 0, 0];
  }
};
exports.watershed = watershed;
var growing = function growing(a) {
  var b = (0, exports.grayScale)(a),
    c = b[0];
  return (0, exports.hslToRgb)(Math.round(c * 360 / 255), 100 / 100, 50 / 100);
};
exports.growing = growing;
var negative = function negative(a) {
  return [Math.round(255 - a[0]), Math.round(255 - a[1]), Math.round(255 - a[2])];
};
exports.negative = negative;
var hslDistance = function hslDistance(a, b) {
  a = [a[0], a[1] / 100, a[2] / 100];
  b = [b[0], b[1] / 100, b[2] / 100];
  var c, d;
  c = 0.5 >= a[2] ? a[1] * a[2] : a[1] * (1 - a[2]);
  d = 0.5 >= b[2] ? b[1] * b[2] : b[1] * (1 - b[2]);
  return Math.round(((a[2] - b[2]) * (a[2] - b[2]) + c * c + d * d - 2 * c * d * Math.cos(2 * (a[0] / 360 - b[0] / 360) * Math.PI)) * 100);
};
exports.hslDistance = hslDistance;
var infoColor = function infoColor(color) {
  var result = {
      type: undefined,
      string: undefined,
      array: undefined
    },
    b,
    c,
    d,
    e;
  if (b = /^((?:rgb|hs[lv]|cmyk|hwb)a?)\s*\(([^\)]*)\)/.exec(String(color))) {
    c = b[1];
    d = c.replace(/a$/, "");
    e = d === "cmyk" ? 4 : 3;
    b[2] = b[2].replace(/^\s+|\s+$/g, "").split(/\s*,\s*/).map(function (x, i) {
      if (/%$/.test(x) && i === e) {
        return parseFloat(x) / 100;
      } else if (/%$/.test(x)) {
        return parseFloat(x);
      }
      return parseFloat(x);
    });
    result.type = d;
    result.string = color;
    result.array = b[2];
  } else if (/^#[A-Fa-f0-9]+$/.test(color)) {
    result.type = "hex";
    result.string = color;
    result.array = (0, exports.hexToRgb)(color);
  } else if (Object.keys(exports.colorNames).includes(String(color).toLowerCase())) {
    result.type = "name";
    result.string = color;
    result.array = (0, exports.hexToRgb)(exports.colorNames[color]);
  }
  return result;
};
exports.infoColor = infoColor;
var Color = /*#__PURE__*/function () {
  function Color() {
    var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "#000000";
    _classCallCheck(this, Color);
    this.value = "#000000";
    this.value = Array.isArray(color) ? exports.rgbToHex.apply(null, color) : color;
    this.info = (0, exports.infoColor)(this.value);
    this.type = this.info.type;
    var defaultProps = {
      rgb: [0, 0, 0],
      string: "#000000",
      hex: "#000000",
      hsl: [0, 0, 0],
      hsv: [0, 0, 0],
      cmyk: [0, 0, 0, 0],
      hwb: [0, 0, 0]
    };
    if (Array.isArray(this.info.array)) {
      switch (this.type) {
        case "name":
          this.props = Color.colorName(this.value);
          break;
        case "hex":
          this.props = Color.hex(this.value);
          break;
        case "rgb":
          this.props = Color.rgb.apply(null, this.info.array);
          break;
        case "hsl":
          this.props = Color.hsl.apply(null, this.info.array);
          break;
        case "cmyk":
          this.props = Color.cmyk.apply(null, this.info.array);
          break;
        case "hwb":
          this.props = Color.hwb.apply(null, this.info.array);
          break;
        case "hsv":
          this.props = Color.hsv.apply(null, this.info.array);
          break;
        default:
          this.props = defaultProps;
      }
    } else {
      this.props = defaultProps;
    }
  }
  return _createClass(Color, [{
    key: "isValidColor",
    get: function get() {
      return Color.isColor(this.value);
    }
  }, {
    key: "hex",
    get: function get() {
      return this.props.hex;
    }
  }, {
    key: "rgb",
    get: function get() {
      return "rgb(" + this.props.rgb.join(", ") + ")";
    }
  }, {
    key: "hsl",
    get: function get() {
      return "hsl(" + this.props.hsl.map(function (v, i) {
        return v + (i > 0 ? "%" : "");
      }).join(", ") + ")";
    }
  }, {
    key: "hsv",
    get: function get() {
      return "hsv(" + this.props.hsv.map(function (v, i) {
        return v + (i > 0 ? "%" : "");
      }).join(", ") + ")";
    }
  }, {
    key: "cmyk",
    get: function get() {
      return "cmyk(" + this.props.cmyk.join("%, ") + ")";
    }
  }, {
    key: "hwb",
    get: function get() {
      return "hwb(" + this.props.hsv.map(function (v, i) {
        return v + (i > 0 ? "%" : "");
      }).join(", ") + ")";
    }
  }, {
    key: "string",
    get: function get() {
      return this.props.string;
    }
  }, {
    key: "vector",
    get: function get() {
      return (0, exports.infoColor)(this.rgb).array;
    }
  }, {
    key: "distance",
    value: function distance(a) {
      return (0, exports.hslDistance)(this.props.hsl, new Color(a).props.hsl);
    }
  }, {
    key: "blend",
    value: function blend(a, b) {
      var c = (0, exports.blend)(this.props.rgb, new Color(a).props.rgb, b);
      return new Color("rgb(" + c.join(", ") + ")");
    }
  }, {
    key: "darken",
    value: function darken(a) {
      var b = (0, exports.darken)(this.props.rgb, a);
      return new Color("rgb(" + b.join(", ") + ")");
    }
  }, {
    key: "lighten",
    value: function lighten(a) {
      var b = (0, exports.lighten)(this.props.rgb, a);
      return new Color("rgb(" + b.join(", ") + ")");
    }
  }, {
    key: "grayScale",
    value: function grayScale() {
      var b = (0, exports.grayScale)(this.props.rgb);
      return new Color("rgb(" + b.join(", ") + ")");
    }
  }, {
    key: "colorScale",
    value: function colorScale(a, b) {
      var c = (0, exports.colorScale)(this.props.rgb, new Color(a == undefined ? "#ffffff" : a).props.rgb, new Color(b == undefined ? "#000000" : b).props.rgb);
      return new Color("rgb(" + c.join(", ") + ")");
    }
  }, {
    key: "watershed",
    value: function watershed() {
      var b = (0, exports.watershed)(this.props.rgb);
      return new Color("rgb(" + b.join(", ") + ")");
    }
  }, {
    key: "growing",
    value: function growing() {
      var b = (0, exports.growing)(this.props.rgb);
      return new Color("rgb(" + b.join(", ") + ")");
    }
  }, {
    key: "negative",
    value: function negative() {
      var b = (0, exports.negative)(this.props.rgb);
      return new Color("rgb(" + b.join(", ") + ")");
    }
  }], [{
    key: "blend",
    value: function blend(a, b, c) {
      return new Color(a).blend(b, c);
    }
  }, {
    key: "isColor",
    value: function isColor(color) {
      var _a;
      try {
        var b = (0, exports.infoColor)(color);
        if (["hex", "name", "rgb", "hsl", "hsv", "cmyk", "hwb", "rgba", "hsla", "hsva", "cmyka", "hwba"].includes((_a = b.type) !== null && _a !== void 0 ? _a : "")) {
          return true;
        }
      } catch (e) {
        return false;
      }
      return false;
    }
  }, {
    key: "colorName",
    value: function colorName(color) {
      var hex = exports.colorNames[color];
      var result = Color.hex(hex);
      result.string = String(color).toLowerCase();
      return result;
    }
  }, {
    key: "hex",
    value: function hex(_hex) {
      _hex = String(_hex);
      _hex = "#" == _hex.charAt(0) ? _hex : "#" + _hex;
      var hexTripletRe_ = /#(.)(.)(.)/,
        validHexColorRe_ = /^#(?:[0-9a-f]{3}){1,2}$/i,
        isValid = function isValid(a) {
          return validHexColorRe_.test(a);
        },
        normalizeHex = function normalizeHex(a) {
          if (!isValid(a)) a = "#000000";
          4 == a.length && (a = a.replace(hexTripletRe_, "#$1$1$2$2$3$3"));
          return a.toLowerCase();
        };
      _hex = normalizeHex(_hex);
      var result = Color.rgb.apply(null, (0, exports.hexToRgb)(_hex));
      result.string = _hex;
      result.hex = _hex;
      return result;
    }
  }, {
    key: "rgb",
    value: function rgb(a, b, c) {
      a = Math.round(Number(a));
      b = Math.round(Number(b));
      c = Math.round(Number(c));
      var rgb = [a, b, c];
      return {
        rgb: rgb,
        string: "rgb(" + rgb.join(", ") + ")",
        hex: (0, exports.rgbToHex)(a, b, c),
        hsl: (0, exports.rgbToHsl)(a, b, c),
        hsv: (0, exports.rgbToHsv)(a, b, c),
        cmyk: (0, exports.rgbToCmyk)(a, b, c),
        hwb: (0, exports.rgbToHwb)(a, b, c)
      };
    }
  }, {
    key: "hsl",
    value: function hsl(a, b, c) {
      a = Math.round(Number(a));
      b = Number(b) / 100;
      c = Number(c) / 100;
      var rgb = (0, exports.hslToRgb)(a, b, c);
      var result = Color.rgb.apply(null, rgb);
      result.hsl = [Math.round(a), Math.round(b * 100), Math.round(c * 100)];
      result.string = "hsl(" + result.hsl.map(function (v, i) {
        return v + (i > 0 ? "%" : "");
      }).join(", ") + ")";
      return result;
    }
  }, {
    key: "hsv",
    value: function hsv(a, b, c) {
      a = Math.round(Number(a));
      b = Number(b) / 100;
      c = Number(c) / 100;
      var rgb = (0, exports.hsvToRgb)(a, b, c);
      var result = Color.rgb.apply(null, rgb);
      result.hsv = [Math.round(a), Math.round(b * 100), Math.round(c * 100)];
      result.string = "hsv(" + result.hsv.map(function (v, i) {
        return v + (i > 0 ? "%" : "");
      }).join(", ") + ")";
      return result;
    }
  }, {
    key: "cmyk",
    value: function cmyk(a, b, c, d) {
      a = Number(a) / 100;
      b = Number(b) / 100;
      c = Number(c) / 100;
      d = Number(d) / 100;
      var rgb = (0, exports.cmykToRgb)(a, b, c, d);
      var result = Color.rgb.apply(null, rgb);
      result.cmyk = [Math.round(a * 100), Math.round(b * 100), Math.round(c * 100), Math.round(d * 100)];
      result.string = "cmyk(" + result.cmyk.join("%, ") + "%)";
      return result;
    }
  }, {
    key: "hwb",
    value: function hwb(a, b, c) {
      a = Number(a) / 360;
      b = Number(b) / 100;
      c = Number(c) / 100;
      var rgb = (0, exports.hwbToRgb)(a, b, c);
      var result = Color.rgb.apply(null, rgb);
      result.hwb = [Math.round(a * 360), Math.round(b * 100), Math.round(c * 100)];
      result.string = "hwb(" + result.hwb.map(function (v, i) {
        return v + (i > 0 ? "%" : "");
      }).join(", ") + ")";
      return result;
    }
  }]);
}();
exports["default"] = Color;

},{}],121:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var validation_1 = require("./validation");
var JSONStringify = function JSONStringify(obj) {
  var restOfDataTypes = function restOfDataTypes(value) {
    return (0, validation_1.isNumber)(value) || (0, validation_1.isString)(value) || (0, validation_1.isBoolean)(value);
  };
  var ignoreDataTypes = function ignoreDataTypes(value) {
    return (0, validation_1.isUndefined)(value) || (0, validation_1.isFunction)(value) || (0, validation_1.isSymbol)(value);
  };
  var nullDataTypes = function nullDataTypes(value) {
    return (0, validation_1.isNotNumber)(value) || (0, validation_1.isInfinity)(value) || (0, validation_1.isNull)(value);
  };
  var arrayValuesNullTypes = function arrayValuesNullTypes(value) {
    return (0, validation_1.isNotNumber)(value) || (0, validation_1.isInfinity)(value) || (0, validation_1.isNull)(value) || ignoreDataTypes(value);
  };
  var removeComma = function removeComma(str) {
    var tempArr = str.split("");
    tempArr.pop();
    return tempArr.join("");
  };
  if (ignoreDataTypes(obj)) {
    return "{}";
  }
  if ((0, validation_1.isDate)(obj)) {
    return "\"".concat(new Date(obj).toISOString(), "\"");
  }
  if (nullDataTypes(obj)) {
    return "".concat(null);
  }
  if ((0, validation_1.isSymbol)(obj)) {
    return "{}";
  }
  if (restOfDataTypes(obj)) {
    return JSON.stringify(obj);
  }
  if ((0, validation_1.isArray)(obj)) {
    var arrStr = "";
    obj.forEach(function (eachValue) {
      arrStr += arrayValuesNullTypes(eachValue) ? JSONStringify(null) : JSONStringify(eachValue);
      arrStr += ",";
    });
    return "[" + removeComma(arrStr) + "]";
  }
  if ((0, validation_1.isObject)(obj)) {
    var objStr = "";
    var objKeys = Object.keys(obj);
    objKeys.forEach(function (eachKey) {
      var eachValue = obj[eachKey];
      objStr += !ignoreDataTypes(eachValue) ? "\"".concat(eachKey, "\":").concat(JSONStringify(eachValue), ",") : "";
    });
    return "{" + removeComma(objStr) + "}";
  }
  return "{}";
};
exports["default"] = JSONStringify;

},{"./validation":129}],122:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
function runCallback(callback, data) {
  try {
    callback(data);
  } catch (err) {
    console.error("Error in subscription callback", err);
  }
}
var _subscriptions = Symbol("subscriptions");
var _oneTimeEvents = Symbol("oneTimeEvents");
var SimpleEventEmitter = /*#__PURE__*/function () {
  function SimpleEventEmitter() {
    _classCallCheck(this, SimpleEventEmitter);
    this[_subscriptions] = [];
    this[_oneTimeEvents] = new Map();
  }
  return _createClass(SimpleEventEmitter, [{
    key: "on",
    value: function on(event, callback) {
      if (this[_oneTimeEvents].has(event)) {
        runCallback(callback, this[_oneTimeEvents].get(event));
      } else {
        this[_subscriptions].push({
          event: event,
          callback: callback,
          once: false
        });
      }
      var self = this;
      return {
        stop: function stop() {
          self.off(event, callback);
        }
      };
    }
  }, {
    key: "off",
    value: function off(event, callback) {
      this[_subscriptions] = this[_subscriptions].filter(function (s) {
        return s.event !== event || callback && s.callback !== callback;
      });
      return this;
    }
  }, {
    key: "once",
    value: function once(event, callback) {
      var _this = this;
      return new Promise(function (resolve) {
        var ourCallback = function ourCallback(data) {
          resolve(data);
          callback === null || callback === void 0 ? void 0 : callback(data);
        };
        if (_this[_oneTimeEvents].has(event)) {
          runCallback(ourCallback, _this[_oneTimeEvents].get(event));
        } else {
          _this[_subscriptions].push({
            event: event,
            callback: ourCallback,
            once: true
          });
        }
      });
    }
  }, {
    key: "emit",
    value: function emit(event, data) {
      if (this[_oneTimeEvents].has(event)) {
        throw new Error("Event \"".concat(event, "\" was supposed to be emitted only once"));
      }
      for (var i = 0; i < this[_subscriptions].length; i++) {
        var s = this[_subscriptions][i];
        if (s.event !== event) {
          continue;
        }
        runCallback(s.callback, data);
        if (s.once) {
          this[_subscriptions].splice(i, 1);
          i--;
        }
      }
      return this;
    }
  }, {
    key: "emitOnce",
    value: function emitOnce(event, data) {
      if (this[_oneTimeEvents].has(event)) {
        throw new Error("Event \"".concat(event, "\" was supposed to be emitted only once"));
      }
      this.emit(event, data);
      this[_oneTimeEvents].set(event, data); // Mark event as being emitted once for future subscribers
      this.off(event); // Remove all listeners for this event, they won't fire again
      return this;
    }
  }, {
    key: "pipe",
    value: function pipe(event, eventEmitter) {
      return this.on(event, function (data) {
        eventEmitter.emit(event, data);
      });
    }
  }, {
    key: "pipeOnce",
    value: function pipeOnce(event, eventEmitter) {
      return this.once(event, function (data) {
        eventEmitter.emitOnce(event, data);
      });
    }
  }]);
}();
exports["default"] = SimpleEventEmitter;

},{}],123:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mat4 = void 0;
exports.mat4 = __importStar(require("./mat4"));

},{"./mat4":124}],124:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transpose = exports.translate = exports.str = exports.scale = exports.rotateZ = exports.rotateY = exports.rotateX = exports.rotate = exports.perspectiveFromFieldOfView = exports.perspective = exports.ortho = exports.multiply = exports.lookAt = exports.invert = exports.identity = exports.frustum = exports.fromZRotation = exports.fromYRotation = exports.fromXRotation = exports.fromTranslation = exports.fromScaling = exports.fromRotationTranslation = exports.fromRotation = exports.fromQuat = exports.determinant = exports.create = exports.copy = exports.clone = exports.adjoint = void 0;
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
var adjoint = function adjoint(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3],
    a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7],
    a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11],
    a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
};
exports.adjoint = adjoint;
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
var clone = function clone(a) {
  var out = new Float32Array(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
};
exports.clone = clone;
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
var copy = function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
};
exports.copy = copy;
/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
var create = function create() {
  var out = new Float32Array(16);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
};
exports.create = create;
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
var determinant = function determinant(a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3],
    a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7],
    a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11],
    a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15],
    b00 = a00 * a11 - a01 * a10,
    b01 = a00 * a12 - a02 * a10,
    b02 = a00 * a13 - a03 * a10,
    b03 = a01 * a12 - a02 * a11,
    b04 = a01 * a13 - a03 * a11,
    b05 = a02 * a13 - a03 * a12,
    b06 = a20 * a31 - a21 * a30,
    b07 = a20 * a32 - a22 * a30,
    b08 = a20 * a33 - a23 * a30,
    b09 = a21 * a32 - a22 * a31,
    b10 = a21 * a33 - a23 * a31,
    b11 = a22 * a33 - a23 * a32;
  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};
exports.determinant = determinant;
/**
 * Creates a matrix from a quaternion rotation.
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @returns {mat4} out
 */
var fromQuat = function fromQuat(out, q) {
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3],
    x2 = x + x,
    y2 = y + y,
    z2 = z + z,
    xx = x * x2,
    yx = y * x2,
    yy = y * y2,
    zx = z * x2,
    zy = z * y2,
    zz = z * z2,
    wx = w * x2,
    wy = w * y2,
    wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
};
exports.fromQuat = fromQuat;
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotate(dest, dest, rad, axis)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
var fromRotation = function fromRotation(out, rad, axis) {
  var s, c, t;
  var x = axis[0];
  var y = axis[1];
  var z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  if (Math.abs(len) < 0.000001) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
};
exports.fromRotation = fromRotation;
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
var fromRotationTranslation = function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
    y = q[1],
    z = q[2],
    w = q[3],
    x2 = x + x,
    y2 = y + y,
    z2 = z + z,
    xx = x * x2,
    xy = x * y2,
    xz = x * z2,
    yy = y * y2,
    yz = y * z2,
    zz = z * z2,
    wx = w * x2,
    wy = w * y2,
    wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
};
exports.fromRotationTranslation = fromRotationTranslation;
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.scale(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
var fromScaling = function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
};
exports.fromScaling = fromScaling;
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.translate(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
var fromTranslation = function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
};
exports.fromTranslation = fromTranslation;
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateX(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
var fromXRotation = function fromXRotation(out, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad);
  // Perform axis-specific matrix multiplication
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
};
exports.fromXRotation = fromXRotation;
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateY(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
var fromYRotation = function fromYRotation(out, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad);
  // Perform axis-specific matrix multiplication
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
};
exports.fromYRotation = fromYRotation;
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateZ(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
var fromZRotation = function fromZRotation(out, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad);
  // Perform axis-specific matrix multiplication
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
};
exports.fromZRotation = fromZRotation;
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
var frustum = function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left),
    tb = 1 / (top - bottom),
    nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
};
exports.frustum = frustum;
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
var identity = function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
};
exports.identity = identity;
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
var invert = function invert(out, a) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3],
    a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7],
    a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11],
    a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15],
    b00 = a00 * a11 - a01 * a10,
    b01 = a00 * a12 - a02 * a10,
    b02 = a00 * a13 - a03 * a10,
    b03 = a01 * a12 - a02 * a11,
    b04 = a01 * a13 - a03 * a11,
    b05 = a02 * a13 - a03 * a12,
    b06 = a20 * a31 - a21 * a30,
    b07 = a20 * a32 - a22 * a30,
    b08 = a20 * a33 - a23 * a30,
    b09 = a21 * a32 - a22 * a31,
    b10 = a21 * a33 - a23 * a31,
    b11 = a22 * a33 - a23 * a32,
    // Calculate the determinant
    det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
};
exports.invert = invert;
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
var lookAt = function lookAt(out, eye, center, up) {
  var x0,
    x1,
    x2,
    y0,
    y1,
    y2,
    z0,
    z1,
    z2,
    len,
    eyex = eye[0],
    eyey = eye[1],
    eyez = eye[2],
    upx = up[0],
    upy = up[1],
    upz = up[2],
    centerx = center[0],
    centery = center[1],
    centerz = center[2];
  if (Math.abs(eyex - centerx) < 0.000001 && Math.abs(eyey - centery) < 0.000001 && Math.abs(eyez - centerz) < 0.000001) {
    return (0, exports.identity)(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
};
exports.lookAt = lookAt;
/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
var multiply = function multiply(out, a, b) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3],
    a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7],
    a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11],
    a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  // Cache only the current line of the second matrix
  var b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
};
exports.multiply = multiply;
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
var ortho = function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right),
    bt = 1 / (bottom - top),
    nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
};
exports.ortho = ortho;
/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
var perspective = function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
    nf = 1 / (near - far);
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = 2 * far * near * nf;
  out[15] = 0;
  return out;
};
exports.perspective = perspective;
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
var perspectiveFromFieldOfView = function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0),
    downTan = Math.tan(fov.downDegrees * Math.PI / 180.0),
    leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0),
    rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0),
    xScale = 2.0 / (leftTan + rightTan),
    yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
};
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
var rotate = function rotate(out, a, rad, axis) {
  var x = axis[0],
    y = axis[1],
    z = axis[2],
    len = Math.sqrt(x * x + y * y + z * z),
    s,
    c,
    t,
    a00,
    a01,
    a02,
    a03,
    a10,
    a11,
    a12,
    a13,
    a20,
    a21,
    a22,
    a23,
    b00,
    b01,
    b02,
    b10,
    b11,
    b12,
    b20,
    b21,
    b22;
  if (Math.abs(len) < 0.000001) {
    return null;
  }
  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  // Construct the elements of the rotation matrix
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;
  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
};
exports.rotate = rotate;
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
var rotateX = function rotateX(out, a, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad),
    a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7],
    a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
};
exports.rotateX = rotateX;
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
var rotateY = function rotateY(out, a, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad),
    a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3],
    a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
};
exports.rotateY = rotateY;
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
var rotateZ = function rotateZ(out, a, rad) {
  var s = Math.sin(rad),
    c = Math.cos(rad),
    a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3],
    a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
};
exports.rotateZ = rotateZ;
/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
var scale = function scale(out, a, v) {
  var x = v[0],
    y = v[1],
    z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
};
exports.scale = scale;
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
var str = function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
};
exports.str = str;
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
var translate = function translate(out, a, v) {
  var x = v[0],
    y = v[1],
    z = v[2],
    a00,
    a01,
    a02,
    a03,
    a10,
    a11,
    a12,
    a13,
    a20,
    a21,
    a22,
    a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
};
exports.translate = translate;
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
var transpose = function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
      a02 = a[2],
      a03 = a[3],
      a12 = a[6],
      a13 = a[7],
      a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
};
exports.transpose = transpose;

},{}],125:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SimpleEventEmitter = exports.Ascii85 = exports.ColorUtils = exports.Color = exports.BezierEasing = exports.Base64 = exports.gl = exports.mergeClasses = exports.JSONStringify = void 0;
var JSONStringify_1 = require("./JSONStringify");
Object.defineProperty(exports, "JSONStringify", {
  enumerable: true,
  get: function get() {
    return __importDefault(JSONStringify_1)["default"];
  }
});
var mergeClasses_1 = require("./mergeClasses");
Object.defineProperty(exports, "mergeClasses", {
  enumerable: true,
  get: function get() {
    return __importDefault(mergeClasses_1)["default"];
  }
});
__exportStar(require("./mimeTypeFromBuffer"), exports);
__exportStar(require("./utils"), exports);
__exportStar(require("./validation"), exports);
exports.gl = __importStar(require("./gl"));
var Base64_1 = require("./Base64");
Object.defineProperty(exports, "Base64", {
  enumerable: true,
  get: function get() {
    return __importDefault(Base64_1)["default"];
  }
});
var BezierEasing_1 = require("./BezierEasing");
Object.defineProperty(exports, "BezierEasing", {
  enumerable: true,
  get: function get() {
    return __importDefault(BezierEasing_1)["default"];
  }
});
var Color_1 = require("./Color");
Object.defineProperty(exports, "Color", {
  enumerable: true,
  get: function get() {
    return __importDefault(Color_1)["default"];
  }
});
exports.ColorUtils = __importStar(require("./Color"));
var Ascii85_1 = require("./Ascii85");
Object.defineProperty(exports, "Ascii85", {
  enumerable: true,
  get: function get() {
    return __importDefault(Ascii85_1)["default"];
  }
});
var SimpleEventEmitter_1 = require("./SimpleEventEmitter");
Object.defineProperty(exports, "SimpleEventEmitter", {
  enumerable: true,
  get: function get() {
    return __importDefault(SimpleEventEmitter_1)["default"];
  }
});

},{"./Ascii85":117,"./Base64":118,"./BezierEasing":119,"./Color":120,"./JSONStringify":121,"./SimpleEventEmitter":122,"./gl":123,"./mergeClasses":126,"./mimeTypeFromBuffer":127,"./utils":128,"./validation":129}],126:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
var findProtoNames = function findProtoNames(i) {
  var names = [];
  var c = i.constructor;
  do {
    var n = Object.getOwnPropertyNames(c.prototype);
    names = names.concat(n.filter(function (s) {
      return s !== "constructor";
    }));
    c = Object.getPrototypeOf(c);
  } while (c.prototype);
  return names;
};
var wrapProto = function wrapProto(i) {
  var names = findProtoNames(i);
  var o = {};
  var _iterator = _createForOfIteratorHelper(names),
    _step;
  try {
    var _loop = function _loop() {
      var name = _step.value;
      if (typeof i[name] !== "function") {
        return 1; // continue
      }
      o[name] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return i[name].apply(i, args);
      };
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      if (_loop()) continue;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return o;
};
var assignProperties = function assignProperties(a, b) {
  var _loop2 = function _loop2() {
    var propName = _Object$keys[_i];
    if (a.hasOwnProperty(propName)) {
      return 1; // continue
    }
    Object.defineProperty(a, propName, {
      get: function get() {
        return b[propName];
      },
      set: function set(value) {
        b[propName] = value;
      }
    });
  };
  for (var _i = 0, _Object$keys = Object.keys(b); _i < _Object$keys.length; _i++) {
    if (_loop2()) continue;
  }
  return a;
};
var mergeClasses = function mergeClasses(a, b) {
  if (b.constructor.name === "Object") {
    return Object.assign(a, b);
  } else {
    var wrapper = wrapProto(b);
    a = assignProperties(a, b);
    return assignProperties(a, wrapper);
  }
};
exports["default"] = mergeClasses;

},{}],127:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mimeTypeFromBuffer = void 0;
var mimeTypes = {
  "ffd8ffe000104a464946": "image/jpeg",
  "89504e470d0a1a0a0000": "image/png",
  "47494638396126026f01": "image/gif",
  "52494646574f455053": "image/webp",
  "464c4946": "image/flif",
  "424d": "image/bmp",
  "49492a00": "image/tiff",
  "4d4d002a": "image/tiff",
  "49492a00100000004352": "image/tiff",
  "4d4d002a000000005200": "image/tiff",
  "654c696673": "image/x-xcf",
  "4954534608000000600000": "image/x-canon-cr2",
  "495453461a00000003000000": "image/x-canon-cr3",
  "414f4c4949": "image/vnd.ms-photo",
  "38425053": "image/vnd.adobe.photoshop",
  "3c3f78646f636d656e74": "application/x-indesign",
  "504b0304": "application/epub+zip",
  //   '504b0304': 'application/x-xpinstall',  // XPI (Firefox Add-on)
  //   '504b0304': 'application/zip',       // ZIP
  "526172211a0700cf9073": "application/x-rar-compressed",
  "504b0708": "application/x-rar-compressed",
  "504b0304140006000800": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "d0cf11e0a1b11ae10000": "application/msword",
  "25504446": "application/pdf",
  "1f8b08": "application/gzip",
  "1f9d90": "application/x-tar",
  "425a68": "application/x-bzip2",
  "377abcaf271c": "application/x-7z-compressed",
  "425a68393141524320202020202000": "application/x-7z-compressed",
  "4d534346": "application/x-apple-diskimage",
  "61726301": "application/x-apache-arrow",
  "66747970": "video/mp4",
  "4d546864": "audio/midi",
  "1a45dfa3": "video/x-matroska",
  "1a45dfa3010000000000": "video/x-matroska",
  //   '1a45dfa3010000000000': 'video/webm', // WebM
  "00000014667479706d703432": "video/webm",
  "77415645": "video/quicktime",
  //   '52494646': 'video/vnd.avi',         // AVI
  //   '52494646': 'video/x-msvideo',       // AVI
  //   '52494646': 'video/x-msvideo',       // AVI
  //   '52494646': 'video/msvideo',         // AVI
  //   '52494646': 'video/x-avi',           // AVI
  "52494646": "video/mp4",
  "524946464f4500013000": "video/mpeg",
  //   '52494646': 'video/3gpp',            // 3GP
  "fffb": "audio/mpeg",
  "fff3": "audio/mp3",
  "666675": "audio/opus",
  "4f676753": "video/ogg",
  //   '4f676753': 'audio/ogg',             // OGG (Ogg Audio)
  //   '4f676753': 'application/ogg',       // OGG (Ogg Container)
  "664c6143": "audio/x-flac",
  "41564520": "audio/ape",
  "7776706b": "audio/wavpack",
  "464f524d00": "audio/amr",
  "7f454c46": "application/x-elf",
  //   '4d5a': 'application/x-msdownload',  // EXE (Windows Executable)
  "436f6e74656e742d74797065": "application/x-shockwave-flash",
  "7b5c727466": "application/rtf",
  "0061736d": "application/wasm",
  "774f4646": "audio/x-wav",
  "d46d9d6c": "audio/x-musepack",
  "0d0a0d0a": "text/calendar",
  "42494638": "video/x-flv",
  //   '252150532d41646f6265': 'application/postscript', // PostScript
  "252150532d41646f6265": "application/eps",
  "fd377a585a00": "application/x-xz",
  "53514c69746520666f726d6174203300": "application/x-sqlite3",
  "4e45531a": "application/x-nintendo-nes-rom",
  //   '504b0304140006000800': 'application/x-google-chrome-extension', // CRX (Chrome Extension)
  //   '4d534346': 'application/vnd.ms-cab-compressed', // CAB (Microsoft Cabinet File)
  "21": "text/plain",
  "314159265359": "text/plain",
  "7801730d626260": "text/plain",
  "7865726d": "text/plain",
  "63757368000000020000": "text/plain",
  "49545346": "application/x-deb",
  //   '1f8b08': 'application/x-compress',  // COMPRESS (Compress)
  "504b030414": "application/x-compress",
  //   '504b0708': 'application/x-lzip',    // LZ (Lzip)
  //   '504b0304': 'application/x-cfb',     // CFB (Compound File Binary)
  //   '504b0304': 'application/x-mie',     // MIE (MIE)
  //   '1a45dfa3': 'application/mxf',       // MXF (Material Exchange Format)
  "0000001a667479703367706832": "video/mp2t",
  "424c5030": "application/x-blender",
  "4250473031": "image/bpg",
  "4a2d2d20": "image/j2c",
  "0000000cjp2": "image/jp2",
  "0d0a870a": "image/jpx",
  "6a5020200d0a870a": "image/jpx",
  "000000186a703268": "image/jpx",
  "6d6a703268": "image/jpm",
  "4d4a32": "image/mj2",
  //   '464f524d00': 'audio/aiff',          // AIFF (Audio Interchange File Format)
  "464f524d20": "audio/aiff",
  "3c3f786d6c": "application/xml",
  //   '3c3f786d6c': 'text/xml',            // XML (alternative)
  "7573746172": "application/tar+gzip",
  "465753": "application/x-mobipocket-ebook",
  "667479706d6f6f6d": "application/vnd.tcpdump.pcap",
  "444d5321": "audio/x-dsf",
  "4c495445": "application/x.ms.shortcut",
  "53746f7261676554696d6573": "application/x.apple.alias",
  "46575320": "application/x-mobipocket-ebook",
  "6f6c796d7075733f6772652d": "audio/opus",
  //   '47494638': 'image/apng',            // APNG
  "4f52494643": "image/x-olympus-orf",
  "49534328": "image/x-sony-arw",
  "49534344": "image/x-adobe-dng",
  "49545046": "image/x-panasonic-rw2",
  "465547464946": "image/x-fujifilm-raf",
  //   '1a45dfa3010000000000': 'video/x-m4v', // M4V
  "667479702": "video/3gpp2",
  //   '504b030414': 'application/x-esri-shape', // SHP (Esri Shapefile)
  "fff30000": "audio/aac",
  "466f726d6174203300": "audio/x-it",
  //   '4d546864': 'audio/x-m4a',           // M4A
  //   '504b0304140006000800': 'application/vnd.openxmlformats-officedocument.presentationml.presentation', // PPTX (PowerPoint)
  "44534420": "application/x-esri-shape",
  "494433": "audio/aac",
  //   '504b0304140006000800': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', // XLSX (Excel)
  //   '504b0304140006000800': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', // DOCX (Word)
  "5a4f4f20": "application/x-xz",
  "fdfd580000": "application/x-sqlite3",
  "50616e20636f6f6b696e": "image/x-icon",
  "47494638": "image/gif",
  "4649463837610111": "image/vnd.adobe.photoshop",
  "0000010000": "application/x-elf",
  "4d5a": "application/x-msdownload",
  //   '464f524d00': 'audio/x-dsf',         // DSD (Direct Stream Digital)
  //   '4c495445': 'application/x.ms.shortcut', // LNK (Windows Shortcut)
  "437265617469766520436f6d6d656e74": "application/vnd.ms-htmlhelp",
  //   '4d534346': 'application/vnd.ms-cab-compressed', // CAB (Microsoft Cabinet File)
  "415647": "model/stl",
  "6d737132": "model/3mf",
  "000001c0": "image/jxl",
  "b501": "application/zstd",
  "4a4c53": "image/jls",
  //   'd0cf11e0a1b11ae10000': 'application/x-ole-storage', // OLE (Object Linking and Embedding)
  "e3828596": "audio/x-rmf",
  "2345584548494c5": "application/vnd.ms-outlook",
  "0c6d6b6e6f74656e73": "audio/x-mid",
  //   '4d534346': 'application/java-vm',   // JAR (Java Archive)
  "1a0b617272616e673135": "application/x-arj",
  //   '1f9d90': 'application/x-iso9660-image', // ISO (International Organization for Standardization)
  "6173642020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020": "application/x-squashfs",
  "3026b2758e66cf11a6d900aa0062ce6c": "application/x-msdownload",
  "536c595845": "application/vnd.iccprofile" // ICC (International Color Consortium)
};
var mimeTypeFromBuffer = function mimeTypeFromBuffer(buffer) {
  var header = buffer.toString("hex", 0, 16);
  for (var magicNumber in mimeTypes) {
    if (header.startsWith(magicNumber)) {
      return mimeTypes[magicNumber];
    }
  }
  return "application/octet-stream";
};
exports.mimeTypeFromBuffer = mimeTypeFromBuffer;

},{}],128:[function(require,module,exports){
(function (process,global,Buffer){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.objectToUrlParams = exports.getAllUrlParams = exports.bytesToNumber = exports.numberToBytes = exports.decodeString = exports.encodeString = exports.defer = exports.getGlobalObject = exports.deepEqual = exports.safeGet = exports.contains = exports.uuidv4 = exports.asyncForEach = void 0;
var validation_1 = require("./validation");
var asyncForEach = function asyncForEach(array, callback) {
  return new Promise( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(resolve, reject) {
      var i;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            i = 0;
          case 2:
            if (!(i < array.length)) {
              _context.next = 8;
              break;
            }
            _context.next = 5;
            return callback(array[i], i, array);
          case 5:
            i++;
            _context.next = 2;
            break;
          case 8:
            resolve();
            _context.next = 14;
            break;
          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](0);
            reject(_context.t0);
          case 14:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[0, 11]]);
    }));
    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }());
};
exports.asyncForEach = asyncForEach;
function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
      v = c === "x" ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
exports.uuidv4 = uuidv4;
function contains(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
exports.contains = contains;
function safeGet(obj, key) {
  if (Object.prototype.hasOwnProperty.call(obj, key)) {
    return obj[key];
  } else {
    return undefined;
  }
}
exports.safeGet = safeGet;
/**
 * Deep equal two objects. Support Arrays and Objects.
 */
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  for (var _i = 0, _aKeys = aKeys; _i < _aKeys.length; _i++) {
    var k = _aKeys[_i];
    if (!bKeys.includes(k)) {
      return false;
    }
    var aProp = a[k];
    var bProp = b[k];
    if ((0, validation_1.isObject)(aProp) && (0, validation_1.isObject)(bProp)) {
      if (!deepEqual(aProp, bProp)) {
        return false;
      }
    } else if (aProp !== bProp) {
      return false;
    }
  }
  for (var _i2 = 0, _bKeys = bKeys; _i2 < _bKeys.length; _i2++) {
    var _k = _bKeys[_i2];
    if (!aKeys.includes(_k)) {
      return false;
    }
  }
  return true;
}
exports.deepEqual = deepEqual;
function getGlobalObject() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("Unable to locate global object.");
}
exports.getGlobalObject = getGlobalObject;
function defer(fn) {
  process.nextTick(fn);
}
exports.defer = defer;
/**
 * Converts a string to a utf-8 encoded Uint8Array
 */
function encodeString(str) {
  if (typeof TextEncoder !== "undefined") {
    // Modern browsers, Node.js v11.0.0+ (or v8.3.0+ with util.TextEncoder)
    var encoder = new TextEncoder();
    return encoder.encode(str);
  } else if (typeof Buffer === "function") {
    // Node.js
    var buf = Buffer.from(str, "utf-8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  } else {
    // Older browsers. Manually encode
    var arr = [];
    for (var i = 0; i < str.length; i++) {
      var code = str.charCodeAt(i);
      if (code > 128) {
        // Attempt simple UTF-8 conversion. See https://en.wikipedia.org/wiki/UTF-8
        if ((code & 0xd800) === 0xd800) {
          // code starts with 1101 10...: this is a 2-part utf-16 char code
          var nextCode = str.charCodeAt(i + 1);
          if ((nextCode & 0xdc00) !== 0xdc00) {
            // next code must start with 1101 11...
            throw new Error("follow-up utf-16 character does not start with 0xDC00");
          }
          i++;
          var p1 = code & 0x3ff; // Only use last 10 bits
          var p2 = nextCode & 0x3ff;
          // Create code point from these 2: (see https://en.wikipedia.org/wiki/UTF-16)
          code = 0x10000 | p1 << 10 | p2;
        }
        if (code < 2048) {
          // Use 2 bytes for 11 bit value, first byte starts with 110xxxxx (0xc0), 2nd byte with 10xxxxxx (0x80)
          var b1 = 0xc0 | code >> 6 & 0x1f; // 0xc0 = 11000000, 0x1f = 11111
          var b2 = 0x80 | code & 0x3f; // 0x80 = 10000000, 0x3f = 111111
          arr.push(b1, b2);
        } else if (code < 65536) {
          // Use 3 bytes for 16-bit value, bits per byte: 4, 6, 6
          var _b = 0xe0 | code >> 12 & 0xf; // 0xe0 = 11100000, 0xf = 1111
          var _b2 = 0x80 | code >> 6 & 0x3f; // 0x80 = 10000000, 0x3f = 111111
          var b3 = 0x80 | code & 0x3f;
          arr.push(_b, _b2, b3);
        } else if (code < 2097152) {
          // Use 4 bytes for 21-bit value, bits per byte: 3, 6, 6, 6
          var _b3 = 0xf0 | code >> 18 & 0x7; // 0xf0 = 11110000, 0x7 = 111
          var _b4 = 0x80 | code >> 12 & 0x3f; // 0x80 = 10000000, 0x3f = 111111
          var _b5 = 0x80 | code >> 6 & 0x3f; // 0x80 = 10000000, 0x3f = 111111
          var b4 = 0x80 | code & 0x3f;
          arr.push(_b3, _b4, _b5, b4);
        } else {
          throw new Error("Cannot convert character ".concat(str.charAt(i), " (code ").concat(code, ") to utf-8"));
        }
      } else {
        arr.push(code < 128 ? code : 63); // 63 = ?
      }
    }
    return new Uint8Array(arr);
  }
}
exports.encodeString = encodeString;
/**
 * Converts a utf-8 encoded buffer to string
 */
function decodeString(buffer) {
  // ArrayBuffer|
  if (typeof TextDecoder !== "undefined") {
    // Modern browsers, Node.js v11.0.0+ (or v8.3.0+ with util.TextDecoder)
    var decoder = new TextDecoder();
    if (buffer instanceof Uint8Array) {
      return decoder.decode(buffer);
    }
    var buf = Uint8Array.from(buffer);
    return decoder.decode(buf);
  } else if (typeof Buffer === "function") {
    // Node.js (v10 and below)
    if (buffer instanceof Array) {
      buffer = Uint8Array.from(buffer); // convert to typed array
    }
    if (!(buffer instanceof Buffer) && "buffer" in buffer && buffer.buffer instanceof ArrayBuffer) {
      var typedArray = buffer;
      buffer = Buffer.from(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength); // Convert typed array to node.js Buffer
    }
    if (!(buffer instanceof Buffer)) {
      throw new Error("Unsupported buffer argument");
    }
    return buffer.toString("utf-8");
  } else {
    // Older browsers. Manually decode!
    if (!(buffer instanceof Uint8Array) && "buffer" in buffer && buffer["buffer"] instanceof ArrayBuffer) {
      // Convert TypedArray to Uint8Array
      var _typedArray = buffer;
      buffer = new Uint8Array(_typedArray.buffer, _typedArray.byteOffset, _typedArray.byteLength);
    }
    if (buffer instanceof Buffer || buffer instanceof Array || buffer instanceof Uint8Array) {
      var str = "";
      for (var i = 0; i < buffer.length; i++) {
        var code = buffer[i];
        if (code > 128) {
          // Decode Unicode character
          if ((code & 0xf0) === 0xf0) {
            // 4 byte char
            var b1 = code,
              b2 = buffer[i + 1],
              b3 = buffer[i + 2],
              b4 = buffer[i + 3];
            code = (b1 & 0x7) << 18 | (b2 & 0x3f) << 12 | (b3 & 0x3f) << 6 | b4 & 0x3f;
            i += 3;
          } else if ((code & 0xe0) === 0xe0) {
            // 3 byte char
            var _b6 = code,
              _b7 = buffer[i + 1],
              _b8 = buffer[i + 2];
            code = (_b6 & 0xf) << 12 | (_b7 & 0x3f) << 6 | _b8 & 0x3f;
            i += 2;
          } else if ((code & 0xc0) === 0xc0) {
            // 2 byte char
            var _b9 = code,
              _b10 = buffer[i + 1];
            code = (_b9 & 0x1f) << 6 | _b10 & 0x3f;
            i++;
          } else {
            throw new Error("invalid utf-8 data");
          }
        }
        if (code >= 65536) {
          // Split into 2-part utf-16 char codes
          code ^= 0x10000;
          var p1 = 0xd800 | code >> 10;
          var p2 = 0xdc00 | code & 0x3ff;
          str += String.fromCharCode(p1);
          str += String.fromCharCode(p2);
        } else {
          str += String.fromCharCode(code);
        }
      }
      return str;
    } else {
      throw new Error("Unsupported buffer argument");
    }
  }
}
exports.decodeString = decodeString;
function numberToBytes(number) {
  var bytes = new Uint8Array(8);
  var view = new DataView(bytes.buffer);
  view.setFloat64(0, number);
  return _construct(Array, _toConsumableArray(bytes));
}
exports.numberToBytes = numberToBytes;
function bytesToNumber(bytes) {
  var length = Array.isArray(bytes) ? bytes.length : bytes.byteLength;
  if (length !== 8) {
    throw new TypeError("must be 8 bytes");
  }
  var bin = new Uint8Array(bytes);
  var view = new DataView(bin.buffer);
  var nr = view.getFloat64(0);
  return nr;
}
exports.bytesToNumber = bytesToNumber;
function getAllUrlParams(url) {
  var queryString = url ? url.split("?")[1] : typeof window !== "undefined" && window.location && window.location.search ? window.location.search.slice(1) : "";
  var obj = {};
  if (queryString) {
    queryString = queryString.split("#")[0];
    var arr = queryString.split("&");
    for (var i = 0; i < arr.length; i++) {
      var a = arr[i].split("=");
      var paramName = a[0];
      var paramValue = typeof a[1] === "undefined" ? true : a[1];
      paramName = paramName.toLowerCase();
      if (typeof paramValue === "string") {
        paramValue = decodeURIComponent(paramValue).toLowerCase();
      }
      if (/\[(\d+)?\]$/.test(paramName)) {
        var key = paramName.replace(/\[(\d+)?\]/, "");
        if (!obj[key]) obj[key] = [];
        if (/\[\d+\]$/.test(paramName)) {
          var index = parseInt(/\[(\d+)\]/.exec(paramName)[1]);
          obj[key][index] = paramValue;
        } else {
          obj[key].push(paramValue);
        }
      } else {
        if (!obj[paramName]) {
          obj[paramName] = paramValue;
        } else if (obj[paramName] && typeof obj[paramName] === "string") {
          obj[paramName] = [obj[paramName]];
          obj[paramName].push(paramValue);
        } else {
          obj[paramName].push(paramValue);
        }
      }
    }
  }
  return obj;
}
exports.getAllUrlParams = getAllUrlParams;
function objectToUrlParams(obj) {
  return Object.keys(obj).map(function (key) {
    var value = obj[key];
    if (Array.isArray(value)) {
      return value.map(function (val) {
        return "".concat(encodeURIComponent(key), "[]=").concat(encodeURIComponent(val));
      }).join("&");
    }
    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
  }).join("&");
}
exports.objectToUrlParams = objectToUrlParams;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./validation":129,"_process":155,"buffer":90}],129:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEmpty = exports.isUrlValid = exports.isPhoneValid = exports.isPasswordValid = exports.isEmailValid = exports.isBuffer = exports.isSymbol = exports.isFunction = exports.isUndefined = exports.isDate = exports.isInfinity = exports.isNotNumber = exports.isNull = exports.isFloat = exports.isInt = exports.isNumberValid = exports.isNumber = exports.isBoolean = exports.isString = exports.isJson = exports.isObject = exports.isTypedArray = exports.isArray = void 0;
var isArray = function isArray(value) {
  return Array.isArray(value) && _typeof(value) === "object";
};
exports.isArray = isArray;
var isTypedArray = function isTypedArray(value) {
  return _typeof(value) === "object" && ["ArrayBuffer", "Buffer", "Uint8Array", "Uint16Array", "Uint32Array", "Int8Array", "Int16Array", "Int32Array"].includes(value.constructor.name);
};
exports.isTypedArray = isTypedArray;
var isObject = function isObject(value) {
  return _typeof(value) === "object" && value !== null && !Array.isArray(value);
};
exports.isObject = isObject;
var isJson = function isJson(value) {
  try {
    var result = JSON.parse(typeof value === "string" ? value : JSON.stringify(value));
    return (0, exports.isObject)(result);
  } catch (_a) {
    return false;
  }
};
exports.isJson = isJson;
var isString = function isString(value) {
  return typeof value === "string";
};
exports.isString = isString;
var isBoolean = function isBoolean(value) {
  return typeof value === "boolean";
};
exports.isBoolean = isBoolean;
var isNumber = function isNumber(value) {
  return typeof value === "number" && Number(value) === value;
};
exports.isNumber = isNumber;
var isNumberValid = function isNumberValid(value) {
  if (typeof value === "number") return true;
  if (typeof value !== "string") return false;
  var num = parseFloat(value);
  return !isNaN(num) && isFinite(num) && /^(\-)?\d+(\.\d+)?$/.test(value);
};
exports.isNumberValid = isNumberValid;
var isInt = function isInt(value) {
  return (0, exports.isNumber)(value) && value % 1 === 0;
};
exports.isInt = isInt;
var isFloat = function isFloat(value) {
  return (0, exports.isNumber)(value) && value % 1 !== 0;
};
exports.isFloat = isFloat;
var isNull = function isNull(value) {
  return value === null && _typeof(value) === "object";
};
exports.isNull = isNull;
var isNotNumber = function isNotNumber(value) {
  return typeof value === "number" && isNaN(value);
};
exports.isNotNumber = isNotNumber;
var isInfinity = function isInfinity(value) {
  return typeof value === "number" && !isFinite(value);
};
exports.isInfinity = isInfinity;
var isDate = function isDate(value) {
  return value instanceof Date || _typeof(value) === "object" && value !== null && typeof value.getMonth === "function" || typeof value === "string" && /^\d+$/.test(value) !== true && !isNaN(Date.parse(value));
};
exports.isDate = isDate;
var isUndefined = function isUndefined(value) {
  return value === undefined && typeof value === "undefined";
};
exports.isUndefined = isUndefined;
var isFunction = function isFunction(value) {
  return typeof value === "function";
};
exports.isFunction = isFunction;
var isSymbol = function isSymbol(value) {
  return _typeof(value) === "symbol";
};
exports.isSymbol = isSymbol;
var isBuffer = function isBuffer(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};
exports.isBuffer = isBuffer;
var isEmailValid = function isEmailValid(email) {
  if (typeof email !== "string") {
    return false;
  }
  var regex = /^\b[\w\.-]+@[\w\.-]+\.\w{2,4}\b$/gi;
  return regex.test(email);
};
exports.isEmailValid = isEmailValid;
var isPasswordValid = function isPasswordValid(password) {
  if (typeof password !== "string") {
    return false;
  }
  var regex = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[a-zA-Z]).{8,}$/gm;
  return regex.test(password);
};
exports.isPasswordValid = isPasswordValid;
var isPhoneValid = function isPhoneValid(phone) {
  if (typeof phone !== "string") {
    return false;
  }
  var regex = new RegExp("^((1[1-9])|([2-9][0-9]))((3[0-9]{3}[0-9]{4})|(9?[0-9]{3}[0-9]{5}))$");
  return regex.test(String(phone).replace(/\D/gi, ""));
};
exports.isPhoneValid = isPhoneValid;
var isUrlValid = function isUrlValid(url) {
  if (typeof url !== "string") {
    return false;
  }
  var regex = /^[(http(s)?):\/\/(www\.)?a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)$/gi;
  regex = /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:[/?#]\S*)?$/i;
  return regex.test(url);
};
exports.isUrlValid = isUrlValid;
function isEmpty(obj) {
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
exports.isEmpty = isEmpty;

},{}],130:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var SimpleEventEmitter_1 = __importDefault(require("../Lib/SimpleEventEmitter"));
var NotImplementedError = /*#__PURE__*/function (_Error) {
  function NotImplementedError(name) {
    _classCallCheck(this, NotImplementedError);
    return _callSuper(this, NotImplementedError, ["".concat(name, " is not implemented")]);
  }
  _inherits(NotImplementedError, _Error);
  return _createClass(NotImplementedError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var Api = /*#__PURE__*/function (_SimpleEventEmitter_) {
  function Api() {
    _classCallCheck(this, Api);
    return _callSuper(this, Api);
  }
  /**
   * Provides statistics
   * @param options
   */
  _inherits(Api, _SimpleEventEmitter_);
  return _createClass(Api, [{
    key: "stats",
    value: function stats(options) {
      throw new NotImplementedError("stats");
    }
    /**
     * @param path
     * @param event event to subscribe to ("value", "child_added" etc)
     * @param callback callback function
     */
  }, {
    key: "subscribe",
    value: function subscribe(path, event, callback, settings) {
      throw new NotImplementedError("subscribe");
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe(path, event, callback) {
      throw new NotImplementedError("unsubscribe");
    }
  }, {
    key: "update",
    value: function update(path, updates, options) {
      throw new NotImplementedError("update");
    }
  }, {
    key: "set",
    value: function set(path, value, options) {
      throw new NotImplementedError("set");
    }
  }, {
    key: "get",
    value: function get(path, options) {
      throw new NotImplementedError("get");
    }
  }, {
    key: "transaction",
    value: function transaction(path, callback, options) {
      throw new NotImplementedError("transaction");
    }
  }, {
    key: "exists",
    value: function exists(path) {
      throw new NotImplementedError("exists");
    }
  }, {
    key: "query",
    value: function query(path, _query, options) {
      throw new NotImplementedError("query");
    }
  }, {
    key: "reflect",
    value: function reflect(path, type, args) {
      throw new NotImplementedError("reflect");
    }
  }, {
    key: "export",
    value: function _export(path, write, options) {
      throw new NotImplementedError("export");
    }
  }, {
    key: "import",
    value: function _import(path, read, options) {
      throw new NotImplementedError("import");
    }
  }, {
    key: "setSchema",
    value: function setSchema(path, schema, warnOnly) {
      throw new NotImplementedError("setSchema");
    }
  }, {
    key: "getSchema",
    value: function getSchema(path) {
      throw new NotImplementedError("getSchema");
    }
  }, {
    key: "getSchemas",
    value: function getSchemas() {
      throw new NotImplementedError("getSchemas");
    }
  }, {
    key: "validateSchema",
    value: function validateSchema(path, value, isUpdate) {
      throw new NotImplementedError("validateSchema");
    }
  }, {
    key: "getMutations",
    value: function getMutations(filter) {
      throw new NotImplementedError("getMutations");
    }
  }, {
    key: "getChanges",
    value: function getChanges(filter) {
      throw new NotImplementedError("getChanges");
    }
  }]);
}(SimpleEventEmitter_1["default"]);
exports["default"] = Api;

},{"../Lib/SimpleEventEmitter":144}],131:[function(require,module,exports){
"use strict";

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataBase = exports.DataBaseSettings = void 0;
var SimpleEventEmitter_1 = __importDefault(require("../Lib/SimpleEventEmitter"));
var reference_1 = require("./reference");
var DebugLogger_1 = __importDefault(require("../Lib/DebugLogger"));
var TypeMappings_1 = __importDefault(require("../Lib/TypeMappings"));
var DataBaseSettings = /*#__PURE__*/_createClass(function DataBaseSettings(options) {
  _classCallCheck(this, DataBaseSettings);
  /**
   * What level to use for console logging.
   * @default 'log'
   */
  this.logLevel = "log";
  /**
   * Whether to use colors in the console logs output
   * @default true
   */
  this.logColors = true;
  /**
   * @internal (for internal use)
   */
  this.info = "realtime database";
  if (_typeof(options) !== "object") {
    options = {};
  }
  if (typeof options.logLevel === "string") {
    this.logLevel = options.logLevel;
  }
  if (typeof options.logColors === "boolean") {
    this.logColors = options.logColors;
  }
  if (typeof options.info === "string") {
    this.info = options.info;
  }
});
exports.DataBaseSettings = DataBaseSettings;
var DataBase = /*#__PURE__*/function (_SimpleEventEmitter_) {
  function DataBase(dbname) {
    var _this;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, DataBase);
    _this = _callSuper(this, DataBase);
    _this._ready = false;
    options = new DataBaseSettings(options);
    _this.name = dbname;
    // Setup console logging
    _this.debug = new DebugLogger_1["default"](options.logLevel, "[".concat(dbname, "]"));
    // Setup type mapping functionality
    _this.types = new TypeMappings_1["default"](_this);
    _this.once("ready", function () {
      // console.log(`database "${dbname}" (${this.constructor.name}) is ready to use`);
      _this._ready = true;
    });
    return _this;
  }
  /**
   * Waits for the database to be ready before running your callback.
   * @param callback (optional) callback function that is called when the database is ready to be used. You can also use the returned promise.
   * @returns returns a promise that resolves when ready
   */
  _inherits(DataBase, _SimpleEventEmitter_);
  return _createClass(DataBase, [{
    key: "ready",
    value: (function () {
      var _ready = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(callback) {
        var _this2 = this;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this._ready) {
                _context.next = 3;
                break;
              }
              _context.next = 3;
              return new Promise(function (resolve) {
                return _this2.on("ready", resolve);
              });
            case 3:
              callback === null || callback === void 0 ? void 0 : callback();
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function ready(_x) {
        return _ready.apply(this, arguments);
      }
      return ready;
    }())
  }, {
    key: "isReady",
    get: function get() {
      return this._ready;
    }
    /**
     * Creates a reference to a node
     * @param path
     * @returns reference to the requested node
     */
  }, {
    key: "ref",
    value: function ref(path) {
      return new reference_1.DataReference(this, path);
    }
    /**
     * Get a reference to the root database node
     * @returns reference to root node
     */
  }, {
    key: "root",
    get: function get() {
      return this.ref("");
    }
    /**
     * Creates a query on the requested node
     * @param path
     * @returns query for the requested node
     */
  }, {
    key: "query",
    value: function query(path) {
      var ref = new reference_1.DataReference(this, path);
      return new reference_1.DataReferenceQuery(ref);
    }
  }, {
    key: "schema",
    get: function get() {
      var _this3 = this;
      return {
        get: function get(path) {
          return _this3.storage.getSchema(path);
        },
        set: function set(path, schema) {
          var warnOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          return _this3.storage.setSchema(path, schema, warnOnly);
        },
        all: function all() {
          return _this3.storage.getSchemas();
        },
        check: function check(path, value, isUpdate) {
          return _this3.storage.validateSchema(path, value, isUpdate);
        }
      };
    }
  }]);
}(SimpleEventEmitter_1["default"]);
exports.DataBase = DataBase;
exports["default"] = DataBase;

},{"../Lib/DebugLogger":136,"../Lib/SimpleEventEmitter":144,"../Lib/TypeMappings":148,"./reference":132}],132:[function(require,module,exports){
"use strict";

function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataReferenceQuery = exports.DataReferencesArray = exports.DataSnapshotsArray = exports.QueryDataRetrievalOptions = exports.DataReference = exports.DataRetrievalOptions = void 0;
var Subscription_1 = require("../Lib/Subscription");
var snapshot_1 = require("./snapshot");
var PathInfo_1 = __importDefault(require("../Lib/PathInfo"));
var ID_1 = __importDefault(require("../Lib/ID"));
var OptionalObservable_1 = require("../Lib/OptionalObservable");
var DataRetrievalOptions = /*#__PURE__*/_createClass(
/**
 * Opções para recuperação de dados, permite o carregamento seletivo de propriedades de objetos.
 */
function DataRetrievalOptions(options) {
  _classCallCheck(this, DataRetrievalOptions);
  if (!options) {
    options = {};
  }
  if (typeof options.include !== "undefined" && !(options.include instanceof Array)) {
    throw new TypeError("options.include must be an array");
  }
  if (typeof options.exclude !== "undefined" && !(options.exclude instanceof Array)) {
    throw new TypeError("options.exclude must be an array");
  }
  if (typeof options.child_objects !== "undefined" && typeof options.child_objects !== "boolean") {
    throw new TypeError("options.child_objects must be a boolean");
  }
  if (typeof options.cache_mode === "string" && !["allow", "bypass", "force"].includes(options.cache_mode)) {
    throw new TypeError("invalid value for options.cache_mode");
  }
  this.include = options.include || undefined;
  this.exclude = options.exclude || undefined;
  this.child_objects = typeof options.child_objects === "boolean" ? options.child_objects : undefined;
  this.cache_mode = typeof options.cache_mode === "string" ? options.cache_mode : typeof options.allow_cache === "boolean" ? options.allow_cache ? "allow" : "bypass" : "allow";
  this.cache_cursor = typeof options.cache_cursor === "string" ? options.cache_cursor : undefined;
});
exports.DataRetrievalOptions = DataRetrievalOptions;
var _private = Symbol("private");
var DataReference = /*#__PURE__*/function () {
  /**
   * Cria uma referência para um nó
   */
  function DataReference(db, path, vars) {
    _classCallCheck(this, DataReference);
    this.db = db;
    if (!path) {
      path = "";
    }
    path = path.replace(/^\/|\/$/g, ""); // Trim slashes
    var pathInfo = PathInfo_1["default"].get(path);
    var key = pathInfo.key;
    var callbacks = [];
    this[_private] = {
      get path() {
        return path;
      },
      get key() {
        return key;
      },
      get callbacks() {
        return callbacks;
      },
      vars: vars || {},
      context: {},
      pushed: false,
      cursor: null
    };
  }
  return _createClass(DataReference, [{
    key: "context",
    value: function context(_context) {
      var merge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var currentContext = this[_private].context;
      if (_typeof(_context) === "object") {
        var newContext = _context ? merge ? currentContext || {} : _context : {};
        if (_context) {
          // Mesclar novo com o contexto atual
          Object.keys(_context).forEach(function (key) {
            newContext[key] = _context[key];
          });
        }
        this[_private].context = newContext;
        return this;
      } else if (typeof _context === "undefined") {
        console.warn("Use snap.context() instead of snap.ref.context() to get updating context in event callbacks");
        return currentContext;
      } else {
        throw new Error("Invalid context argument");
      }
    }
    /**
     * Contém o último cursor recebido para este caminho referenciado (se o banco de dados conectado tiver o log de transações ativado).
     * Se você deseja ser notificado se esse valor mudar, adicione um manipulador com `ref.onCursor(callback)`.
     */
  }, {
    key: "cursor",
    get: function get() {
      return this[_private].cursor;
    },
    set: function set(value) {
      var _a;
      this[_private].cursor = value;
      (_a = this.onCursor) === null || _a === void 0 ? void 0 : _a.call(this, value);
    }
  }, {
    key: "isWildcardPath",
    get: function get() {
      return this.path.indexOf("*") >= 0 || this.path.indexOf("$") >= 0;
    }
    /**
     * O caminho com o qual esta instância foi criada
     */
  }, {
    key: "path",
    get: function get() {
      return this[_private].path;
    }
    /**
     * A chave ou índice deste nó
     */
  }, {
    key: "key",
    get: function get() {
      var key = this[_private].key;
      return typeof key === "number" ? "[".concat(key, "]") : key;
    }
    /**
     * Se a "chave" for um número, é um índice!
     */
  }, {
    key: "index",
    get: function get() {
      var key = this[_private].key;
      if (typeof key !== "number") {
        throw new Error("\"".concat(key, "\" is not a number"));
      }
      return key;
    }
    /**
     * Retorna uma nova referência para o pai deste nó
     */
  }, {
    key: "parent",
    get: function get() {
      var currentPath = PathInfo_1["default"].fillVariables2(this.path, this.vars);
      var info = PathInfo_1["default"].get(currentPath);
      if (info.parentPath === null) {
        return null;
      }
      return new DataReference(this.db, info.parentPath).context(this[_private].context);
    }
    /**
     * Contém valores das variáveis/curingas usadas em um caminho de assinatura se esta referência foi
     * criada por um evento ("value", "child_added", etc.), ou em um caminho de mapeamento de tipo ao serializar / instanciar objetos tipados.
     */
  }, {
    key: "vars",
    get: function get() {
      return this[_private].vars;
    }
    /**
     * Retorna uma nova referência para um nó filho
     * @param childPath Chave de filho, índice ou caminho
     * @returns Referência para o filho
     */
  }, {
    key: "child",
    value: function child(childPath) {
      childPath = typeof childPath === "number" ? childPath : childPath.replace(/^\/|\/$/g, "");
      var currentPath = PathInfo_1["default"].fillVariables2(this.path, this.vars);
      var targetPath = PathInfo_1["default"].getChildPath(currentPath, childPath);
      return new DataReference(this.db, targetPath).context(this[_private].context); //  `${this.path}/${childPath}`
    }
    /**
     * Define ou sobrescreve o valor armazenado.
     * @param value Valor a ser armazenado no banco de dados.
     * @param onComplete Callback de conclusão opcional a ser usado em vez de retornar uma promise.
     * @returns Promise que é resolvida com esta referência quando concluída.
     */
  }, {
    key: "set",
    value: (function () {
      var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(value, onComplete) {
        var _yield$this$db$storag, cursor;
        return _regeneratorRuntime().wrap(function _callee$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              if (!this.isWildcardPath) {
                _context2.next = 3;
                break;
              }
              throw new Error("Cannot set the value of wildcard path \"/".concat(this.path, "\""));
            case 3:
              if (!(this.parent === null)) {
                _context2.next = 5;
                break;
              }
              throw new Error("Cannot set the root object. Use update, or set individual child properties");
            case 5:
              if (!(typeof value === "undefined")) {
                _context2.next = 7;
                break;
              }
              throw new TypeError("Cannot store undefined value in \"/".concat(this.path, "\""));
            case 7:
              if (this.db.isReady) {
                _context2.next = 10;
                break;
              }
              _context2.next = 10;
              return this.db.ready();
            case 10:
              value = this.db.types.serialize(this.path, value);
              _context2.next = 13;
              return this.db.storage.set(this.path, value, {
                context: this[_private].context
              });
            case 13:
              _yield$this$db$storag = _context2.sent;
              cursor = _yield$this$db$storag.cursor;
              this.cursor = cursor;
              if (typeof onComplete === "function") {
                try {
                  onComplete(null, this);
                } catch (err) {
                  console.error("Error in onComplete callback:", err);
                }
              }
              _context2.next = 26;
              break;
            case 19:
              _context2.prev = 19;
              _context2.t0 = _context2["catch"](0);
              if (!(typeof onComplete === "function")) {
                _context2.next = 25;
                break;
              }
              try {
                onComplete(_context2.t0, this);
              } catch (err) {
                console.error("Error in onComplete callback:", err);
              }
              _context2.next = 26;
              break;
            case 25:
              throw _context2.t0;
            case 26:
              return _context2.abrupt("return", this);
            case 27:
            case "end":
              return _context2.stop();
          }
        }, _callee, this, [[0, 19]]);
      }));
      function set(_x, _x2) {
        return _set.apply(this, arguments);
      }
      return set;
    }()
    /**
     * Atualiza as propriedades do nó referenciado.
     * @param updates Contendo as propriedades a serem atualizadas.
     * @param onComplete Callback de conclusão opcional a ser usado em vez de retornar uma promise.
     * @return Retorna uma promise que é resolvida com esta referência quando concluída.
     */
    )
  }, {
    key: "update",
    value: (function () {
      var _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(updates, onComplete) {
        var _yield$this$db$storag2, cursor;
        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              if (!this.isWildcardPath) {
                _context3.next = 3;
                break;
              }
              throw new Error("Cannot update the value of wildcard path \"/".concat(this.path, "\""));
            case 3:
              if (this.db.isReady) {
                _context3.next = 6;
                break;
              }
              _context3.next = 6;
              return this.db.ready();
            case 6:
              if (!(_typeof(updates) !== "object" || updates instanceof Array || updates instanceof ArrayBuffer || updates instanceof Date)) {
                _context3.next = 11;
                break;
              }
              _context3.next = 9;
              return this.set(updates);
            case 9:
              _context3.next = 21;
              break;
            case 11:
              if (!(Object.keys(updates).length === 0)) {
                _context3.next = 15;
                break;
              }
              console.warn("update called on path \"/".concat(this.path, "\", but there is nothing to update"));
              _context3.next = 21;
              break;
            case 15:
              updates = this.db.types.serialize(this.path, updates);
              _context3.next = 18;
              return this.db.storage.update(this.path, updates, {
                context: this[_private].context
              });
            case 18:
              _yield$this$db$storag2 = _context3.sent;
              cursor = _yield$this$db$storag2.cursor;
              this.cursor = cursor;
            case 21:
              if (typeof onComplete === "function") {
                try {
                  onComplete(null, this);
                } catch (err) {
                  console.error("Error in onComplete callback:", err);
                }
              }
              _context3.next = 31;
              break;
            case 24:
              _context3.prev = 24;
              _context3.t0 = _context3["catch"](0);
              if (!(typeof onComplete === "function")) {
                _context3.next = 30;
                break;
              }
              try {
                onComplete(_context3.t0, this);
              } catch (err) {
                console.error("Error in onComplete callback:", err);
              }
              _context3.next = 31;
              break;
            case 30:
              throw _context3.t0;
            case 31:
              return _context3.abrupt("return", this);
            case 32:
            case "end":
              return _context3.stop();
          }
        }, _callee2, this, [[0, 24]]);
      }));
      function update(_x3, _x4) {
        return _update.apply(this, arguments);
      }
      return update;
    }()
    /**
     * Define o valor de um nó usando uma transação: executa sua função de retorno de chamada com o valor atual, utiliza seu valor de retorno como o novo valor a ser armazenado.
     * A transação é cancelada se sua função de retorno de chamada retornar undefined ou lançar um erro. Se sua função de retorno de chamada retornar null, o nó de destino será removido.
     * @param callback - Função de retorno de chamada que realiza a transação no valor atual do nó. Deve retornar o novo valor a ser armazenado (ou uma promise com o novo valor), undefined para cancelar a transação ou null para remover o nó.
     * @returns Retorna uma promise que é resolvida com a DataReference assim que a transação for processada.
     */
    )
  }, {
    key: "transaction",
    value: (function () {
      var _transaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(callback) {
        var _this = this;
        var throwError, cb, _yield$this$db$storag3, cursor;
        return _regeneratorRuntime().wrap(function _callee3$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!this.isWildcardPath) {
                _context4.next = 2;
                break;
              }
              throw new Error("Cannot start a transaction on wildcard path \"/".concat(this.path, "\""));
            case 2:
              if (this.db.isReady) {
                _context4.next = 5;
                break;
              }
              _context4.next = 5;
              return this.db.ready();
            case 5:
              cb = function cb(currentValue) {
                currentValue = _this.db.types.deserialize(_this.path, currentValue);
                var snap = new snapshot_1.DataSnapshot(_this, currentValue);
                var newValue;
                try {
                  newValue = callback(snap);
                } catch (err) {
                  // O código de retorno de chamada lançou um erro
                  throwError = err; // Lembre-se do erro
                  return; // cancela a transação retornando undefined
                }
                if (newValue instanceof Promise) {
                  return newValue.then(function (val) {
                    return _this.db.types.serialize(_this.path, val);
                  })["catch"](function (err) {
                    throwError = err; // Lembre-se do erro
                    return; // cancela a transação retornando undefined
                  });
                } else {
                  return _this.db.types.serialize(_this.path, newValue);
                }
              };
              _context4.next = 8;
              return this.db.storage.transaction(this.path, cb, {
                context: this[_private].context
              });
            case 8:
              _yield$this$db$storag3 = _context4.sent;
              cursor = _yield$this$db$storag3.cursor;
              this.cursor = cursor;
              if (!throwError) {
                _context4.next = 13;
                break;
              }
              throw throwError;
            case 13:
              return _context4.abrupt("return", this);
            case 14:
            case "end":
              return _context4.stop();
          }
        }, _callee3, this);
      }));
      function transaction(_x5) {
        return _transaction.apply(this, arguments);
      }
      return transaction;
    }())
  }, {
    key: "on",
    value: function on(event, callback, cancelCallback) {
      var _this2 = this;
      if (this.path === "" && ["value", "child_changed"].includes(event)) {
        // Removidos os eventos 'notify_value' e 'notify_child_changed' da lista, pois eles não exigem mais carregamento adicional de dados.
        console.warn("WARNING: Listening for value and child_changed events on the root node is a bad practice. These events require loading of all data (value event), or potentially lots of data (child_changed event) each time they are fired");
      }
      var eventPublisher;
      var eventStream = new Subscription_1.EventStream(function (publisher) {
        eventPublisher = publisher;
      });
      // Mapear NOSSO retorno de chamada para o retorno de chamada original, para que o .off possa remover o(s) retorno(s) de chamada certo(s)
      var cb = {
        event: event,
        stream: eventStream,
        userCallback: typeof callback === "function" ? callback : undefined,
        ourCallback: function ourCallback(err, path, newValue, oldValue, eventContext) {
          if (err) {
            // TODO: Investigar se isso realmente acontece?
            _this2.db.debug.error("Error getting data for event ".concat(event, " on path \"").concat(path, "\""), err);
            return;
          }
          var ref = _this2.db.ref(path);
          ref[_private].vars = PathInfo_1["default"].extractVariables(_this2.path, path);
          var callbackObject;
          if (event.startsWith("notify_")) {
            // No evento de dados, retorno de chamada com referência
            callbackObject = ref.context(eventContext || {});
          } else {
            var values = {
              previous: _this2.db.types.deserialize(path, oldValue),
              current: _this2.db.types.deserialize(path, newValue)
            };
            if (event === "child_removed") {
              callbackObject = new snapshot_1.DataSnapshot(ref, values.previous, true, values.previous, eventContext);
            } else if (event === "mutations") {
              callbackObject = new snapshot_1.MutationsDataSnapshot(ref, values.current, eventContext);
            } else {
              var isRemoved = event === "mutated" && values.current === null;
              callbackObject = new snapshot_1.DataSnapshot(ref, values.current, isRemoved, values.previous, eventContext);
            }
          }
          eventPublisher.publish(callbackObject);
          if (eventContext === null || eventContext === void 0 ? void 0 : eventContext.database_cursor) {
            _this2.cursor = eventContext.database_cursor;
          }
        }
      };
      this[_private].callbacks.push(cb);
      var subscribe = function subscribe() {
        // (NOVO) Adicionar retorno de chamada ao fluxo de eventos
        // ref.on('value', callback) agora é exatamente o mesmo que ref.on('value').subscribe(callback)
        if (typeof callback === "function") {
          eventStream.subscribe(callback, function (activated, cancelReason) {
            if (!activated) {
              cancelCallback && cancelCallback(cancelReason);
            }
          });
        }
        if (event === "value") {
          if (_this2.isWildcardPath) {
            var err = "Cannot get value of wildcard path \"/".concat(_this2.path, "\".");
            eventPublisher.cancel(err);
            throw new Error(err);
          }
          var cache;
          var observeSubscribe = _this2.observe().subscribe(function (value) {
            var ref = _this2.db.ref(_this2.path);
            cache = !cache ? value : cache;
            var values = {
              previous: _this2.db.types.deserialize(_this2.path, cache),
              current: _this2.db.types.deserialize(_this2.path, value)
            };
            var isRemoved = values.current === null;
            var snap = new snapshot_1.DataSnapshot(ref, values.current, isRemoved, values.previous, {});
            eventPublisher.publish(snap);
          });
          eventPublisher.start(function () {
            return observeSubscribe.unsubscribe();
          });
          return;
        }
        var advancedOptions = _typeof(callback) === "object" ? callback : {
          newOnly: !callback
        }; // newOnly: se o retorno de chamada não for 'truthy', poderia alterar isso para (typeof callback !== 'function' && callback !== true), mas isso quebraria o código do cliente que usa um argumento truthy.
        if (typeof advancedOptions.newOnly !== "boolean") {
          advancedOptions.newOnly = false;
        }
        if (_this2.isWildcardPath) {
          advancedOptions.newOnly = true;
        }
        var cancelSubscription = function cancelSubscription(err) {
          // Acesso negado?
          // Cancelar a assinatura
          var callbacks = _this2[_private].callbacks;
          callbacks.splice(callbacks.indexOf(cb), 1);
          _this2.db.storage.unsubscribe(_this2.path, event, cb.ourCallback);
          // Chamar cancelCallbacks
          _this2.db.debug.error("Subscription \"".concat(event, "\" on path \"/").concat(_this2.path, "\" canceled because of an error: ").concat(err.message));
          eventPublisher.cancel(err.message);
        };
        var authorized = _this2.db.storage.subscribe(_this2.path, event, cb.ourCallback, {
          newOnly: advancedOptions.newOnly,
          cancelCallback: cancelSubscription,
          syncFallback: advancedOptions.syncFallback
        });
        var allSubscriptionsStoppedCallback = function allSubscriptionsStoppedCallback() {
          var callbacks = _this2[_private].callbacks;
          callbacks.splice(callbacks.indexOf(cb), 1);
          return _this2.db.storage.unsubscribe(_this2.path, event, cb.ourCallback);
        };
        if (authorized instanceof Promise) {
          // A API da Web agora retorna uma promise que é resolvida se a solicitação for permitida
          // e é rejeitada quando o acesso é negado pelas regras de segurança definidas.
          authorized.then(function () {
            // Acesso concedido
            eventPublisher.start(allSubscriptionsStoppedCallback);
          })["catch"](cancelSubscription);
        } else {
          // API local, sempre autorizada
          eventPublisher.start(allSubscriptionsStoppedCallback);
        }
        if (!advancedOptions.newOnly) {
          // Se o parâmetro de retorno de chamada for fornecido (seja uma função de retorno de chamada, true ou qualquer valor truthy),
          // ele disparará eventos para os valores atuais agora.
          // Caso contrário, espera-se que o método .subscribe seja usado, que então
          // só será chamado para eventos futuros.
          // if (event === "value") {
          // 	this.get((snap) => {
          // 		eventPublisher.publish(snap);
          // 	});
          // } else
          if (event === "child_added") {
            _this2.get(function (snap) {
              var val = snap.val();
              if (val === null || _typeof(val) !== "object") {
                return;
              }
              Object.keys(val).forEach(function (key) {
                var childSnap = new snapshot_1.DataSnapshot(_this2.child(key), val[key]);
                eventPublisher.publish(childSnap);
              });
            });
          } else if (event === "notify_child_added") {
            // Use a API de reflexão para obter os filhos atuais.
            // NOTA: Isso não funciona com o IvipBase <= v0.9.7, apenas quando conectado como administrador.
            var step = 100,
              limit = step;
            var skip = 0;
            var more = /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
                var children;
                return _regeneratorRuntime().wrap(function _callee4$(_context5) {
                  while (1) switch (_context5.prev = _context5.next) {
                    case 0:
                      _context5.next = 2;
                      return _this2.db.storage.reflect(_this2.path, "children", {
                        limit: limit,
                        skip: skip
                      });
                    case 2:
                      children = _context5.sent;
                      if (children && "more" in children) {
                        children.list.forEach(function (child) {
                          var childRef = _this2.child(child.key);
                          eventPublisher.publish(childRef);
                          // typeof callback === 'function' && callback(childRef);
                        });
                        if (children.more) {
                          skip += step;
                          more();
                        }
                      }
                    case 4:
                    case "end":
                      return _context5.stop();
                  }
                }, _callee4);
              }));
              return function more() {
                return _ref.apply(this, arguments);
              };
            }();
            more();
          }
        }
      };
      if (this.db.isReady) {
        subscribe();
      } else {
        this.db.ready(subscribe);
      }
      return eventStream;
    }
  }, {
    key: "off",
    value: function off(event, callback) {
      var subscriptions = this[_private].callbacks;
      var stopSubs = subscriptions.filter(function (sub) {
        return (!event || sub.event === event) && (!callback || sub.userCallback === callback);
      });
      if (stopSubs.length === 0) {
        this.db.debug.warn("Can't find event subscriptions to stop (path: \"".concat(this.path, "\", event: ").concat(event || "(any)", ", callback: ").concat(callback, ")"));
      }
      stopSubs.forEach(function (sub) {
        sub.stream.stop();
      });
      return this;
    }
  }, {
    key: "get",
    value: function get(optionsOrCallback, callback) {
      var _this3 = this;
      if (!this.db.isReady) {
        var _promise = this.db.ready().then(function () {
          return _this3.get(optionsOrCallback, callback);
        });
        return typeof optionsOrCallback !== "function" && typeof callback !== "function" ? _promise : undefined; // retorna apenas uma promise se nenhum retorno de chamada for utilizado
      }
      callback = typeof optionsOrCallback === "function" ? optionsOrCallback : typeof callback === "function" ? callback : undefined;
      if (this.isWildcardPath) {
        var error = new Error("Cannot get value of wildcard path \"/".concat(this.path, "\". Use .query() instead"));
        if (typeof callback === "function") {
          throw error;
        }
        return Promise.reject(error);
      }
      var options = new DataRetrievalOptions(_typeof(optionsOrCallback) === "object" ? optionsOrCallback : {
        cache_mode: "allow"
      });
      var promise = this.db.storage.get(this.path, options).then(function (result) {
        var _a;
        var isNewApiResult = "context" in result && "value" in result;
        if (!isNewApiResult) {
          // A versão do pacote acebase-core foi atualizada, mas os pacotes acebase ou acebase-client não foram? Aviso, mas não lance um erro.
          console.warn("IvipBase api.get method returned an old response value. Update your acebase or acebase-client package");
          result = {
            value: result,
            context: {}
          };
        }
        var value = _this3.db.types.deserialize(_this3.path, result.value);
        var snapshot = new snapshot_1.DataSnapshot(_this3, value, undefined, undefined, result.context);
        if ((_a = result.context) === null || _a === void 0 ? void 0 : _a.database_cursor) {
          _this3.cursor = result.context.database_cursor;
        }
        return snapshot;
      });
      if (callback) {
        promise.then(callback)["catch"](function (err) {
          console.error("Uncaught error:", err);
        });
        return;
      } else {
        return promise;
      }
    }
    /**
     * Aguarda a ocorrência de um evento
     * @param event Nome do evento, por exemplo, "value", "child_added", "child_changed", "child_removed"
     * @param options Opções de recuperação de dados, para incluir ou excluir chaves específicas de filhos
     * @returns Retorna uma promise que é resolvida com uma snapshot dos dados
     */
  }, {
    key: "once",
    value: function once(event, options) {
      var _this4 = this;
      if (event === "value" && !this.isWildcardPath) {
        // Shortcut, do not start listening for future events
        return this.get(options);
      }
      return new Promise(function (resolve) {
        var callback = function callback(snap) {
          _this4.off(event, callback); // unsubscribe directly
          resolve(snap);
        };
        _this4.on(event, callback);
      });
    }
    /**
     * @param value Valor opcional para armazenar no banco de dados imediatamente
     * @param onComplete Função de retorno de chamada opcional para ser executada uma vez que o valor foi armazenado
     * @returns Retorna uma promise que é resolvida com a referência após o valor passado ter sido armazenado
     */
  }, {
    key: "push",
    value: function push(value, onComplete) {
      if (this.isWildcardPath) {
        var error = new Error("Cannot push to wildcard path \"/".concat(this.path, "\""));
        if (typeof value === "undefined" || typeof onComplete === "function") {
          throw error;
        }
        return Promise.reject(error);
      }
      var id = ID_1["default"].generate();
      var ref = this.child(id);
      ref[_private].pushed = true;
      if (typeof value !== "undefined") {
        return ref.set(value, onComplete).then(function () {
          return ref;
        });
      } else {
        return ref;
      }
    }
    /**
     * Remove este nó e todos os filhos
     */
  }, {
    key: "remove",
    value: (function () {
      var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        return _regeneratorRuntime().wrap(function _callee5$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              if (!this.isWildcardPath) {
                _context6.next = 2;
                break;
              }
              throw new Error("Cannot remove wildcard path \"/".concat(this.path, "\". Use query().remove instead"));
            case 2:
              if (!(this.parent === null)) {
                _context6.next = 4;
                break;
              }
              throw new Error("Cannot remove the root node");
            case 4:
              return _context6.abrupt("return", this.set(null));
            case 5:
            case "end":
              return _context6.stop();
          }
        }, _callee5, this);
      }));
      function remove() {
        return _remove.apply(this, arguments);
      }
      return remove;
    }()
    /**
     * Verifica rapidamente se esta referência possui um valor no banco de dados, sem retornar seus dados
     * @returns Retorna uma promise que é resolvida com um valor booleano
     */
    )
  }, {
    key: "exists",
    value: (function () {
      var _exists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        return _regeneratorRuntime().wrap(function _callee6$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              if (!this.isWildcardPath) {
                _context7.next = 2;
                break;
              }
              throw new Error("Cannot check wildcard path \"/".concat(this.path, "\" existence"));
            case 2:
              if (this.db.isReady) {
                _context7.next = 5;
                break;
              }
              _context7.next = 5;
              return this.db.ready();
            case 5:
              return _context7.abrupt("return", this.db.storage.exists(this.path));
            case 6:
            case "end":
              return _context7.stop();
          }
        }, _callee6, this);
      }));
      function exists() {
        return _exists.apply(this, arguments);
      }
      return exists;
    }()
    /**
     * Cria um objeto de consulta para o nó atual
     */
    )
  }, {
    key: "query",
    value: function query() {
      return new DataReferenceQuery(this);
    }
    /**
     * Obtém o número de filhos que este nó possui, utiliza reflexão
     */
  }, {
    key: "count",
    value: (function () {
      var _count = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var info;
        return _regeneratorRuntime().wrap(function _callee7$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.reflect("info", {
                child_count: true
              });
            case 2:
              info = _context8.sent;
              return _context8.abrupt("return", info.children.count);
            case 4:
            case "end":
              return _context8.stop();
          }
        }, _callee7, this);
      }));
      function count() {
        return _count.apply(this, arguments);
      }
      return count;
    }())
  }, {
    key: "reflect",
    value: function () {
      var _reflect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(type, args) {
        return _regeneratorRuntime().wrap(function _callee8$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              if (!this.isWildcardPath) {
                _context9.next = 2;
                break;
              }
              throw new Error("Cannot reflect on wildcard path \"/".concat(this.path, "\""));
            case 2:
              if (this.db.isReady) {
                _context9.next = 5;
                break;
              }
              _context9.next = 5;
              return this.db.ready();
            case 5:
              return _context9.abrupt("return", this.db.storage.reflect(this.path, type, args));
            case 6:
            case "end":
              return _context9.stop();
          }
        }, _callee8, this);
      }));
      function reflect(_x6, _x7) {
        return _reflect.apply(this, arguments);
      }
      return reflect;
    }()
  }, {
    key: "export",
    value: function () {
      var _export2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(write) {
        var options,
          writeFn,
          _args9 = arguments;
        return _regeneratorRuntime().wrap(function _callee9$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {
                format: "json",
                type_safe: true
              };
              if (!this.isWildcardPath) {
                _context10.next = 3;
                break;
              }
              throw new Error("Cannot export wildcard path \"/".concat(this.path, "\""));
            case 3:
              if (this.db.isReady) {
                _context10.next = 6;
                break;
              }
              _context10.next = 6;
              return this.db.ready();
            case 6:
              writeFn = typeof write === "function" ? write : write.write.bind(write);
              return _context10.abrupt("return", this.db.storage["export"](this.path, writeFn, options));
            case 8:
            case "end":
              return _context10.stop();
          }
        }, _callee9, this);
      }));
      function _export(_x8) {
        return _export2.apply(this, arguments);
      }
      return _export;
    }()
    /**
     * Importa o valor deste nó e todos os filhos
     * @param read Função que lê dados do seu fluxo
     * @param options Atualmente, o único formato suportado é json
     * @returns Retorna uma promise que é resolvida assim que todos os dados forem importados
     */
  }, {
    key: "import",
    value: (function () {
      var _import2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(read) {
        var options,
          _args10 = arguments;
        return _regeneratorRuntime().wrap(function _callee10$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              options = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {
                format: "json",
                suppress_events: false
              };
              if (!this.isWildcardPath) {
                _context11.next = 3;
                break;
              }
              throw new Error("Cannot import to wildcard path \"/".concat(this.path, "\""));
            case 3:
              if (this.db.isReady) {
                _context11.next = 6;
                break;
              }
              _context11.next = 6;
              return this.db.ready();
            case 6:
              return _context11.abrupt("return", this.db.storage["import"](this.path, read, options));
            case 7:
            case "end":
              return _context11.stop();
          }
        }, _callee10, this);
      }));
      function _import(_x9) {
        return _import2.apply(this, arguments);
      }
      return _import;
    }()
    /**
     * @param options Opções opcionais iniciais de recuperação de dados.
     * Não recomendado para uso ainda - os includes/excludes fornecidos não são aplicados às mutações recebidas,
     * ou ações de sincronização ao usar um IvipBase com banco de dados de cache.
     */
    )
  }, {
    key: "observe",
    value: function observe(options) {
      var _this5 = this;
      // options não deve ser usado ainda - não podemos prevenir/filtrar eventos de mutação em caminhos excluídos no momento
      if (options) {
        throw new Error("observe does not support data retrieval options yet");
      }
      if (this.isWildcardPath) {
        throw new Error("Cannot observe wildcard path \"/".concat(this.path, "\""));
      }
      var Observable = (0, OptionalObservable_1.getObservable)();
      return new Observable(function (observer) {
        var cache,
          resolved = false;
        var promise = Promise.all([_this5.get(options)]).then(function (_ref2) {
          var _ref3 = _slicedToArray(_ref2, 1),
            snap = _ref3[0];
          resolved = true;
          cache = snap.val();
          observer.next(cache);
        });
        var updateCache = function updateCache(snap) {
          if (!resolved) {
            promise = promise.then(function () {
              return updateCache(snap);
            });
            return;
          }
          var mutatedPath = snap.ref.path;
          if (mutatedPath === _this5.path) {
            cache = snap.val();
            return observer.next(cache);
          }
          var trailKeys = PathInfo_1["default"].getPathKeys(mutatedPath).slice(PathInfo_1["default"].getPathKeys(_this5.path).length);
          var target = cache;
          while (trailKeys.length > 1) {
            var key = trailKeys.shift();
            if (typeof key === "string" || typeof key === "number") {
              if (!(key in target)) {
                // Ocorre se os dados carregados inicialmente não incluíram / excluíram esses dados,
                // ou se perdemos um evento
                target[key] = typeof trailKeys[0] === "number" ? [] : {};
              }
              target = target[key];
            }
          }
          var prop = trailKeys.shift();
          var newValue = snap.val();
          if (typeof prop === "string" || typeof prop === "number") {
            if (newValue === null) {
              // Remova isso
              target instanceof Array && typeof prop === "number" ? target.splice(prop, 1) : delete target[prop];
            } else {
              // Defina ou atualize isso
              target[prop] = newValue;
            }
          }
          observer.next(cache);
        };
        _this5.on("mutated", updateCache); // TODO: Refatorar para o evento 'mutations' em vez disso
        // Retornar a função de cancelamento da inscrição
        return function () {
          _this5.off("mutated", updateCache);
        };
      });
    }
  }, {
    key: "forEach",
    value: function () {
      var _forEach = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(callbackOrOptions, callback) {
        var options, _yield$this$reflect, children, summary, i, key, snapshot, result;
        return _regeneratorRuntime().wrap(function _callee11$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              if (typeof callbackOrOptions === "function") {
                callback = callbackOrOptions;
              } else {
                options = callbackOrOptions;
              }
              if (!(typeof callback !== "function")) {
                _context12.next = 3;
                break;
              }
              throw new TypeError("No callback function given");
            case 3:
              _context12.next = 5;
              return this.reflect("children", {
                limit: 0,
                skip: 0
              });
            case 5:
              _yield$this$reflect = _context12.sent;
              children = _yield$this$reflect.children;
              // Obtém TODAS as chaves dos filhos
              summary = {
                canceled: false,
                total: children && "list" in children ? children === null || children === void 0 ? void 0 : children.list.length : 0,
                processed: 0
              }; // Iterar por todos os filhos até que a função de retorno de chamada retorne false
              if (!(children && "list" in children)) {
                _context12.next = 27;
                break;
              }
              i = 0;
            case 10:
              if (!(i < children.list.length)) {
                _context12.next = 27;
                break;
              }
              key = children.list[i].key; // Obter dados do filho
              _context12.next = 14;
              return this.child(key).get(options);
            case 14:
              snapshot = _context12.sent;
              summary.processed++;
              if (!(!snapshot || !snapshot.exists())) {
                _context12.next = 18;
                break;
              }
              return _context12.abrupt("continue", 24);
            case 18:
              _context12.next = 20;
              return callback(snapshot);
            case 20:
              result = _context12.sent;
              if (!(result === false)) {
                _context12.next = 24;
                break;
              }
              summary.canceled = true;
              return _context12.abrupt("break", 27);
            case 24:
              i++;
              _context12.next = 10;
              break;
            case 27:
              return _context12.abrupt("return", summary);
            case 28:
            case "end":
              return _context12.stop();
          }
        }, _callee11, this);
      }));
      function forEach(_x10, _x11) {
        return _forEach.apply(this, arguments);
      }
      return forEach;
    }()
  }, {
    key: "getMutations",
    value: function () {
      var _getMutations = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(cursorOrDate) {
        var cursor, timestamp;
        return _regeneratorRuntime().wrap(function _callee12$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              cursor = typeof cursorOrDate === "string" ? cursorOrDate : undefined;
              timestamp = cursorOrDate === null || typeof cursorOrDate === "undefined" ? 0 : cursorOrDate instanceof Date ? cursorOrDate.getTime() : Date.now();
              return _context13.abrupt("return", this.db.storage.getMutations({
                path: this.path,
                cursor: cursor,
                timestamp: timestamp
              }));
            case 3:
            case "end":
              return _context13.stop();
          }
        }, _callee12, this);
      }));
      function getMutations(_x12) {
        return _getMutations.apply(this, arguments);
      }
      return getMutations;
    }()
  }, {
    key: "getChanges",
    value: function () {
      var _getChanges = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(cursorOrDate) {
        var cursor, timestamp;
        return _regeneratorRuntime().wrap(function _callee13$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              cursor = typeof cursorOrDate === "string" ? cursorOrDate : undefined;
              timestamp = cursorOrDate === null || typeof cursorOrDate === "undefined" ? 0 : cursorOrDate instanceof Date ? cursorOrDate.getTime() : Date.now();
              return _context14.abrupt("return", this.db.storage.getChanges({
                path: this.path,
                cursor: cursor,
                timestamp: timestamp
              }));
            case 3:
            case "end":
              return _context14.stop();
          }
        }, _callee13, this);
      }));
      function getChanges(_x13) {
        return _getChanges.apply(this, arguments);
      }
      return getChanges;
    }()
  }]);
}();
exports.DataReference = DataReference;
var QueryDataRetrievalOptions = /*#__PURE__*/function (_DataRetrievalOptions) {
  /**
   * @param options Opções para recuperação de dados, permite o carregamento seletivo de propriedades de objeto
   */
  function QueryDataRetrievalOptions(options) {
    var _this6;
    _classCallCheck(this, QueryDataRetrievalOptions);
    _this6 = _callSuper(this, QueryDataRetrievalOptions, [options]);
    if (!["undefined", "boolean"].includes(_typeof(options.snapshots))) {
      throw new TypeError("options.snapshots must be a boolean");
    }
    _this6.snapshots = typeof options.snapshots === "boolean" ? options.snapshots : true;
    return _this6;
  }
  _inherits(QueryDataRetrievalOptions, _DataRetrievalOptions);
  return _createClass(QueryDataRetrievalOptions);
}(DataRetrievalOptions);
exports.QueryDataRetrievalOptions = QueryDataRetrievalOptions;
var DataSnapshotsArray = /*#__PURE__*/function (_Array) {
  function DataSnapshotsArray() {
    _classCallCheck(this, DataSnapshotsArray);
    return _callSuper(this, DataSnapshotsArray, arguments);
  }
  _inherits(DataSnapshotsArray, _Array);
  return _createClass(DataSnapshotsArray, [{
    key: "getValues",
    value: function getValues() {
      return this.map(function (snap) {
        return snap.val();
      });
    }
  }], [{
    key: "from",
    value: function from(snaps) {
      var arr = new DataSnapshotsArray(snaps.length);
      snaps.forEach(function (snap, i) {
        return arr[i] = snap;
      });
      return arr;
    }
  }]);
}( /*#__PURE__*/_wrapNativeSuper(Array));
exports.DataSnapshotsArray = DataSnapshotsArray;
var DataReferencesArray = /*#__PURE__*/function (_Array2) {
  function DataReferencesArray() {
    _classCallCheck(this, DataReferencesArray);
    return _callSuper(this, DataReferencesArray, arguments);
  }
  _inherits(DataReferencesArray, _Array2);
  return _createClass(DataReferencesArray, [{
    key: "getPaths",
    value: function getPaths() {
      return this.map(function (ref) {
        return ref.path;
      });
    }
  }], [{
    key: "from",
    value: function from(refs) {
      var arr = new DataReferencesArray(refs.length);
      refs.forEach(function (ref, i) {
        return arr[i] = ref;
      });
      return arr;
    }
  }]);
}( /*#__PURE__*/_wrapNativeSuper(Array));
exports.DataReferencesArray = DataReferencesArray;
var DataReferenceQuery = /*#__PURE__*/function () {
  /**
   * Cria uma consulta em uma referência
   */
  function DataReferenceQuery(ref) {
    _classCallCheck(this, DataReferenceQuery);
    this.ref = ref;
    this[_private] = {
      filters: [],
      skip: 0,
      take: 0,
      order: [],
      events: {}
    };
  }
  /**
   * Aplica um filtro aos filhos da referência sendo consultada.
   * Se houver um índice na chave da propriedade que está sendo consultada, ele será usado
   * para acelerar a consulta.
   * @param key Propriedade para testar o valor
   * @param op Operador a ser usado
   * @param compare Valor a ser comparado
   */
  return _createClass(DataReferenceQuery, [{
    key: "filter",
    value: function filter(key, op, compare) {
      if ((op === "in" || op === "!in") && (!(compare instanceof Array) || compare.length === 0)) {
        throw new Error("".concat(op, " filter for ").concat(key, " must supply an Array compare argument containing at least 1 value"));
      }
      if ((op === "between" || op === "!between") && (!(compare instanceof Array) || compare.length !== 2)) {
        throw new Error("".concat(op, " filter for ").concat(key, " must supply an Array compare argument containing 2 values"));
      }
      if ((op === "matches" || op === "!matches") && !(compare instanceof RegExp)) {
        throw new Error("".concat(op, " filter for ").concat(key, " must supply a RegExp compare argument"));
      }
      // DISABLED 2019/10/23 because it is not fully implemented only works locally
      // if (op === "custom" && typeof compare !== "function") {
      //     throw `${op} filter for ${key} must supply a Function compare argument`;
      // }
      // DISABLED 2022/08/15, implemented by query.ts in acebase
      // if ((op === 'contains' || op === '!contains') && ((typeof compare === 'object' && !(compare instanceof Array) && !(compare instanceof Date)) || (compare instanceof Array && compare.length === 0))) {
      //     throw new Error(`${op} filter for ${key} must supply a simple value or (non-zero length) array compare argument`);
      // }
      this[_private].filters.push({
        key: key,
        op: op,
        compare: compare
      });
      return this;
    }
    /**
     * @deprecated use `.filter` instead
     */
  }, {
    key: "where",
    value: function where(key, op, compare) {
      return this.filter(key, op, compare);
    }
    /**
     * Limits the number of query results
     */
  }, {
    key: "take",
    value: function take(n) {
      this[_private].take = n;
      return this;
    }
    /**
     * Skips the first n query results
     */
  }, {
    key: "skip",
    value: function skip(n) {
      this[_private].skip = n;
      return this;
    }
  }, {
    key: "sort",
    value: function sort(key) {
      var ascending = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (!["string", "number"].includes(_typeof(key))) {
        throw "key must be a string or number";
      }
      this[_private].order.push({
        key: key,
        ascending: ascending
      });
      return this;
    }
    /**
     * @deprecated use `.sort` instead
     */
  }, {
    key: "order",
    value: function order(key) {
      var ascending = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return this.sort(key, ascending);
    }
  }, {
    key: "get",
    value: function get(optionsOrCallback, callback) {
      var _this7 = this;
      if (!this.ref.db.isReady) {
        var promise = this.ref.db.ready().then(function () {
          return _this7.get(optionsOrCallback, callback);
        });
        return typeof optionsOrCallback !== "function" && typeof callback !== "function" ? promise : undefined; // only return promise if no callback is used
      }
      callback = typeof optionsOrCallback === "function" ? optionsOrCallback : typeof callback === "function" ? callback : undefined;
      var options = new QueryDataRetrievalOptions(_typeof(optionsOrCallback) === "object" ? optionsOrCallback : {
        snapshots: true,
        cache_mode: "allow"
      });
      options.allow_cache = options.cache_mode !== "bypass"; // Backward compatibility when using older acebase-client
      options.eventHandler = function (ev) {
        // TODO: implement context for query events
        if (!_this7[_private].events[ev.name]) {
          return false;
        }
        var listeners = _this7[_private].events[ev.name];
        if (_typeof(listeners) !== "object" || listeners.length === 0) {
          return false;
        }
        if (["add", "change", "remove"].includes(ev.name)) {
          var eventData = {
            name: ev.name,
            ref: new DataReference(_this7.ref.db, ev.path)
          };
          if (eventData.ref && options.snapshots && ev.name !== "remove") {
            var val = db.types.deserialize(ev.path, ev.value);
            eventData.snapshot = new snapshot_1.DataSnapshot(eventData.ref, val, false);
          }
          ev = eventData;
        }
        listeners.forEach(function (callback) {
          var _a, _b;
          try {
            callback(ev);
          } catch (err) {
            _this7.ref.db.debug.error("Error executing \"".concat(ev.name, "\" event handler of realtime query on path \"").concat(_this7.ref.path, "\": ").concat((_b = (_a = err === null || err === void 0 ? void 0 : err.stack) !== null && _a !== void 0 ? _a : err === null || err === void 0 ? void 0 : err.message) !== null && _b !== void 0 ? _b : err));
          }
        });
      };
      // Check if there are event listeners set for realtime changes
      options.monitor = {
        add: false,
        change: false,
        remove: false
      };
      if (this[_private].events) {
        if (this[_private].events["add"] && this[_private].events["add"].length > 0) {
          options.monitor.add = true;
        }
        if (this[_private].events["change"] && this[_private].events["change"].length > 0) {
          options.monitor.change = true;
        }
        if (this[_private].events["remove"] && this[_private].events["remove"].length > 0) {
          options.monitor.remove = true;
        }
      }
      // Interrompe os resultados em tempo real se ainda estiverem habilitados em um .get anterior nesta instância
      this.stop();
      // NOTA: retorna uma promise aqui, independentemente do argumento de retorno de chamada. Bom argumento para refatorar o método para async/await em breve
      var db = this.ref.db;
      return db.storage.query(this.ref.path, this[_private], options)["catch"](function (err) {
        throw new Error(err);
      }).then(function (res) {
        var stop = res.stop;
        var results = res.results,
          context = res.context;
        _this7.stop = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
          return _regeneratorRuntime().wrap(function _callee14$(_context15) {
            while (1) switch (_context15.prev = _context15.next) {
              case 0:
                _context15.next = 2;
                return stop();
              case 2:
              case "end":
                return _context15.stop();
            }
          }, _callee14);
        }));
        if (!("results" in res && "context" in res)) {
          console.warn("Query results missing context. Update your acebase and/or acebase-client packages");
          results = res, context = {};
        }
        if (options.snapshots) {
          var snaps = results.map(function (result) {
            var val = db.types.deserialize(result.path, result.val);
            return new snapshot_1.DataSnapshot(db.ref(result.path), val, false, undefined, context);
          });
          return DataSnapshotsArray.from(snaps);
        } else {
          var refs = results.map(function (path) {
            return db.ref(path);
          });
          return DataReferencesArray.from(refs);
        }
      }).then(function (results) {
        callback && callback(results);
        return results;
      });
    }
    /**
     * Stops a realtime query, no more notifications will be received.
     */
  }, {
    key: "stop",
    value: (function () {
      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
        return _regeneratorRuntime().wrap(function _callee15$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
            case "end":
              return _context16.stop();
          }
        }, _callee15);
      }));
      function stop() {
        return _stop.apply(this, arguments);
      }
      return stop;
    }()
    /**
     * Executes the query and returns references. Short for `.get({ snapshots: false })`
     * @param callback callback to use instead of returning a promise
     * @returns returns an Promise that resolves with an array of DataReferences, or void when using a callback
     * @deprecated Use `find` instead
     */
    )
  }, {
    key: "getRefs",
    value: function getRefs(callback) {
      return this.get({
        snapshots: false
      }, callback);
    }
    /**
     * Executes the query and returns an array of references. Short for `.get({ snapshots: false })`
     */
  }, {
    key: "find",
    value: function find() {
      return this.get({
        snapshots: false
      });
    }
    /**
     * Executes the query and returns the number of results
     */
  }, {
    key: "count",
    value: (function () {
      var _count2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
        var refs;
        return _regeneratorRuntime().wrap(function _callee16$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 2;
              return this.find();
            case 2:
              refs = _context17.sent;
              return _context17.abrupt("return", refs.length);
            case 4:
            case "end":
              return _context17.stop();
          }
        }, _callee16, this);
      }));
      function count() {
        return _count2.apply(this, arguments);
      }
      return count;
    }()
    /**
     * Executes the query and returns if there are any results
     */
    )
  }, {
    key: "exists",
    value: (function () {
      var _exists2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
        var originalTake, p, refs;
        return _regeneratorRuntime().wrap(function _callee17$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              originalTake = this[_private].take;
              p = this.take(1).find();
              this.take(originalTake);
              _context18.next = 5;
              return p;
            case 5:
              refs = _context18.sent;
              return _context18.abrupt("return", refs.length !== 0);
            case 7:
            case "end":
              return _context18.stop();
          }
        }, _callee17, this);
      }));
      function exists() {
        return _exists2.apply(this, arguments);
      }
      return exists;
    }()
    /**
     * Executes the query, removes all matches from the database
     * @returns returns a Promise that resolves once all matches have been removed
     */
    )
  }, {
    key: "remove",
    value: (function () {
      var _remove2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(callback) {
        var refs, parentUpdates, db, promises, results;
        return _regeneratorRuntime().wrap(function _callee19$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return this.find();
            case 2:
              refs = _context20.sent;
              // Perform updates on each distinct parent collection (only 1 parent if this is not a wildcard path)
              parentUpdates = refs.reduce(function (parents, ref) {
                if (ref.parent) {
                  var parent = parents[ref.parent.path];
                  if (!parent) {
                    parents[ref.parent.path] = [ref];
                  } else {
                    parent.push(ref);
                  }
                }
                return parents;
              }, {});
              db = this.ref.db;
              promises = Object.keys(parentUpdates).map( /*#__PURE__*/function () {
                var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(parentPath) {
                  var updates, ref;
                  return _regeneratorRuntime().wrap(function _callee18$(_context19) {
                    while (1) switch (_context19.prev = _context19.next) {
                      case 0:
                        updates = refs.reduce(function (updates, ref) {
                          updates[ref.key] = null;
                          return updates;
                        }, {});
                        ref = db.ref(parentPath);
                        _context19.prev = 2;
                        _context19.next = 5;
                        return ref.update(updates);
                      case 5:
                        return _context19.abrupt("return", {
                          ref: ref,
                          success: true
                        });
                      case 8:
                        _context19.prev = 8;
                        _context19.t0 = _context19["catch"](2);
                        return _context19.abrupt("return", {
                          ref: ref,
                          success: false,
                          error: _context19.t0
                        });
                      case 11:
                      case "end":
                        return _context19.stop();
                    }
                  }, _callee18, null, [[2, 8]]);
                }));
                return function (_x15) {
                  return _ref5.apply(this, arguments);
                };
              }());
              _context20.next = 8;
              return Promise.all(promises);
            case 8:
              results = _context20.sent;
              callback && callback(results);
              return _context20.abrupt("return", results);
            case 11:
            case "end":
              return _context20.stop();
          }
        }, _callee19, this);
      }));
      function remove(_x14) {
        return _remove2.apply(this, arguments);
      }
      return remove;
    }())
  }, {
    key: "on",
    value: function on(event, callback) {
      if (!this[_private].events[event]) {
        this[_private].events[event] = [];
      }
      this[_private].events[event].push(callback);
      return this;
    }
    /**
     * Unsubscribes from (a) previously added event(s)
     * @param event Name of the event
     * @param callback callback function to remove
     * @returns returns reference to this query
     */
  }, {
    key: "off",
    value: function off(event, callback) {
      if (typeof event === "undefined") {
        this[_private].events = {};
        return this;
      }
      if (!this[_private].events[event]) {
        return this;
      }
      if (typeof callback === "undefined") {
        delete this[_private].events[event];
        return this;
      }
      var index = this[_private].events[event].indexOf(callback);
      if (!~index) {
        return this;
      }
      this[_private].events[event].splice(index, 1);
      return this;
    }
  }, {
    key: "forEach",
    value: function () {
      var _forEach2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(callbackOrOptions, callback) {
        var options, refs, summary, i, ref, snapshot, result;
        return _regeneratorRuntime().wrap(function _callee20$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              if (typeof callbackOrOptions === "function") {
                callback = callbackOrOptions;
              } else {
                options = callbackOrOptions;
              }
              if (!(typeof callback !== "function")) {
                _context21.next = 3;
                break;
              }
              throw new TypeError("No callback function given");
            case 3:
              _context21.next = 5;
              return this.find();
            case 5:
              refs = _context21.sent;
              summary = {
                canceled: false,
                total: refs.length,
                processed: 0
              }; // Iterate through all children until callback returns false
              i = 0;
            case 8:
              if (!(i < refs.length)) {
                _context21.next = 25;
                break;
              }
              ref = refs[i]; // Get child data
              _context21.next = 12;
              return ref.get(options);
            case 12:
              snapshot = _context21.sent;
              summary.processed++;
              if (!(!snapshot || !snapshot.exists())) {
                _context21.next = 16;
                break;
              }
              return _context21.abrupt("continue", 22);
            case 16:
              _context21.next = 18;
              return callback(snapshot);
            case 18:
              result = _context21.sent;
              if (!(result === false)) {
                _context21.next = 22;
                break;
              }
              summary.canceled = true;
              return _context21.abrupt("break", 25);
            case 22:
              i++;
              _context21.next = 8;
              break;
            case 25:
              return _context21.abrupt("return", summary);
            case 26:
            case "end":
              return _context21.stop();
          }
        }, _callee20, this);
      }));
      function forEach(_x16, _x17) {
        return _forEach2.apply(this, arguments);
      }
      return forEach;
    }()
  }]);
}();
exports.DataReferenceQuery = DataReferenceQuery;

},{"../Lib/ID":137,"../Lib/OptionalObservable":139,"../Lib/PathInfo":141,"../Lib/Subscription":146,"./snapshot":133}],133:[function(require,module,exports){
"use strict";

function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MutationsDataSnapshot = exports.DataSnapshot = void 0;
var PathInfo_1 = __importDefault(require("../Lib/PathInfo"));
function getChild(snapshot, path) {
  var previous = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (!snapshot.exists()) {
    return null;
  }
  var child = previous ? snapshot.previous() : snapshot.val();
  if (typeof path === "number") {
    return child[path];
  }
  PathInfo_1["default"].getPathKeys(path).every(function (key) {
    child = child[key];
    return typeof child !== "undefined";
  });
  return child || null;
}
function getChildren(snapshot) {
  if (!snapshot.exists()) {
    return [];
  }
  var value = snapshot.val();
  if (value instanceof Array) {
    return new Array(value.length).map(function (v, i) {
      return i;
    });
  }
  if (_typeof(value) === "object") {
    return Object.keys(value);
  }
  return [];
}
var DataSnapshot = /*#__PURE__*/function () {
  /**
   * Cria uma nova instância do DataSnapshot
   */
  function DataSnapshot(ref, value) {
    var isRemoved = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var prevValue = arguments.length > 3 ? arguments[3] : undefined;
    var context = arguments.length > 4 ? arguments[4] : undefined;
    _classCallCheck(this, DataSnapshot);
    this.ref = ref;
    this.val = function () {
      return value;
    };
    this.previous = function () {
      return prevValue;
    };
    this.exists = function () {
      if (isRemoved) {
        return false;
      }
      return value !== null && typeof value !== "undefined";
    };
    this.context = function () {
      return context || {};
    };
  }
  /**
   * Cria uma instância `DataSnapshot`
   * @internal (para uso interno)
   */
  return _createClass(DataSnapshot, [{
    key: "exists",
    value:
    /**
     * Indica se o nó existe no banco de dados
     */
    function exists() {
      return false;
    }
  }, {
    key: "child",
    value: function child(path) {
      // Create new snapshot for child data
      var val = getChild(this, path, false);
      var prev = getChild(this, path, true);
      return new DataSnapshot(this.ref.child(path), val, false, prev);
    }
    /**
     * Verifica se o valor do instantâneo tem um filho com a chave ou caminho fornecido
     * @param path chave filho ou caminho
     */
  }, {
    key: "hasChild",
    value: function hasChild(path) {
      return getChild(this, path) !== null;
    }
    /**
     * Indica se o valor do instantâneo tem algum nó filho
     */
  }, {
    key: "hasChildren",
    value: function hasChildren() {
      return getChildren(this).length > 0;
    }
    /**
     * O número de nós filhos neste instantâneo
     */
  }, {
    key: "numChildren",
    value: function numChildren() {
      return getChildren(this).length;
    }
    /**
     * Executa uma função de retorno de chamada para cada nó filho neste instantâneo até que o retorno de chamada retorne falso
     * @param callback Função de retorno de chamada com um instantâneo de cada nó filho neste instantâneo.
     * Deve retornar um valor booleano que indica se a iteração deve continuar ou não.
     */
  }, {
    key: "forEach",
    value: function forEach(callback) {
      var _this = this;
      var _a, _b;
      var value = (_a = this.val()) !== null && _a !== void 0 ? _a : {};
      var prev = (_b = this.previous()) !== null && _b !== void 0 ? _b : {};
      return getChildren(this).every(function (key) {
        var snap = new DataSnapshot(_this.ref.child(key), value[key], false, prev[key]);
        return callback(snap);
      });
    }
    /**
     * A chave do caminho do nó
     */
  }, {
    key: "key",
    get: function get() {
      return this.ref.key;
    }
  }], [{
    key: "for",
    value: function _for(ref, value) {
      return new DataSnapshot(ref, value);
    }
  }]);
}();
exports.DataSnapshot = DataSnapshot;
var MutationsDataSnapshot = /*#__PURE__*/function (_DataSnapshot) {
  function MutationsDataSnapshot(ref, mutations, context) {
    var _this2;
    _classCallCheck(this, MutationsDataSnapshot);
    _this2 = _callSuper(this, MutationsDataSnapshot, [ref, mutations, false, undefined, context]);
    /**
     * Não use isso para obter valores anteriores de nós mutados.
     * Use as propriedades `.previous` nas snapshots individuais de cada filho.
     * @throws Lança um erro se você o utilizar.
     */
    _this2.previous = function () {
      throw new Error("Iterate values to get previous values for each mutation");
    };
    _this2.val = function () {
      var warn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (warn) {
        console.warn("Unless you know what you are doing, it is best not to use the value of a mutations snapshot directly. Use child methods and forEach to iterate the mutations instead");
      }
      return mutations;
    };
    return _this2;
  }
  /**
   * Executa uma função de retorno de chamada para cada mutação nesta snapshot até que a função de retorno de chamada retorne false.
   * @param callback Função chamada com uma snapshot de cada mutação nesta snapshot. Deve retornar um valor booleano que indica se deve continuar a iteração ou não.
   * @returns Retorna se cada filho foi iterado.
   */
  _inherits(MutationsDataSnapshot, _DataSnapshot);
  return _createClass(MutationsDataSnapshot, [{
    key: "forEach",
    value: function forEach(callback) {
      var _this3 = this;
      var mutations = this.val(false);
      return mutations.every(function (mutation) {
        var ref = mutation.target.reduce(function (ref, key) {
          return ref.child(key);
        }, _this3.ref);
        var snap = new DataSnapshot(ref, mutation.val, false, mutation.prev);
        return callback(snap);
      });
    }
  }, {
    key: "child",
    value: function child(index) {
      if (typeof index !== "number") {
        throw new Error("child index must be a number");
      }
      var mutation = this.val(false)[index];
      var ref = mutation.target.reduce(function (ref, key) {
        return ref.child(key);
      }, this.ref);
      return new DataSnapshot(ref, mutation.val, false, mutation.prev);
    }
  }]);
}(DataSnapshot);
exports.MutationsDataSnapshot = MutationsDataSnapshot;

},{"../Lib/PathInfo":141}],134:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ascii85 = void 0;
function c(input, length, result) {
  var b = [0, 0, 0, 0, 0];
  for (var i = 0; i < length; i += 4) {
    var n = ((input[i] * 256 + input[i + 1]) * 256 + input[i + 2]) * 256 + input[i + 3];
    if (!n) {
      result.push("z");
    } else {
      for (var j = 0; j < 5; b[j++] = n % 85 + 33, n = Math.floor(n / 85)) {}
      result.push(String.fromCharCode(b[4], b[3], b[2], b[1], b[0]));
    }
  }
}
function _encode(arr) {
  // summary: encodes input data in ascii85 string
  // input: ArrayLike
  var _a;
  var input = arr,
    result = [],
    remainder = input.length % 4,
    length = input.length - remainder;
  c(input, length, result);
  if (remainder) {
    var t = new Uint8Array(4);
    t.set(input.slice(length), 0);
    c(t, 4, result);
    var x = (_a = result.pop()) !== null && _a !== void 0 ? _a : "";
    if (x == "z") {
      x = "!!!!!";
    }
    result.push(x.substr(0, remainder + 1));
  }
  var ret = result.join(""); // String
  ret = "<~" + ret + "~>";
  return ret;
}
exports.ascii85 = {
  encode: function encode(arr) {
    if (arr instanceof ArrayBuffer) {
      arr = new Uint8Array(arr, 0, arr.byteLength);
    }
    return _encode(arr);
  },
  decode: function decode(input) {
    // summary: decodes the input string back to an ArrayBuffer
    // input: String: the input string to decode
    if (!input.startsWith("<~") || !input.endsWith("~>")) {
      throw new Error("Invalid input string");
    }
    input = input.substr(2, input.length - 4);
    var n = input.length,
      r = [],
      b = [0, 0, 0, 0, 0];
    var t, x, y, d;
    for (var i = 0; i < n; ++i) {
      if (input.charAt(i) == "z") {
        r.push(0, 0, 0, 0);
        continue;
      }
      for (var j = 0; j < 5; ++j) {
        b[j] = input.charCodeAt(i + j) - 33;
      }
      d = n - i;
      if (d < 5) {
        for (var _j = d; _j < 4; b[++_j] = 0) {}
        b[d] = 85;
      }
      t = (((b[0] * 85 + b[1]) * 85 + b[2]) * 85 + b[3]) * 85 + b[4];
      x = t & 255;
      t >>>= 8;
      y = t & 255;
      t >>>= 8;
      r.push(t >>> 8, t & 255, y, x);
      for (var _j2 = d; _j2 < 5; ++_j2, r.pop()) {}
      i += 4;
    }
    var data = new Uint8Array(r);
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
};
exports["default"] = exports.ascii85;

},{}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = void 0;
/**
 * Replacement for console.assert, throws an error if condition is not met.
 * @param condition 'truthy' condition
 * @param error
 */
function assert(condition, error) {
  if (!condition) {
    throw new Error("Assertion failed: ".concat(error !== null && error !== void 0 ? error : "check your code"));
  }
}
exports.assert = assert;

},{}],136:[function(require,module,exports){
(function (process){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
// eslint-disable-next-line @typescript-eslint/no-empty-function
var noop = function noop() {};
var DebugLogger = /*#__PURE__*/function () {
  function DebugLogger() {
    var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "log";
    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    _classCallCheck(this, DebugLogger);
    this.level = level;
    this.prefix = prefix;
    this.setLevel(level);
  }
  return _createClass(DebugLogger, [{
    key: "setLevel",
    value: function setLevel(level) {
      var prefix = this.prefix ? this.prefix + " %s" : "";
      this.verbose = ["verbose"].includes(level) ? prefix ? console.log.bind(console, prefix) : console.log.bind(console) : noop;
      this.log = ["verbose", "log"].includes(level) ? prefix ? console.log.bind(console, prefix) : console.log.bind(console) : noop;
      this.warn = ["verbose", "log", "warn"].includes(level) ? prefix ? console.warn.bind(console, prefix) : console.warn.bind(console) : noop;
      this.error = ["verbose", "log", "warn", "error"].includes(level) ? prefix ? console.error.bind(console, prefix) : console.error.bind(console) : noop;
      this.write = function (text) {
        var isRunKit = typeof process !== "undefined" && process.env && typeof process.env.RUNKIT_ENDPOINT_PATH === "string";
        if (text && isRunKit) {
          text.split("\n").forEach(function (line) {
            return console.log(line);
          }); // Logs each line separately
        } else {
          console.log(text);
        }
      };
    }
  }]);
}();
exports["default"] = DebugLogger;

}).call(this)}).call(this,require('_process'))
},{"_process":155}],137:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var cuid_1 = __importDefault(require("cuid"));
// Not using slugs, removed code
var timeBias = 0;
var ID = /*#__PURE__*/function () {
  function ID() {
    _classCallCheck(this, ID);
  }
  return _createClass(ID, null, [{
    key: "timeBias",
    set:
    /**
     * (for internal use)
     * bias in milliseconds to adjust generated cuid timestamps with
     */
    function set(bias) {
      if (typeof bias !== "number") {
        return;
      }
      timeBias = bias;
    }
  }, {
    key: "generate",
    value: function generate() {
      // Could also use https://www.npmjs.com/package/pushid for Firebase style 20 char id's
      return (0, cuid_1["default"])().slice(1); // Cuts off the always leading 'c'
      // return uuid62.v1();
    }
  }]);
}();
exports["default"] = ID;

},{"cuid":91}],138:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectCollection = void 0;
var ID_1 = __importDefault(require("./ID"));
/**
 * Convenience interface for defining an object collection
 * @example
 * type ChatMessage = {
 *    text: string, uid: string, sent: Date
 * }
 * type Chat = {
 *    title: text
 *    messages: ObjectCollection<ChatMessage>
 * }
 */
var ObjectCollection = /*#__PURE__*/function () {
  function ObjectCollection() {
    _classCallCheck(this, ObjectCollection);
  }
  return _createClass(ObjectCollection, null, [{
    key: "from",
    value:
    /**
     * Converts and array of values into an object collection, generating a unique key for each item in the array
     * @param array
     * @example
     * const array = [
     *  { title: "Don't make me think!", author: "Steve Krug" },
     *  { title: "The tipping point", author: "Malcolm Gladwell" }
     * ];
     *
     * // Convert:
     * const collection = ObjectCollection.from(array);
     * // --> {
     * //   kh1x3ygb000120r7ipw6biln: {
     * //       title: "Don't make me think!",
     * //       author: "Steve Krug"
     * //   },
     * //   kh1x3ygb000220r757ybpyec: {
     * //       title: "The tipping point",
     * //       author: "Malcolm Gladwell"
     * //   }
     * // }
     *
     * // Now it's easy to add them to the db:
     * db.ref('books').update(collection);
     */
    function from(array) {
      var collection = {};
      array.forEach(function (child) {
        collection[ID_1["default"].generate()] = child;
      });
      return collection;
    }
  }]);
}();
exports.ObjectCollection = ObjectCollection;

},{"./ID":137}],139:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setObservable = exports.getObservable = void 0;
var SimpleObservable_1 = __importDefault(require("./SimpleObservable"));
var Utils_1 = require("./Utils");
var _shimRequested = false;
var _observable;
_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
  var global, _yield$Promise$resolv, Observable;
  return _regeneratorRuntime().wrap(function _callee$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        // Try pre-loading rxjs Observable
        // Test availability in global scope first
        global = (0, Utils_1.getGlobalObject)();
        if (!(typeof global.Observable !== "undefined")) {
          _context.next = 4;
          break;
        }
        _observable = global.Observable;
        return _context.abrupt("return");
      case 4:
        _context.prev = 4;
        _context.next = 7;
        return Promise.resolve().then(function () {
          return __importStar(require("rxjs"));
        });
      case 7:
        _yield$Promise$resolv = _context.sent;
        Observable = _yield$Promise$resolv.Observable;
        _observable = Observable;
        _context.next = 15;
        break;
      case 12:
        _context.prev = 12;
        _context.t0 = _context["catch"](4);
        // rxjs Observable not available, setObservable must be used if usage of SimpleObservable is not desired
        _observable = SimpleObservable_1["default"];
      case 15:
      case "end":
        return _context.stop();
    }
  }, _callee, null, [[4, 12]]);
}))();
function getObservable() {
  if (_observable === SimpleObservable_1["default"] && !_shimRequested) {
    console.warn("Using IvipBase's simple Observable implementation because rxjs is not available. " + 'Add it to your project with "npm install rxjs", add it to IvipBase using db.setObservable(Observable), ' + 'or call db.setObservable("shim") to suppress this warning');
  }
  if (_observable) {
    return _observable;
  }
  throw new Error("RxJS Observable could not be loaded. ");
}
exports.getObservable = getObservable;
function setObservable(Observable) {
  if (Observable === "shim") {
    _observable = SimpleObservable_1["default"];
    _shimRequested = true;
  } else {
    _observable = Observable;
  }
}
exports.setObservable = setObservable;

},{"./SimpleObservable":145,"./Utils":149,"rxjs":90}],140:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PartialArray = void 0;
/**
 * Sparse/partial array converted to a serializable object. Use `Object.keys(sparseArray)` and `Object.values(sparseArray)` to iterate its indice and/or values
 */
var PartialArray = /*#__PURE__*/_createClass(function PartialArray(sparseArray) {
  _classCallCheck(this, PartialArray);
  if (sparseArray instanceof Array) {
    for (var i = 0; i < sparseArray.length; i++) {
      if (typeof sparseArray[i] !== "undefined") {
        this[i] = sparseArray[i];
      }
    }
  } else if (sparseArray) {
    Object.assign(this, sparseArray);
  }
});
exports.PartialArray = PartialArray;

},{}],141:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PathInfo = exports.PathReference = void 0;
var PathReference = /*#__PURE__*/_createClass(
/**
 * Cria uma referência a um caminho que pode ser armazenado no banco de dados. Use isso para criar referências cruzadas para outros dados em seu banco de dados.
 * @param path
 */
function PathReference(path) {
  _classCallCheck(this, PathReference);
  this.path = path;
});
exports.PathReference = PathReference;
function _getPathKeys(path) {
  path = path.replace(/\[/g, "/[").replace(/^\/+/, "").replace(/\/+$/, ""); // Substitua `[` por `/[`, remova barras invertidas iniciais, remova barras invertidas finais
  if (path.length === 0) {
    return [""];
  }
  var keys = [""].concat(_toConsumableArray(path.split("/")));
  return keys.map(function (key) {
    return key.startsWith("[") ? parseInt(key.slice(1, -1)) : key;
  });
}
var PathInfo = /*#__PURE__*/function () {
  function PathInfo(path) {
    _classCallCheck(this, PathInfo);
    if (typeof path === "string") {
      this.keys = _getPathKeys(path);
    } else if (path instanceof Array) {
      this.keys = Array.prototype.concat.apply([], path.map(function (k) {
        return typeof k === "string" ? _getPathKeys(k) : k instanceof PathInfo ? k.keys : [k];
      }).map(function (k) {
        k.splice(0, k.findIndex(function (k) {
          return String(k).trim() !== "";
        }));
        return k;
      }));
    } else {
      this.keys = [""];
    }
    this.keys.splice(0, this.keys.findIndex(function (k) {
      return String(k).trim() !== "";
    }));
    this.path = this.keys.reduce(function (path, key, i) {
      return i === 0 ? "".concat(key) : typeof key === "string" ? "".concat(path, "/").concat(key) : "".concat(path, "[").concat(key, "]");
    }, "").replace(/^\//gi, "");
  }
  return _createClass(PathInfo, [{
    key: "key",
    get: function get() {
      return this.keys.length === 0 ? null : this.keys.slice(-1)[0];
    }
  }, {
    key: "parent",
    get: function get() {
      if (this.keys.length == 0) {
        return null;
      }
      var parentKeys = this.keys.slice(0, -1);
      return new PathInfo(parentKeys);
    }
  }, {
    key: "parentPath",
    get: function get() {
      var _a, _b;
      return this.keys.length === 0 ? null : (_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : null;
    }
  }, {
    key: "child",
    value: function child(childKey) {
      var _this = this;
      if (typeof childKey === "string") {
        if (childKey.length === 0) {
          throw new Error("child key for path \"".concat(this.path, "\" cannot be empty"));
        }
        // Permitir a expansão de um caminho filho (por exemplo, "user/name") para o equivalente a `child('user').child('name')`
        var keys = _getPathKeys(childKey);
        keys.forEach(function (key, index) {
          // Verifique as regras de chave do IvipBase aqui para que sejam aplicadas independentemente do destino de armazenamento.
          // Isso impede que chaves específicas sejam permitidas em um ambiente (por exemplo, navegador), mas depois
          // recusadas ao sincronizar com um banco de dados binário IvipBase.
          if (typeof key !== "string") {
            return;
          }
          if (/[\x00-\x08\x0b\x0c\x0e-\x1f/[\]\\]/.test(key)) {
            throw new Error("Invalid child key \"".concat(key, "\" for path \"").concat(_this.path, "\". Keys cannot contain control characters or any of the following characters: \\ / [ ]"));
          }
          if (key.length > 128) {
            throw new Error("child key \"".concat(key, "\" for path \"").concat(_this.path, "\" is too long. Max key length is 128"));
          }
          if (index !== 0 && key.length === 0) {
            throw new Error("child key for path \"".concat(_this.path, "\" cannot be empty"));
          }
        });
        childKey = keys;
      }
      if (Array.isArray(childKey) && childKey[0] === "") childKey.shift();
      return new PathInfo(this.keys.concat(childKey).filter(function (key, i, l) {
        return key === "" ? i === 0 : true;
      }));
    }
  }, {
    key: "childPath",
    value: function childPath(childKey) {
      return this.child(childKey).path;
    }
  }, {
    key: "pathKeys",
    get: function get() {
      return this.keys;
    }
  }, {
    key: "equals",
    value:
    /**
     * Verifica se um caminho dado corresponde a este caminho, por exemplo, "posts/*\/title" corresponde a "posts/12344/title" e "users/123/name" corresponde a "users/$uid/name"
     */
    function equals(otherPath) {
      var other = otherPath instanceof PathInfo ? otherPath : new PathInfo(otherPath);
      if (this.path.replace(/\/$/gi, "") === other.path.replace(/\/$/gi, "")) {
        return true;
      } // they are identical
      if (this.keys.length !== other.keys.length) {
        return false;
      }
      return this.keys.every(function (key, index) {
        var otherKey = other.keys[index];
        return otherKey === key || typeof otherKey === "string" && (otherKey === "*" || otherKey[0] === "$") || typeof key === "string" && (key === "*" || key[0] === "$");
      });
    }
    /**
     * Verifica se um caminho dado é um ancestral, por exemplo, "posts" é um ancestral de "posts/12344/title"
     */
  }, {
    key: "isAncestorOf",
    value: function isAncestorOf(descendantPath) {
      var descendant = descendantPath instanceof PathInfo ? descendantPath : new PathInfo(descendantPath);
      if (descendant.path === "" || this.path === descendant.path) {
        return false;
      }
      if (this.path === "") {
        return true;
      }
      if (this.keys.length >= descendant.keys.length) {
        return false;
      }
      return this.keys.every(function (key, index) {
        var otherKey = descendant.keys[index];
        return otherKey === key || typeof otherKey === "string" && (otherKey === "*" || otherKey[0] === "$") || typeof key === "string" && (key === "*" || key[0] === "$");
      });
    }
    /**
     * Verifica se um caminho dado é um descendente, por exemplo, "posts/1234/title" é um descendente de "posts"
     */
  }, {
    key: "isDescendantOf",
    value: function isDescendantOf(ancestorPath) {
      var _this2 = this;
      var ancestor = ancestorPath instanceof PathInfo ? ancestorPath : new PathInfo(ancestorPath);
      if (this.path === "" || this.path === ancestor.path) {
        return false;
      }
      if (ancestorPath === "") {
        return true;
      }
      if (ancestor.keys.length >= this.keys.length) {
        return false;
      }
      return ancestor.keys.every(function (key, index) {
        var otherKey = _this2.keys[index];
        return otherKey === key || typeof otherKey === "string" && (otherKey === "*" || otherKey[0] === "$") || typeof key === "string" && (key === "*" || key[0] === "$");
      });
    }
    /**
     * Verifica se o outro caminho está na mesma trilha que este caminho. Caminhos estão na mesma trilha se compartilharem um
     * ancestral comum. Por exemplo, "posts" está na trilha de "posts/1234/title" e vice-versa.
     */
  }, {
    key: "isOnTrailOf",
    value: function isOnTrailOf(otherPath) {
      var other = otherPath instanceof PathInfo ? otherPath : new PathInfo(otherPath);
      if (this.path.length === 0 || other.path.length === 0) {
        return true;
      }
      if (this.path === other.path) {
        return true;
      }
      return this.pathKeys.every(function (key, index) {
        if (index >= other.keys.length) {
          return true;
        }
        var otherKey = other.keys[index];
        return otherKey === key || typeof otherKey === "string" && (otherKey === "*" || otherKey[0] === "$") || typeof key === "string" && (key === "*" || key[0] === "$");
      });
    }
    /**
     * Verifica se um determinado caminho é um filho direto, por exemplo, "posts/1234/title" é um filho de "posts/1234"
     */
  }, {
    key: "isChildOf",
    value: function isChildOf(otherPath) {
      var _a, _b;
      var other = otherPath instanceof PathInfo ? otherPath : new PathInfo(otherPath);
      if (this.path === "") {
        return false;
      } // Se nosso caminho for a raiz, ele não é filho de ninguém...
      return (_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.equals(other)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Verifica se um determinado caminho é seu pai, por exemplo, "posts/1234" é o pai de "posts/1234/title"
     */
  }, {
    key: "isParentOf",
    value: function isParentOf(otherPath) {
      var other = otherPath instanceof PathInfo ? otherPath : new PathInfo(otherPath);
      if (other.path === "" || !other.parent) {
        return false;
      } // Verifica se um determinado caminho é seu pai, por exemplo, "posts/1234" é o pai de "posts/1234/title"
      return this.equals(other.parent);
    }
  }], [{
    key: "get",
    value: function get(path) {
      return new PathInfo(path);
    }
  }, {
    key: "getChildPath",
    value: function getChildPath(path, childKey) {
      // return getChildPath(path, childKey);
      return PathInfo.get(path).child(childKey).path;
    }
  }, {
    key: "getPathKeys",
    value: function getPathKeys(path) {
      return _getPathKeys(path).filter(function (key, i) {
        return !(key === "" && i === 0);
      });
    }
  }, {
    key: "variablesKeys",
    value: function variablesKeys(varPath) {
      var count = 0;
      var variables = [];
      if (!varPath.includes("*") && !varPath.includes("$")) {
        return variables;
      }
      _getPathKeys(varPath).forEach(function (key) {
        if (key === "*") {
          variables.push(count++);
        } else if (typeof key === "string" && key[0] === "$") {
          variables.push(count++);
          variables.push(key);
          variables.push(key.slice(1));
        }
      });
      return variables;
    }
    /**
     * Se varPath contiver variáveis ou wildcards, ele as retornará com os valores encontrados em fullPath
     * @param {string} varPath caminho contendo variáveis como * e $name
     * @param {string} fullPath caminho real para um nó
     * @returns {{ [index: number]: string|number, [variable: string]: string|number }} retorna um objeto semelhante a uma matriz com todos os valores de variáveis. Todas as variáveis nomeadas também são definidas no objeto pelo nome delas (por exemplo, vars.uid e vars.$uid)
     * @example
     * PathInfo.extractVariables('users/$uid/posts/$postid', 'users/ewout/posts/post1/title') === {
     *  0: 'ewout',
     *  1: 'post1',
     *  uid: 'ewout', // ou $uid
     *  postid: 'post1' // ou $postid
     * };
     *
     * PathInfo.extractVariables('users/*\/posts/*\/$property', 'users/ewout/posts/post1/title') === {
     *  0: 'ewout',
     *  1: 'post1',
     *  2: 'title',
     *  property: 'title' // ou $property
     * };
     *
     * PathInfo.extractVariables('users/$user/friends[*]/$friend', 'users/dora/friends[4]/diego') === {
     *  0: 'dora',
     *  1: 4,
     *  2: 'diego',
     *  user: 'dora', // ou $user
     *  friend: 'diego' // ou $friend
     * };
     */
  }, {
    key: "extractVariables",
    value: function extractVariables(varPath, fullPath) {
      var count = 0;
      var variables = {
        get length() {
          return count;
        }
      };
      if (!varPath.includes("*") && !varPath.includes("$")) {
        return variables;
      }
      if (!this.get(varPath).equals(this.fillVariables(varPath, fullPath))) {
        return variables;
      }
      var keys = _getPathKeys(varPath);
      var pathKeys = _getPathKeys(fullPath);
      keys.forEach(function (key, index) {
        var pathKey = pathKeys[index];
        if (key === "*") {
          variables[count++] = pathKey;
        } else if (typeof key === "string" && key[0] === "$") {
          variables[count++] = pathKey;
          // Set the $variable property
          variables[key] = pathKey;
          // Set friendly property name (without $)
          var varName = key.slice(1);
          if (typeof variables[varName] === "undefined") {
            variables[varName] = pathKey;
          }
        }
      });
      return variables;
    }
    /**
     * Se varPath contiver variáveis ou wildcards, ele retornará um caminho com as variáveis substituídas pelas chaves encontradas em fullPath.
     * @example
     * PathInfo.fillVariables('users/$uid/posts/$postid', 'users/ewout/posts/post1/title') === 'users/ewout/posts/post1'
     */
  }, {
    key: "fillVariables",
    value: function fillVariables(varPath, fullPath) {
      if (varPath.indexOf("*") < 0 && varPath.indexOf("$") < 0) {
        return varPath;
      }
      var keys = _getPathKeys(varPath);
      var pathKeys = _getPathKeys(fullPath);
      var merged = keys.map(function (key, index) {
        if (key === pathKeys[index] || index >= pathKeys.length) {
          return key;
        } else if (typeof key === "string" && (key === "*" || key[0] === "$")) {
          return pathKeys[index];
        } else {
          throw new Error("Path \"".concat(fullPath, "\" cannot be used to fill variables of path \"").concat(varPath, "\" because they do not match"));
        }
      });
      var mergedPath = "";
      merged.forEach(function (key) {
        if (typeof key === "number") {
          mergedPath += "[".concat(key, "]");
        } else {
          if (mergedPath.length > 0) {
            mergedPath += "/";
          }
          mergedPath += key;
        }
      });
      return mergedPath;
    }
    /**
     * Substitui todas as variáveis em um caminho pelos valores no argumento vars
     * @param varPath caminho contendo variáveis
     * @param vars objeto de variáveis, como aquele obtido a partir de PathInfo.extractVariables
     */
  }, {
    key: "fillVariables2",
    value: function fillVariables2(varPath, vars) {
      if (_typeof(vars) !== "object" || Object.keys(vars).length === 0) {
        return varPath; // Nothing to fill
      }
      var pathKeys = _getPathKeys(varPath);
      var n = 0;
      var targetPath = pathKeys.reduce(function (path, key) {
        if (typeof key === "string" && (key === "*" || key.startsWith("$"))) {
          return PathInfo.getChildPath(path, vars[n++]);
        } else {
          return PathInfo.getChildPath(path, key);
        }
      }, "");
      return targetPath;
    }
  }]);
}();
exports.PathInfo = PathInfo;
exports["default"] = PathInfo;

},{}],142:[function(require,module,exports){
"use strict";

function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SchemaDefinition = void 0;
// parses a typestring, creates checker functions
function parse(definition) {
  // tokenize
  var pos = 0;
  function consumeSpaces() {
    var c;
    while (c = definition[pos], [" ", "\r", "\n", "\t"].includes(c)) {
      pos++;
    }
  }
  function consumeCharacter(c) {
    if (definition[pos] !== c) {
      throw new Error("Unexpected character at position ".concat(pos, ". Expected: '").concat(c, "', found '").concat(definition[pos], "'"));
    }
    pos++;
  }
  function readProperty() {
    consumeSpaces();
    var prop = {
      name: "",
      optional: false,
      wildcard: false
    };
    var c;
    while (c = definition[pos], c === "_" || c === "$" || c >= "a" && c <= "z" || c >= "A" && c <= "Z" || prop.name.length > 0 && c >= "0" && c <= "9" || prop.name.length === 0 && c === "*") {
      prop.name += c;
      pos++;
    }
    if (prop.name.length === 0) {
      throw new Error("Property name expected at position ".concat(pos, ", found: ").concat(definition.slice(pos, pos + 10), ".."));
    }
    if (definition[pos] === "?") {
      prop.optional = true;
      pos++;
    }
    if (prop.name === "*" || prop.name[0] === "$") {
      prop.optional = true;
      prop.wildcard = true;
    }
    consumeSpaces();
    consumeCharacter(":");
    return prop;
  }
  function readType() {
    consumeSpaces();
    var type = {
        typeOf: "any"
      },
      c;
    // try reading simple type first: (string,number,boolean,Date etc)
    var name = "";
    while (c = definition[pos], c >= "a" && c <= "z" || c >= "A" && c <= "Z") {
      name += c;
      pos++;
    }
    if (name.length === 0) {
      if (definition[pos] === "*") {
        // any value
        consumeCharacter("*");
        type.typeOf = "any";
      } else if (["'", '"', "`"].includes(definition[pos])) {
        // Read string value
        type.typeOf = "string";
        type.value = "";
        var quote = definition[pos];
        consumeCharacter(quote);
        while (c = definition[pos], c && c !== quote) {
          type.value += c;
          pos++;
        }
        consumeCharacter(quote);
      } else if (definition[pos] >= "0" && definition[pos] <= "9") {
        // read numeric value
        type.typeOf = "number";
        var nr = "";
        while (c = definition[pos], c === "." || c === "n" || c >= "0" && c <= "9") {
          nr += c;
          pos++;
        }
        if (nr.endsWith("n")) {
          type.value = BigInt(nr);
        } else if (nr.includes(".")) {
          type.value = parseFloat(nr);
        } else {
          type.value = parseInt(nr);
        }
      } else if (definition[pos] === "{") {
        // Read object (interface) definition
        consumeCharacter("{");
        type.typeOf = "object";
        type.instanceOf = Object;
        // Read children:
        type.children = [];
        while (true) {
          var prop = readProperty();
          var types = readTypes();
          type.children.push({
            name: prop.name,
            optional: prop.optional,
            wildcard: prop.wildcard,
            types: types
          });
          consumeSpaces();
          if (definition[pos] === ";" || definition[pos] === ",") {
            consumeCharacter(definition[pos]);
            consumeSpaces();
          }
          if (definition[pos] === "}") {
            break;
          }
        }
        consumeCharacter("}");
      } else if (definition[pos] === "/") {
        // Read regular expression definition
        consumeCharacter("/");
        var pattern = "",
          flags = "";
        while (c = definition[pos], c !== "/" || pattern.endsWith("\\")) {
          pattern += c;
          pos++;
        }
        consumeCharacter("/");
        while (c = definition[pos], ["g", "i", "m", "s", "u", "y", "d"].includes(c)) {
          flags += c;
          pos++;
        }
        type.typeOf = "string";
        type.matches = new RegExp(pattern, flags);
      } else {
        throw new Error("Expected a type definition at position ".concat(pos, ", found character '").concat(definition[pos], "'"));
      }
    } else if (["string", "number", "boolean", "bigint", "undefined", "String", "Number", "Boolean", "BigInt"].includes(name)) {
      type.typeOf = name.toLowerCase();
    } else if (name === "Object" || name === "object") {
      type.typeOf = "object";
      type.instanceOf = Object;
    } else if (name === "Date") {
      type.typeOf = "object";
      type.instanceOf = Date;
    } else if (name === "Binary" || name === "binary") {
      type.typeOf = "object";
      type.instanceOf = ArrayBuffer;
    } else if (name === "any") {
      type.typeOf = "any";
    } else if (name === "null") {
      // This is ignored, null values are not stored in the db (null indicates deletion)
      type.typeOf = "object";
      type.value = null;
    } else if (name === "Array") {
      // Read generic Array defintion
      consumeCharacter("<");
      type.typeOf = "object";
      type.instanceOf = Array; //name;
      type.genericTypes = readTypes();
      consumeCharacter(">");
    } else if (["true", "false"].includes(name)) {
      type.typeOf = "boolean";
      type.value = name === "true";
    } else {
      throw new Error("Unknown type at position ".concat(pos, ": \"").concat(type, "\""));
    }
    // Check if it's an Array of given type (eg: string[] or string[][])
    // Also converts to generics, string[] becomes Array<string>, string[][] becomes Array<Array<string>>
    consumeSpaces();
    while (definition[pos] === "[") {
      consumeCharacter("[");
      consumeCharacter("]");
      type = {
        typeOf: "object",
        instanceOf: Array,
        genericTypes: [type]
      };
    }
    return type;
  }
  function readTypes() {
    consumeSpaces();
    var types = [readType()];
    while (definition[pos] === "|") {
      consumeCharacter("|");
      types.push(readType());
      consumeSpaces();
    }
    return types;
  }
  return readType();
}
function checkObject(path, properties, obj, partial) {
  // Are there any properties that should not be in there?
  var invalidProperties = properties.find(function (prop) {
    return prop.name === "*" || prop.name[0] === "$";
  }) // Only if no wildcard properties are allowed
  ? [] : Object.keys(obj).filter(function (key) {
    return ![null, undefined].includes(obj[key]) &&
    // Ignore null or undefined values
    !properties.find(function (prop) {
      return prop.name === key;
    });
  });
  if (invalidProperties.length > 0) {
    return {
      ok: false,
      reason: "Object at path \"".concat(path, "\" cannot have propert").concat(invalidProperties.length === 1 ? "y" : "ies", " ").concat(invalidProperties.map(function (p) {
        return "\"".concat(p, "\"");
      }).join(", "))
    };
  }
  // Loop through properties that should be present
  function checkProperty(property) {
    var hasValue = ![null, undefined].includes(obj[property.name]);
    if (!property.optional && (partial ? obj[property.name] === null : !hasValue)) {
      return {
        ok: false,
        reason: "Property at path \"".concat(path, "/").concat(property.name, "\" is not optional")
      };
    }
    if (hasValue && property.types.length === 1) {
      return checkType("".concat(path, "/").concat(property.name), property.types[0], obj[property.name], false);
    }
    if (hasValue && !property.types.some(function (type) {
      return checkType("".concat(path, "/").concat(property.name), type, obj[property.name], false).ok;
    })) {
      return {
        ok: false,
        reason: "Property at path \"".concat(path, "/").concat(property.name, "\" does not match any of ").concat(property.types.length, " allowed types")
      };
    }
    return {
      ok: true
    };
  }
  var namedProperties = properties.filter(function (prop) {
    return !prop.wildcard;
  });
  var failedProperty = namedProperties.find(function (prop) {
    return !checkProperty(prop).ok;
  });
  if (failedProperty) {
    var reason = checkProperty(failedProperty).reason;
    return {
      ok: false,
      reason: reason
    };
  }
  var wildcardProperty = properties.find(function (prop) {
    return prop.wildcard;
  });
  if (!wildcardProperty) {
    return {
      ok: true
    };
  }
  var wildcardChildKeys = Object.keys(obj).filter(function (key) {
    return !namedProperties.find(function (prop) {
      return prop.name === key;
    });
  });
  var result = {
    ok: true
  };
  for (var i = 0; i < wildcardChildKeys.length && result.ok; i++) {
    var childKey = wildcardChildKeys[i];
    result = checkProperty({
      name: childKey,
      types: wildcardProperty.types,
      optional: true,
      wildcard: true
    });
  }
  return result;
}
function checkType(path, type, value, partial, trailKeys) {
  var ok = {
    ok: true
  };
  if (type.typeOf === "any") {
    return ok;
  }
  if (trailKeys instanceof Array && trailKeys.length > 0) {
    // The value to check resides in a descendant path of given type definition.
    // Recursivly check child type definitions to find a match
    if (type.typeOf !== "object") {
      return {
        ok: false,
        reason: "path \"".concat(path, "\" must be typeof ").concat(type.typeOf)
      }; // given value resides in a child path, but parent is not allowed be an object.
    }
    if (!type.children) {
      return ok;
    }
    var childKey = trailKeys[0];
    var property = type.children.find(function (prop) {
      return prop.name === childKey;
    });
    if (!property) {
      property = type.children.find(function (prop) {
        return prop.name === "*" || prop.name[0] === "$";
      });
    }
    if (!property) {
      return {
        ok: false,
        reason: "Object at path \"".concat(path, "\" cannot have property \"").concat(childKey, "\"")
      };
    }
    if (property.optional && value === null && trailKeys.length === 1) {
      return ok;
    }
    var result = {
      ok: false,
      reason: ""
    };
    property.types.some(function (type) {
      var childPath = typeof childKey === "number" ? "".concat(path, "[").concat(childKey, "]") : "".concat(path, "/").concat(childKey);
      result = checkType(childPath, type, value, partial, trailKeys.slice(1));
      return result.ok;
    });
    return result;
  }
  if (value === null) {
    return ok;
  }
  if (type.instanceOf === Object && (_typeof(value) !== "object" || value instanceof Array || value instanceof Date)) {
    return {
      ok: false,
      reason: "path \"".concat(path, "\" must be an object collection")
    };
  }
  if (type.instanceOf && (_typeof(value) !== "object" || value.constructor !== type.instanceOf)) {
    // !(value instanceof type.instanceOf) // value.constructor.name !== type.instanceOf
    return {
      ok: false,
      reason: "path \"".concat(path, "\" must be an instance of ").concat(type.instanceOf.name)
    };
  }
  if ("value" in type && value !== type.value) {
    return {
      ok: false,
      reason: "path \"".concat(path, "\" must be value: ").concat(type.value)
    };
  }
  if (_typeof(value) !== type.typeOf) {
    return {
      ok: false,
      reason: "path \"".concat(path, "\" must be typeof ").concat(type.typeOf)
    };
  }
  if (type.instanceOf === Array && type.genericTypes && !value.every(function (v) {
    var _a;
    return ((_a = type.genericTypes) !== null && _a !== void 0 ? _a : []).some(function (t) {
      return checkType(path, t, v, false).ok;
    });
  })) {
    return {
      ok: false,
      reason: "every array value of path \"".concat(path, "\" must match one of the specified types")
    };
  }
  if (type.typeOf === "object" && type.children) {
    return checkObject(path, type.children, value, partial);
  }
  if (type.matches && !type.matches.test(value)) {
    return {
      ok: false,
      reason: "path \"".concat(path, "\" must match regular expression /").concat(type.matches.source, "/").concat(type.matches.flags)
    };
  }
  return ok;
}
// eslint-disable-next-line @typescript-eslint/ban-types
function getConstructorType(val) {
  switch (val) {
    case String:
      return "string";
    case Number:
      return "number";
    case Boolean:
      return "boolean";
    case Date:
      return "Date";
    case BigInt:
      return "bigint";
    case Array:
      throw new Error("Schema error: Array cannot be used without a type. Use string[] or Array<string> instead");
    default:
      throw new Error("Schema error: unknown type used: ".concat(val.name));
  }
}
var SchemaDefinition = /*#__PURE__*/function () {
  function SchemaDefinition(definition) {
    var handling = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      warnOnly: false
    };
    _classCallCheck(this, SchemaDefinition);
    this.handling = handling;
    this.source = definition;
    if (_typeof(definition) === "object") {
      // Turn object into typescript definitions
      // eg:
      // const example = {
      //     name: String,
      //     born: Date,
      //     instrument: "'guitar'|'piano'",
      //     "address?": {
      //         street: String
      //     }
      // };
      // Resulting ts: "{name:string,born:Date,instrument:'guitar'|'piano',address?:{street:string}}"
      var toTS = function toTS(obj) {
        return "{" + Object.keys(obj).map(function (key) {
          var val = obj[key];
          if (val === undefined) {
            val = "undefined";
          } else if (val instanceof RegExp) {
            val = "/".concat(val.source, "/").concat(val.flags);
          } else if (_typeof(val) === "object") {
            val = toTS(val);
          } else if (typeof val === "function") {
            val = getConstructorType(val);
          } else if (!["string", "number", "boolean", "bigint"].includes(_typeof(val))) {
            throw new Error("Type definition for key \"".concat(key, "\" must be a string, number, boolean, bigint, object, regular expression, or one of these classes: String, Number, Boolean, Date, BigInt"));
          }
          return "".concat(key, ":").concat(val);
        }).join(",") + "}";
      };
      this.text = toTS(definition);
    } else if (typeof definition === "string") {
      this.text = definition;
    } else {
      throw new Error("Type definiton must be a string or an object");
    }
    this.type = parse(this.text);
  }
  return _createClass(SchemaDefinition, [{
    key: "check",
    value: function check(path, value, partial, trailKeys) {
      var result = checkType(path, this.type, value, partial, trailKeys);
      if (!result.ok && this.handling.warnOnly) {
        // Only issue a warning, allows schema definitions to be added to a production db to monitor if they are accurate before enforcing them.
        result.warning = "".concat(partial ? "Partial schema" : "Schema", " check on path \"").concat(path, "\"").concat(trailKeys ? " for child \"".concat(trailKeys.join("/"), "\"") : "", " failed: ").concat(result.reason);
        result.ok = true;
        if (typeof this.handling.warnCallback === "function") this.handling.warnCallback(result.warning);
      }
      return result;
    }
  }]);
}();
exports.SchemaDefinition = SchemaDefinition;

},{}],143:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SimpleCache = void 0;
var Utils_1 = require("./Utils");
var calculateExpiryTime = function calculateExpiryTime(expirySeconds) {
  return expirySeconds > 0 ? Date.now() + expirySeconds * 1000 : Infinity;
};
/**
 * Implementação simples de cache que mantém valores imutáveis na memória por um tempo limitado.
 * A imutabilidade é garantida clonando os valores armazenados e recuperados. Para alterar um valor em cache, ele terá que ser `set` novamente com o novo valor.
 */
var SimpleCache = /*#__PURE__*/function () {
  function SimpleCache(options) {
    var _this = this;
    _classCallCheck(this, SimpleCache);
    var _a;
    this.enabled = true;
    if (typeof options === "number") {
      // Assinatura antiga: apenas expirySeconds fornecido
      options = {
        expirySeconds: options
      };
    }
    options.cloneValues = options.cloneValues !== false;
    if (typeof options.expirySeconds !== "number" && typeof options.maxEntries !== "number") {
      throw new Error("Either expirySeconds or maxEntries must be specified");
    }
    this.options = Object.assign({
      expirySeconds: 15
    }, options);
    this.cache = new Map();
    // Limpeza a cada minuto
    var interval = setInterval(function () {
      _this.cleanUp();
    }, 60 * 1000);
    (_a = interval.unref) === null || _a === void 0 ? void 0 : _a.call(interval);
  }
  return _createClass(SimpleCache, [{
    key: "size",
    get: function get() {
      return this.cache.size;
    }
  }, {
    key: "has",
    value: function has(key) {
      if (!this.enabled) {
        return false;
      }
      return this.cache.has(key);
    }
  }, {
    key: "get",
    value: function get(key) {
      if (!this.enabled) {
        return null;
      }
      var entry = this.cache.get(key);
      if (!entry) {
        return null;
      } // if (!entry || entry.expires <= Date.now()) { return null; }
      entry.expires = calculateExpiryTime(this.options.expirySeconds);
      entry.accessed = Date.now();
      return this.options.cloneValues ? (0, Utils_1.cloneObject)(entry.value) : entry.value;
    }
  }, {
    key: "set",
    value: function set(key, value) {
      if (typeof this.options.maxEntries === "number" && this.options.maxEntries > 0 && this.cache.size >= this.options.maxEntries && !this.cache.has(key)) {
        // console.warn(`* cache limit ${this.options.maxEntries} reached: ${this.cache.size}`);
        // Remove um item expirado ou aquele que foi acessado há mais tempo
        var oldest = null;
        var now = Date.now();
        var _iterator = _createForOfIteratorHelper(this.cache.entries()),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
              _key = _step$value[0],
              entry = _step$value[1];
            if (entry.expires <= now) {
              // Found an expired item. Remove it now and stop
              this.cache["delete"](_key);
              oldest = null;
              break;
            }
            if (!oldest || entry.accessed < oldest.accessed) {
              oldest = {
                key: _key,
                accessed: entry.accessed
              };
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        if (oldest !== null) {
          this.cache["delete"](oldest.key);
        }
      }
      this.cache.set(key, {
        value: this.options.cloneValues ? (0, Utils_1.cloneObject)(value) : value,
        added: Date.now(),
        accessed: Date.now(),
        expires: calculateExpiryTime(this.options.expirySeconds)
      });
    }
  }, {
    key: "remove",
    value: function remove(key) {
      this.cache["delete"](key);
    }
  }, {
    key: "cleanUp",
    value: function cleanUp() {
      var _this2 = this;
      var now = Date.now();
      this.cache.forEach(function (entry, key) {
        if (entry.expires <= now) {
          _this2.cache["delete"](key);
        }
      });
    }
  }, {
    key: "keys",
    value: function keys() {
      return Array.from(this.cache.keys());
    }
  }, {
    key: "values",
    value: function values() {
      return Array.from(this.cache.values()).map(function (v) {
        return v.value;
      });
    }
  }, {
    key: "forEach",
    value: function forEach(callback) {
      var _this3 = this;
      this.cache.forEach(function (entry, key) {
        callback(entry.value, key, _this3);
      });
    }
  }]);
}();
exports.SimpleCache = SimpleCache;

},{"./Utils":149}],144:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
function runCallback(callback, data) {
  try {
    callback(data);
  } catch (err) {
    console.error("Error in subscription callback", err);
  }
}
var _subscriptions = Symbol("subscriptions");
var _oneTimeEvents = Symbol("oneTimeEvents");
var SimpleEventEmitter = /*#__PURE__*/function () {
  function SimpleEventEmitter() {
    _classCallCheck(this, SimpleEventEmitter);
    this[_subscriptions] = [];
    this[_oneTimeEvents] = new Map();
  }
  return _createClass(SimpleEventEmitter, [{
    key: "on",
    value: function on(event, callback) {
      if (this[_oneTimeEvents].has(event)) {
        runCallback(callback, this[_oneTimeEvents].get(event));
      } else {
        this[_subscriptions].push({
          event: event,
          callback: callback,
          once: false
        });
      }
      var self = this;
      return {
        stop: function stop() {
          self.off(event, callback);
        }
      };
    }
  }, {
    key: "off",
    value: function off(event, callback) {
      this[_subscriptions] = this[_subscriptions].filter(function (s) {
        return s.event !== event || callback && s.callback !== callback;
      });
      return this;
    }
  }, {
    key: "once",
    value: function once(event, callback) {
      var _this = this;
      return new Promise(function (resolve) {
        var ourCallback = function ourCallback(data) {
          resolve(data);
          callback === null || callback === void 0 ? void 0 : callback(data);
        };
        if (_this[_oneTimeEvents].has(event)) {
          runCallback(ourCallback, _this[_oneTimeEvents].get(event));
        } else {
          _this[_subscriptions].push({
            event: event,
            callback: ourCallback,
            once: true
          });
        }
      });
    }
  }, {
    key: "emit",
    value: function emit(event, data) {
      if (this[_oneTimeEvents].has(event)) {
        throw new Error("Event \"".concat(event, "\" was supposed to be emitted only once"));
      }
      for (var i = 0; i < this[_subscriptions].length; i++) {
        var s = this[_subscriptions][i];
        if (s.event !== event) {
          continue;
        }
        runCallback(s.callback, data);
        if (s.once) {
          this[_subscriptions].splice(i, 1);
          i--;
        }
      }
      return this;
    }
  }, {
    key: "emitOnce",
    value: function emitOnce(event, data) {
      if (this[_oneTimeEvents].has(event)) {
        throw new Error("Event \"".concat(event, "\" was supposed to be emitted only once"));
      }
      this.emit(event, data);
      this[_oneTimeEvents].set(event, data); // Mark event as being emitted once for future subscribers
      this.off(event); // Remove all listeners for this event, they won't fire again
      return this;
    }
  }, {
    key: "pipe",
    value: function pipe(event, eventEmitter) {
      return this.on(event, function (data) {
        eventEmitter.emit(event, data);
      });
    }
  }, {
    key: "pipeOnce",
    value: function pipeOnce(event, eventEmitter) {
      return this.once(event, function (data) {
        eventEmitter.emitOnce(event, data);
      });
    }
  }]);
}();
exports["default"] = SimpleEventEmitter;

},{}],145:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * rxjs is an optional dependency that only needs installing when any of IvipBase's observe methods are used.
 * If for some reason rxjs is not available (eg in test suite), we can provide a shim. This class is used when
 * `db.setObservable("shim")` is called
 */
var SimpleObservable = /*#__PURE__*/function () {
  function SimpleObservable(create) {
    _classCallCheck(this, SimpleObservable);
    this._active = false;
    this._subscribers = [];
    this._create = create;
  }
  return _createClass(SimpleObservable, [{
    key: "subscribe",
    value: function subscribe(subscriber) {
      var _this = this;
      if (!this._active) {
        var next = function next(value) {
          // emit value to all subscribers
          _this._subscribers.forEach(function (s) {
            try {
              s(value);
            } catch (err) {
              console.error("Error in subscriber callback:", err);
            }
          });
        };
        var observer = {
          next: next
        };
        this._cleanup = this._create(observer);
        this._active = true;
      }
      this._subscribers.push(subscriber);
      var unsubscribe = function unsubscribe() {
        _this._subscribers.splice(_this._subscribers.indexOf(subscriber), 1);
        if (_this._subscribers.length === 0) {
          _this._active = false;
          _this._cleanup();
        }
      };
      var subscription = {
        unsubscribe: unsubscribe
      };
      return subscription;
    }
  }]);
}();
exports["default"] = SimpleObservable;

},{}],146:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventStream = exports.EventPublisher = exports.EventSubscription = void 0;
var EventSubscription = /*#__PURE__*/function () {
  /**
   * @param stop function that stops the subscription from receiving future events
   */
  function EventSubscription(stop) {
    _classCallCheck(this, EventSubscription);
    this.stop = stop;
    this._internal = {
      state: "init",
      activatePromises: []
    };
  }
  /**
   * Notifies when subscription is activated or canceled
   * @param callback optional callback to run each time activation state changes
   * @returns returns a promise that resolves once activated, or rejects when it is denied (and no callback was supplied)
   */
  return _createClass(EventSubscription, [{
    key: "activated",
    value: function activated(callback) {
      var _this = this;
      if (callback) {
        this._internal.activatePromises.push({
          callback: callback
        });
        if (this._internal.state === "active") {
          callback(true);
        } else if (this._internal.state === "canceled") {
          callback(false, this._internal.cancelReason);
        }
      }
      // Changed behaviour: now also returns a Promise when the callback is used.
      // This allows for 1 activated call to both handle: first activation result,
      // and any future events using the callback
      return new Promise(function (resolve, reject) {
        if (_this._internal.state === "active") {
          return resolve();
        } else if (_this._internal.state === "canceled" && !callback) {
          return reject(new Error(_this._internal.cancelReason));
        }
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        var noop = function noop() {};
        _this._internal.activatePromises.push({
          resolve: resolve,
          reject: callback ? noop : reject // Don't reject when callback is used: let callback handle this (prevents UnhandledPromiseRejection if only callback is used)
        });
      });
    }
    /** (for internal use) */
  }, {
    key: "_setActivationState",
    value: function _setActivationState(activated, cancelReason) {
      this._internal.cancelReason = cancelReason;
      this._internal.state = activated ? "active" : "canceled";
      while (this._internal.activatePromises.length > 0) {
        var p = this._internal.activatePromises.shift();
        if (p && activated) {
          p.callback && p.callback(true);
          p.resolve && p.resolve();
        } else if (p) {
          p.callback && p.callback(false, cancelReason);
          p.reject && p.reject(cancelReason);
        }
      }
    }
  }]);
}();
exports.EventSubscription = EventSubscription;
var EventPublisher = /*#__PURE__*/_createClass(
/**
 *
 * @param publish function that publishes a new value to subscribers, return if there are any active subscribers
 * @param start function that notifies subscribers their subscription is activated
 * @param cancel function that notifies subscribers their subscription has been canceled, removes all subscriptions
 */
function EventPublisher(publish, start, cancel) {
  _classCallCheck(this, EventPublisher);
  this.publish = publish;
  this.start = start;
  this.cancel = cancel;
});
exports.EventPublisher = EventPublisher;
var EventStream = /*#__PURE__*/_createClass(function EventStream(eventPublisherCallback) {
  _classCallCheck(this, EventStream);
  var subscribers = [];
  var noMoreSubscribersCallback;
  var activationState; // TODO: refactor to string only: STATE_INIT, STATE_STOPPED, STATE_ACTIVATED, STATE_CANCELED
  var STATE_STOPPED = "stopped (no more subscribers)";
  this.subscribe = function (callback, _activationCallback) {
    if (typeof callback !== "function") {
      throw new TypeError("callback must be a function");
    } else if (activationState === STATE_STOPPED) {
      throw new Error("stream can't be used anymore because all subscribers were stopped");
    }
    var sub = {
      callback: callback,
      activationCallback: function activationCallback(activated, cancelReason) {
        _activationCallback === null || _activationCallback === void 0 ? void 0 : _activationCallback(activated, cancelReason);
        this.subscription._setActivationState(activated, cancelReason);
      },
      subscription: new EventSubscription(function stop() {
        subscribers.splice(subscribers.indexOf(sub), 1);
        return checkActiveSubscribers();
      })
    };
    subscribers.push(sub);
    if (typeof activationState !== "undefined") {
      if (activationState === true) {
        _activationCallback === null || _activationCallback === void 0 ? void 0 : _activationCallback(true);
        sub.subscription._setActivationState(true);
      } else if (typeof activationState === "string") {
        _activationCallback === null || _activationCallback === void 0 ? void 0 : _activationCallback(false, activationState);
        sub.subscription._setActivationState(false, activationState);
      }
    }
    return sub.subscription;
  };
  var checkActiveSubscribers = function checkActiveSubscribers() {
    var ret;
    if (subscribers.length === 0) {
      ret = noMoreSubscribersCallback === null || noMoreSubscribersCallback === void 0 ? void 0 : noMoreSubscribersCallback();
      activationState = STATE_STOPPED;
    }
    return Promise.resolve(ret);
  };
  this.unsubscribe = function (callback) {
    var remove = callback ? subscribers.filter(function (sub) {
      return sub.callback === callback;
    }) : subscribers;
    remove.forEach(function (sub) {
      var i = subscribers.indexOf(sub);
      subscribers.splice(i, 1);
    });
    checkActiveSubscribers();
  };
  this.stop = function () {
    // Stop (remove) all subscriptions
    subscribers.splice(0);
    checkActiveSubscribers();
  };
  /**
   * For publishing side: adds a value that will trigger callbacks to all subscribers
   * @param val
   * @returns returns whether there are subscribers left
   */
  var publish = function publish(val) {
    subscribers.forEach(function (sub) {
      try {
        sub.callback(val);
      } catch (err) {
        console.error("Error running subscriber callback: ".concat(err.message));
      }
    });
    if (subscribers.length === 0) {
      checkActiveSubscribers();
    }
    return subscribers.length > 0;
  };
  /**
   * For publishing side: let subscribers know their subscription is activated. Should be called only once
   */
  var start = function start(allSubscriptionsStoppedCallback) {
    activationState = true;
    noMoreSubscribersCallback = allSubscriptionsStoppedCallback;
    subscribers.forEach(function (sub) {
      var _a;
      (_a = sub.activationCallback) === null || _a === void 0 ? void 0 : _a.call(sub, true);
    });
  };
  /**
   * For publishing side: let subscribers know their subscription has been canceled. Should be called only once
   */
  var cancel = function cancel(reason) {
    activationState = reason;
    subscribers.forEach(function (sub) {
      var _a;
      (_a = sub.activationCallback) === null || _a === void 0 ? void 0 : _a.call(sub, false, reason || new Error("unknown reason"));
    });
    subscribers.splice(0); // Clear all
  };
  var publisher = new EventPublisher(publish, start, cancel);
  eventPublisherCallback(publisher);
});
exports.EventStream = EventStream;

},{}],147:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deserialize2 = exports.serialize2 = exports.serialize = exports.detectSerializeVersion = exports.deserialize = void 0;
var Ascii85_1 = __importDefault(require("./Ascii85"));
var PartialArray_1 = require("./PartialArray");
var PathInfo_1 = __importStar(require("./PathInfo"));
var Utils_1 = require("./Utils");
/*
    There are now 2 different serialization methods for transporting values.

    v1:
    The original version (v1) created an object with "map" and "val" properties.
    The "map" property was made optional in v1.14.1 so they won't be present for values needing no serializing

    v2:
    The new version replaces serialized values inline by objects containing ".type" and ".val" properties.
    This serializing method was introduced by `export` and `import` methods because they use streaming and
    are unable to prepare type mappings up-front. This format is smaller in transmission (in many cases),
    and easier to read and process.

    original: { "date": (some date) }
    v1 serialized: { "map": { "date": "date" }, "val": { date: "2022-04-22T07:49:23Z" } }
    v2 serialized: { "date": { ".type": "date", ".val": "2022-04-22T07:49:23Z" } }

    original: (some date)
    v1 serialized: { "map": "date", "val": "2022-04-22T07:49:23Z" }
    v2 serialized: { ".type": "date", ".val": "2022-04-22T07:49:23Z" }
    comment: top level value that need serializing is wrapped in an object with ".type" and ".val". v1 is smaller in this case

    original: 'some string'
    v1 serialized: { "map": {}, "val": "some string" }
    v2 serialized: "some string"
    comment: primitive types such as strings don't need serializing and are returned as is in v2

    original: { "date": (some date), "text": "Some string" }
    v1 serialized: { "map": { "date": "date" }, "val": { date: "2022-04-22T07:49:23Z", "text": "Some string" } }
    v2 serialized: { "date": { ".type": "date", ".val": "2022-04-22T07:49:23Z" }, "text": "Some string" }
*/
/**
 * Original deserialization method using global `map` and `val` properties
 * @param data
 * @returns
 */
var deserialize = function deserialize(data) {
  if (data.map === null || typeof data.map === "undefined") {
    if (typeof data.val === "undefined") {
      throw new Error("serialized value must have a val property");
    }
    return data.val;
  }
  var deserializeValue = function deserializeValue(type, val) {
    if (type === "date") {
      // Date was serialized as a string (UTC)
      return new Date(val);
    } else if (type === "binary") {
      // ascii85 encoded binary data
      return Ascii85_1["default"].decode(val);
    } else if (type === "reference") {
      return new PathInfo_1.PathReference(val);
    } else if (type === "regexp") {
      return new RegExp(val.pattern, val.flags);
    } else if (type === "array") {
      return new PartialArray_1.PartialArray(val);
    } else if (type === "bigint") {
      return BigInt(val);
    }
    return val;
  };
  if (typeof data.map === "string") {
    // Single value
    return deserializeValue(data.map, data.val);
  }
  Object.keys(data.map).forEach(function (path) {
    var type = data.map[path];
    var keys = PathInfo_1["default"].getPathKeys(path);
    var parent = data;
    var key = "val";
    var val = data.val;
    keys.forEach(function (k) {
      key = k;
      parent = val;
      val = val[key]; // If an error occurs here, there's something wrong with the calling code...
    });
    parent[key] = deserializeValue(type, val);
  });
  return data.val;
};
exports.deserialize = deserialize;
/**
 * Function to detect the used serialization method with for the given object
 * @param data
 * @returns
 */
var detectSerializeVersion = function detectSerializeVersion(data) {
  if (_typeof(data) !== "object" || data === null) {
    // This can only be v2, which allows primitive types to bypass serializing
    return 2;
  }
  if ("map" in data && "val" in data) {
    return 1;
  } else if ("val" in data) {
    // If it's v1, 'val' will be the only key in the object because serialize2 adds ".version": 2 to the object to prevent confusion.
    if (Object.keys(data).length > 1) {
      return 2;
    }
    return 1;
  }
  return 2;
};
exports.detectSerializeVersion = detectSerializeVersion;
/**
 * Original serialization method using global `map` and `val` properties
 * @param data
 * @returns
 */
var serialize = function serialize(obj) {
  var _a;
  // Recursively find dates and binary data
  if (obj === null || _typeof(obj) !== "object" || obj instanceof Date || obj instanceof ArrayBuffer || obj instanceof PathInfo_1.PathReference || obj instanceof RegExp) {
    // Single value
    var ser = (0, exports.serialize)({
      value: obj
    });
    return {
      map: (_a = ser.map) === null || _a === void 0 ? void 0 : _a.value,
      val: ser.val.value
    };
  }
  obj = (0, Utils_1.cloneObject)(obj); // Make sure we don't alter the original object
  var process = function process(obj, mappings, prefix) {
    if (obj instanceof PartialArray_1.PartialArray) {
      mappings[prefix] = "array";
    }
    Object.keys(obj).forEach(function (key) {
      var val = obj[key];
      var path = prefix.length === 0 ? key : "".concat(prefix, "/").concat(key);
      if (typeof val === "bigint") {
        obj[key] = val.toString();
        mappings[path] = "bigint";
      } else if (val instanceof Date) {
        // serialize date to UTC string
        obj[key] = val.toISOString();
        mappings[path] = "date";
      } else if (val instanceof ArrayBuffer) {
        // Serialize binary data with ascii85
        obj[key] = Ascii85_1["default"].encode(val); //ascii85.encode(Buffer.from(val)).toString();
        mappings[path] = "binary";
      } else if (val instanceof PathInfo_1.PathReference) {
        obj[key] = val.path;
        mappings[path] = "reference";
      } else if (val instanceof RegExp) {
        // Queries using the 'matches' filter with a regular expression can now also be used on remote db's
        obj[key] = {
          pattern: val.source,
          flags: val.flags
        };
        mappings[path] = "regexp";
      } else if (_typeof(val) === "object" && val !== null) {
        process(val, mappings, path);
      }
    });
  };
  var mappings = {};
  process(obj, mappings, "");
  var serialized = {
    val: obj
  };
  if (Object.keys(mappings).length > 0) {
    serialized.map = mappings;
  }
  return serialized;
};
exports.serialize = serialize;
/**
 * New serialization method using inline `.type` and `.val` properties
 * @param obj
 * @returns
 */
var serialize2 = function serialize2(obj) {
  // Recursively find data that needs serializing
  var getSerializedValue = function getSerializedValue(val) {
    if (typeof val === "bigint") {
      // serialize bigint to string
      return {
        ".type": "bigint",
        ".val": val.toString()
      };
    } else if (val instanceof Date) {
      // serialize date to UTC string
      return {
        ".type": "date",
        ".val": val.toISOString()
      };
    } else if (val instanceof ArrayBuffer) {
      // Serialize binary data with ascii85
      return {
        ".type": "binary",
        ".val": Ascii85_1["default"].encode(val)
      };
    } else if (val instanceof PathInfo_1.PathReference) {
      return {
        ".type": "reference",
        ".val": val.path
      };
    } else if (val instanceof RegExp) {
      // Queries using the 'matches' filter with a regular expression can now also be used on remote db's
      return {
        ".type": "regexp",
        ".val": "/".concat(val.source, "/").concat(val.flags) // new: shorter
        // '.val': {
        //     pattern: val.source,
        //     flags: val.flags
        // }
      };
    } else if (_typeof(val) === "object" && val !== null) {
      if (val instanceof Array) {
        var copy = [];
        for (var i = 0; i < val.length; i++) {
          copy[i] = getSerializedValue(val[i]);
        }
        return copy;
      } else {
        var _copy = {}; //val instanceof Array ? [] : {} as SerializedValueV2;
        if (val instanceof PartialArray_1.PartialArray) {
          // Mark the object as partial ("sparse") array
          _copy[".type"] = "array";
        }
        for (var prop in val) {
          _copy[prop] = getSerializedValue(val[prop]);
        }
        return _copy;
      }
    } else {
      // Primitive value. Don't serialize
      return val;
    }
  };
  var serialized = getSerializedValue(obj);
  if (serialized !== null && _typeof(serialized) === "object" && "val" in serialized && Object.keys(serialized).length === 1) {
    // acebase-core v1.14.1 made the 'map' property optional.
    // This v2 serialized object might be confused with a v1 without mappings, because it only has a "val" property
    // To prevent this, mark the serialized object with version 2
    serialized[".version"] = 2;
  }
  return serialized;
};
exports.serialize2 = serialize2;
/**
 * New deserialization method using inline `.type` and `.val` properties
 * @param obj
 * @returns
 */
var deserialize2 = function deserialize2(data) {
  if (_typeof(data) !== "object" || data === null) {
    // primitive value, not serialized
    return data;
  }
  if (typeof data[".type"] === "undefined") {
    // No type given: this is a plain object or array
    if (data instanceof Array) {
      // Plain array, deserialize items into a copy
      var copy = [];
      var arr = data;
      for (var i = 0; i < arr.length; i++) {
        copy.push((0, exports.deserialize2)(arr[i]));
      }
      return copy;
    } else {
      // Plain object, deserialize properties into a copy
      var _copy2 = {};
      var obj = data;
      for (var prop in obj) {
        _copy2[prop] = (0, exports.deserialize2)(obj[prop]);
      }
      return _copy2;
    }
  } else if (typeof data[".type"] === "string") {
    var dataType = data[".type"].toLowerCase();
    if (dataType === "bigint") {
      var val = data[".val"];
      return BigInt(val);
    } else if (dataType === "array") {
      // partial ("sparse") array, deserialize children into a copy
      var _arr = data;
      var _copy3 = {};
      for (var index in _arr) {
        _copy3[index] = (0, exports.deserialize2)(_arr[index]);
      }
      delete _copy3[".type"];
      return new PartialArray_1.PartialArray(_copy3);
    } else if (dataType === "date") {
      // Date was serialized as a string (UTC)
      var _val = data[".val"];
      return new Date(_val);
    } else if (dataType === "binary") {
      // ascii85 encoded binary data
      var _val2 = data[".val"];
      return Ascii85_1["default"].decode(_val2);
    } else if (dataType === "reference") {
      var _val3 = data[".val"];
      return new PathInfo_1.PathReference(_val3);
    } else if (dataType === "regexp") {
      var _val4 = data[".val"];
      if (typeof _val4 === "string") {
        // serialized as '/(pattern)/flags'
        var match = /^\/(.*)\/([a-z]+)$/.exec(_val4);
        return match ? new RegExp(match[1], match[2]) : null;
      }
      // serialized as object with pattern & flags properties
      return new RegExp(_val4.pattern, _val4.flags);
    }
  }
  throw new Error("Unknown data type \"".concat(data[".type"], "\" in serialized value"));
};
exports.deserialize2 = deserialize2;

},{"./Ascii85":134,"./PartialArray":140,"./PathInfo":141,"./Utils":149}],148:[function(require,module,exports){
"use strict";

function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var Utils_1 = require("./Utils");
var PathInfo_1 = __importDefault(require("./PathInfo"));
var reference_1 = require("../DataBase/reference");
var snapshot_1 = require("../DataBase/snapshot");
/**
 * (for internal use) - gets the mapping set for a specific path
 */
function get(mappings, path) {
  // path points to the mapped (object container) location
  path = path.replace(/^\/|\/$/g, ""); // trim slashes
  var keys = PathInfo_1["default"].getPathKeys(path);
  var mappedPath = Object.keys(mappings).find(function (mpath) {
    var mkeys = PathInfo_1["default"].getPathKeys(mpath);
    if (mkeys.length !== keys.length) {
      return false; // Can't be a match
    }
    return mkeys.every(function (mkey, index) {
      if (mkey === "*" || typeof mkey === "string" && mkey[0] === "$") {
        return true; // wildcard
      }
      return mkey === keys[index];
    });
  });
  if (!mappedPath) return;
  var mapping = mappings[mappedPath];
  return mapping;
}
/**
 * (for internal use) - gets the mapping set for a specific path's parent
 */
function _map(mappings, path) {
  // path points to the object location, its parent should have the mapping
  var targetPath = PathInfo_1["default"].get(path).parentPath;
  if (targetPath === null) {
    return;
  }
  return get(mappings, targetPath);
}
/**
 * (for internal use) - gets all mappings set for a specific path and all subnodes
 * @returns returns array of all matched mappings in path
 */
function mapDeep(mappings, entryPath) {
  // returns mapping for this node, and all mappings for nested nodes
  // entryPath: "users/ewout"
  // mappingPath: "users"
  // mappingPath: "users/*/posts"
  entryPath = entryPath.replace(/^\/|\/$/g, ""); // trim slashes
  // Start with current path's parent node
  var pathInfo = PathInfo_1["default"].get(entryPath);
  var startPath = pathInfo.parentPath;
  var keys = startPath ? PathInfo_1["default"].getPathKeys(startPath) : [];
  // Every path that starts with startPath, is a match
  // TODO: refactor to return Object.keys(mappings),filter(...)
  var matches = Object.keys(mappings).reduce(function (m, mpath) {
    //const mkeys = mpath.length > 0 ? mpath.split("/") : [];
    var mkeys = PathInfo_1["default"].getPathKeys(mpath);
    if (mkeys.length < keys.length) {
      return m; // Can't be a match
    }
    var isMatch = true;
    if (keys.length === 0 && startPath !== null) {
      // Only match first node's children if mapping pattern is "*" or "$variable"
      isMatch = mkeys.length === 1 && (mkeys[0] === "*" || typeof mkeys[0] === "string" && mkeys[0][0] === "$");
    } else {
      mkeys.every(function (mkey, index) {
        if (index >= keys.length) {
          return false; // stop .every loop
        } else if (mkey === "*" || typeof mkey === "string" && mkey[0] === "$" || mkey === keys[index]) {
          return true; // continue .every loop
        } else {
          isMatch = false;
          return false; // stop .every loop
        }
      });
    }
    if (isMatch) {
      var mapping = mappings[mpath];
      m.push({
        path: mpath,
        type: mapping
      });
    }
    return m;
  }, []);
  return matches;
}
/**
 * (for internal use) - serializes or deserializes an object using type mappings
 * @returns returns the (de)serialized value
 */
function process(db, mappings, path, obj, action) {
  if (obj === null || _typeof(obj) !== "object") {
    return obj;
  }
  var keys = PathInfo_1["default"].getPathKeys(path); // path.length > 0 ? path.split("/") : [];
  var m = mapDeep(mappings, path);
  var changes = [];
  m.sort(function (a, b) {
    return PathInfo_1["default"].getPathKeys(a.path).length > PathInfo_1["default"].getPathKeys(b.path).length ? -1 : 1;
  }); // Deepest paths first
  m.forEach(function (mapping) {
    var mkeys = PathInfo_1["default"].getPathKeys(mapping.path); //mapping.path.length > 0 ? mapping.path.split("/") : [];
    mkeys.push("*");
    var mTrailKeys = mkeys.slice(keys.length);
    if (mTrailKeys.length === 0) {
      var vars = PathInfo_1["default"].extractVariables(mapping.path, path);
      var ref = new reference_1.DataReference(db, path, vars);
      if (action === "serialize") {
        // serialize this object
        obj = mapping.type.serialize(obj, ref);
      } else if (action === "deserialize") {
        // deserialize this object
        var snap = new snapshot_1.DataSnapshot(ref, obj);
        obj = mapping.type.deserialize(snap);
      }
      return;
    }
    // Find all nested objects at this trail path
    var process = function process(parentPath, parent, keys) {
      if (obj === null || _typeof(obj) !== "object") {
        return obj;
      }
      var key = keys[0];
      var children = [];
      if (key === "*" || typeof key === "string" && key[0] === "$") {
        // Include all children
        if (parent instanceof Array) {
          children = parent.map(function (val, index) {
            return {
              key: index,
              val: val
            };
          });
        } else {
          children = Object.keys(parent).map(function (k) {
            return {
              key: k,
              val: parent[k]
            };
          });
        }
      } else {
        // Get the 1 child
        var child = parent[key];
        if (_typeof(child) === "object") {
          children.push({
            key: key,
            val: child
          });
        }
      }
      children.forEach(function (child) {
        var childPath = PathInfo_1["default"].getChildPath(parentPath, child.key);
        var vars = PathInfo_1["default"].extractVariables(mapping.path, childPath);
        var ref = new reference_1.DataReference(db, childPath, vars);
        if (keys.length === 1) {
          // TODO: this alters the existing object, we must build our own copy!
          if (action === "serialize") {
            // serialize this object
            changes.push({
              parent: parent,
              key: child.key,
              original: parent[child.key]
            });
            parent[child.key] = mapping.type.serialize(child.val, ref);
          } else if (action === "deserialize") {
            // deserialize this object
            var _snap = new snapshot_1.DataSnapshot(ref, child.val);
            parent[child.key] = mapping.type.deserialize(_snap);
          }
        } else {
          // Dig deeper
          process(childPath, child.val, keys.slice(1));
        }
      });
    };
    process(path, obj, mTrailKeys);
  });
  if (action === "serialize") {
    // Clone this serialized object so any types that remained
    // will become plain objects without functions, and we can restore
    // the original object's values if any mappings were processed.
    // This will also prevent circular references
    obj = (0, Utils_1.cloneObject)(obj);
    if (changes.length > 0) {
      // Restore the changes made to the original object
      changes.forEach(function (change) {
        change.parent[change.key] = change.original;
      });
    }
  }
  return obj;
}
var _mappings = Symbol("mappings");
var TypeMappings = /*#__PURE__*/function () {
  function TypeMappings(db) {
    _classCallCheck(this, TypeMappings);
    this.db = db;
    this[_mappings] = {};
  }
  /** (for internal use) */
  return _createClass(TypeMappings, [{
    key: "mappings",
    get: function get() {
      return this[_mappings];
    }
    /** (for internal use) */
  }, {
    key: "map",
    value: function map(path) {
      return _map(this[_mappings], path);
    }
    /**
     * Maps objects that are stored in a specific path to a class, so they can automatically be
     * serialized when stored to, and deserialized (instantiated) when loaded from the database.
     * @param path path to an object container, eg "users" or "users/*\/posts"
     * @param type class to bind all child objects of path to
     * Best practice is to implement 2 methods for instantiation and serializing of your objects:
     * 1) `static create(snap: DataSnapshot)` and 2) `serialize(ref: DataReference)`. See example
     * @param options (optional) You can specify the functions to use to
     * serialize and/or instantiate your class. If you do not specificy a creator (constructor) method,
     * IvipBase will call `YourClass.create(snapshot)` method if it exists, or create an instance of
     * YourClass with `new YourClass(snapshot)`.
     * If you do not specifiy a serializer method, IvipBase will call `YourClass.prototype.serialize(ref)`
     * if it exists, or tries storing your object's fields unaltered. NOTE: `this` in your creator
     * function will point to `YourClass`, and `this` in your serializer function will point to the
     * `instance` of `YourClass`.
     * @example
     * class User {
     *    static create(snap: DataSnapshot): User {
     *        // Deserialize (instantiate) User from plain database object
     *        let user = new User();
     *        Object.assign(user, snap.val()); // Copy all properties to user
     *        user.id = snap.ref.key; // Add the key as id
     *        return user;
     *    }
     *    serialize(ref: DataReference) {
     *        // Serialize user for database storage
     *        return {
     *            name: this.name
     *            email: this.email
     *        };
     *    }
     * }
     * db.types.bind('users', User); // Automatically uses serialize and static create methods
     */
  }, {
    key: "bind",
    value: function bind(path, type) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      // Maps objects that are stored in a specific path to a constructor method,
      // so they are automatically deserialized
      if (typeof path !== "string") {
        throw new TypeError("path must be a string");
      }
      if (typeof type !== "function") {
        throw new TypeError("constructor must be a function");
      }
      if (typeof options.serializer === "undefined") {
        // if (typeof type.prototype.serialize === 'function') {
        //     // Use .serialize instance method
        //     options.serializer = type.prototype.serialize;
        // }
        // Use object's serialize method upon serialization (if available)
      } else if (typeof options.serializer === "string") {
        if (typeof type.prototype[options.serializer] === "function") {
          options.serializer = type.prototype[options.serializer];
        } else {
          throw new TypeError("".concat(type.name, ".prototype.").concat(options.serializer, " is not a function, cannot use it as serializer"));
        }
      } else if (typeof options.serializer !== "function") {
        throw new TypeError("serializer for class ".concat(type.name, " must be a function, or the name of a prototype method"));
      }
      if (typeof options.creator === "undefined") {
        if (typeof type.create === "function") {
          // Use static .create as creator method
          options.creator = type.create;
        }
      } else if (typeof options.creator === "string") {
        if (typeof type[options.creator] === "function") {
          options.creator = type[options.creator];
        } else {
          throw new TypeError("".concat(type.name, ".").concat(options.creator, " is not a function, cannot use it as creator"));
        }
      } else if (typeof options.creator !== "function") {
        throw new TypeError("creator for class ".concat(type.name, " must be a function, or the name of a static method"));
      }
      path = path.replace(/^\/|\/$/g, ""); // trim slashes
      this[_mappings][path] = {
        db: this.db,
        type: type,
        creator: options.creator,
        serializer: options.serializer,
        deserialize: function deserialize(snap) {
          // run constructor method
          var obj;
          if (this.creator) {
            obj = this.creator.call(this.type, snap);
          } else {
            obj = new this.type(snap);
          }
          return obj;
        },
        serialize: function serialize(obj, ref) {
          if (this.serializer) {
            obj = this.serializer.call(obj, ref, obj);
          } else if (obj && typeof obj.serialize === "function") {
            obj = obj.serialize(ref, obj);
          }
          return obj;
        }
      };
    }
    /**
     * @internal (for internal use)
     * Serializes any child in given object that has a type mapping
     * @param path | path to the object's location
     * @param obj object to serialize
     */
  }, {
    key: "serialize",
    value: function serialize(path, obj) {
      return process(this.db, this[_mappings], path, obj, "serialize");
    }
    /**
     * @internal (for internal use)
     * Deserialzes any child in given object that has a type mapping
     * @param path path to the object's location
     * @param obj object to deserialize
     */
  }, {
    key: "deserialize",
    value: function deserialize(path, obj) {
      return process(this.db, this[_mappings], path, obj, "deserialize");
    }
  }]);
}();
exports["default"] = TypeMappings;

},{"../DataBase/reference":132,"../DataBase/snapshot":133,"./PathInfo":141,"./Utils":149}],149:[function(require,module,exports){
(function (global,Buffer){(function (){
"use strict";

function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uuidv4 = exports.deepEqual = exports.isEmpty = exports.safeGet = exports.contains = exports.getGlobalObject = exports.defer = exports.getChildValues = exports.getMutations = exports.compareValues = exports.isDate = exports.ObjectDifferences = exports.valuesAreEqual = exports.cloneObject = exports.concatTypedArrays = exports.decodeString = exports.encodeString = exports.bytesToBigint = exports.bigintToBytes = exports.bytesToNumber = exports.numberToBytes = void 0;
var PathInfo_1 = require("./PathInfo");
var PartialArray_1 = require("./PartialArray");
var process_1 = __importDefault(require("../process"));
function numberToBytes(number) {
  var bytes = new Uint8Array(8);
  var view = new DataView(bytes.buffer);
  view.setFloat64(0, number);
  return _construct(Array, _toConsumableArray(bytes));
}
exports.numberToBytes = numberToBytes;
function bytesToNumber(bytes) {
  var length = Array.isArray(bytes) ? bytes.length : bytes.byteLength;
  if (length !== 8) {
    throw new TypeError("must be 8 bytes");
  }
  var bin = new Uint8Array(bytes);
  var view = new DataView(bin.buffer);
  var nr = view.getFloat64(0);
  return nr;
}
exports.bytesToNumber = bytesToNumber;
var hasBigIntSupport = function () {
  try {
    return typeof BigInt(0) === "bigint";
  } catch (err) {
    return false;
  }
}();
var noBigIntError = "BigInt is not supported on this platform";
var bigIntFunctions = {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  bigintToBytes: function bigintToBytes(number) {
    throw new Error(noBigIntError);
  },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  bytesToBigint: function bytesToBigint(bytes) {
    throw new Error(noBigIntError);
  }
};
if (hasBigIntSupport) {
  var big = {
    zero: BigInt(0),
    one: BigInt(1),
    two: BigInt(2),
    eight: BigInt(8),
    ff: BigInt(0xff)
  };
  bigIntFunctions.bigintToBytes = function bigintToBytes(number) {
    if (typeof number !== "bigint") {
      throw new Error("number must be a bigint");
    }
    var bytes = [];
    var negative = number < big.zero;
    do {
      var _byte = Number(number & big.ff); // NOTE: bits are inverted on negative numbers
      bytes.push(_byte);
      number = number >> big.eight;
    } while (number !== (negative ? -big.one : big.zero));
    bytes.reverse(); // little-endian
    if (negative ? bytes[0] < 128 : bytes[0] >= 128) {
      bytes.unshift(negative ? 255 : 0); // extra sign byte needed
    }
    return bytes;
  };
  bigIntFunctions.bytesToBigint = function bytesToBigint(bytes) {
    var negative = bytes[0] >= 128;
    var number = big.zero;
    var _iterator = _createForOfIteratorHelper(bytes),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var b = _step.value;
        if (negative) {
          b = ~b & 0xff;
        } // Invert the bits
        number = (number << big.eight) + BigInt(b);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (negative) {
      number = -(number + big.one);
    }
    return number;
  };
}
exports.bigintToBytes = bigIntFunctions.bigintToBytes;
exports.bytesToBigint = bigIntFunctions.bytesToBigint;
/**
 * Converts a string to a utf-8 encoded Uint8Array
 */
function encodeString(str) {
  if (typeof TextEncoder !== "undefined") {
    // Modern browsers, Node.js v11.0.0+ (or v8.3.0+ with util.TextEncoder)
    var encoder = new TextEncoder();
    return encoder.encode(str);
  } else if (typeof Buffer === "function") {
    // Node.js
    var buf = Buffer.from(str, "utf-8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  } else {
    // Older browsers. Manually encode
    var arr = [];
    for (var i = 0; i < str.length; i++) {
      var code = str.charCodeAt(i);
      if (code > 128) {
        // Attempt simple UTF-8 conversion. See https://en.wikipedia.org/wiki/UTF-8
        if ((code & 0xd800) === 0xd800) {
          // code starts with 1101 10...: this is a 2-part utf-16 char code
          var nextCode = str.charCodeAt(i + 1);
          if ((nextCode & 0xdc00) !== 0xdc00) {
            // next code must start with 1101 11...
            throw new Error("follow-up utf-16 character does not start with 0xDC00");
          }
          i++;
          var p1 = code & 0x3ff; // Only use last 10 bits
          var p2 = nextCode & 0x3ff;
          // Create code point from these 2: (see https://en.wikipedia.org/wiki/UTF-16)
          code = 0x10000 | p1 << 10 | p2;
        }
        if (code < 2048) {
          // Use 2 bytes for 11 bit value, first byte starts with 110xxxxx (0xc0), 2nd byte with 10xxxxxx (0x80)
          var b1 = 0xc0 | code >> 6 & 0x1f; // 0xc0 = 11000000, 0x1f = 11111
          var b2 = 0x80 | code & 0x3f; // 0x80 = 10000000, 0x3f = 111111
          arr.push(b1, b2);
        } else if (code < 65536) {
          // Use 3 bytes for 16-bit value, bits per byte: 4, 6, 6
          var _b = 0xe0 | code >> 12 & 0xf; // 0xe0 = 11100000, 0xf = 1111
          var _b2 = 0x80 | code >> 6 & 0x3f; // 0x80 = 10000000, 0x3f = 111111
          var b3 = 0x80 | code & 0x3f;
          arr.push(_b, _b2, b3);
        } else if (code < 2097152) {
          // Use 4 bytes for 21-bit value, bits per byte: 3, 6, 6, 6
          var _b3 = 0xf0 | code >> 18 & 0x7; // 0xf0 = 11110000, 0x7 = 111
          var _b4 = 0x80 | code >> 12 & 0x3f; // 0x80 = 10000000, 0x3f = 111111
          var _b5 = 0x80 | code >> 6 & 0x3f; // 0x80 = 10000000, 0x3f = 111111
          var b4 = 0x80 | code & 0x3f;
          arr.push(_b3, _b4, _b5, b4);
        } else {
          throw new Error("Cannot convert character ".concat(str.charAt(i), " (code ").concat(code, ") to utf-8"));
        }
      } else {
        arr.push(code < 128 ? code : 63); // 63 = ?
      }
    }
    return new Uint8Array(arr);
  }
}
exports.encodeString = encodeString;
/**
 * Converts a utf-8 encoded buffer to string
 */
function decodeString(buffer) {
  // ArrayBuffer|
  if (typeof TextDecoder !== "undefined") {
    // Modern browsers, Node.js v11.0.0+ (or v8.3.0+ with util.TextDecoder)
    var decoder = new TextDecoder();
    if (buffer instanceof Uint8Array) {
      return decoder.decode(buffer);
    }
    var buf = Uint8Array.from(buffer);
    return decoder.decode(buf);
  } else if (typeof Buffer === "function") {
    // Node.js (v10 and below)
    if (buffer instanceof Array) {
      buffer = Uint8Array.from(buffer); // convert to typed array
    }
    if (!(buffer instanceof Buffer) && "buffer" in buffer && buffer.buffer instanceof ArrayBuffer) {
      var typedArray = buffer;
      buffer = Buffer.from(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength); // Convert typed array to node.js Buffer
    }
    if (!(buffer instanceof Buffer)) {
      throw new Error("Unsupported buffer argument");
    }
    return buffer.toString("utf-8");
  } else {
    // Older browsers. Manually decode!
    if (!(buffer instanceof Uint8Array) && "buffer" in buffer && buffer["buffer"] instanceof ArrayBuffer) {
      // Convert TypedArray to Uint8Array
      var _typedArray = buffer;
      buffer = new Uint8Array(_typedArray.buffer, _typedArray.byteOffset, _typedArray.byteLength);
    }
    if (buffer instanceof Buffer || buffer instanceof Array || buffer instanceof Uint8Array) {
      var str = "";
      for (var i = 0; i < buffer.length; i++) {
        var code = buffer[i];
        if (code > 128) {
          // Decode Unicode character
          if ((code & 0xf0) === 0xf0) {
            // 4 byte char
            var b1 = code,
              b2 = buffer[i + 1],
              b3 = buffer[i + 2],
              b4 = buffer[i + 3];
            code = (b1 & 0x7) << 18 | (b2 & 0x3f) << 12 | (b3 & 0x3f) << 6 | b4 & 0x3f;
            i += 3;
          } else if ((code & 0xe0) === 0xe0) {
            // 3 byte char
            var _b6 = code,
              _b7 = buffer[i + 1],
              _b8 = buffer[i + 2];
            code = (_b6 & 0xf) << 12 | (_b7 & 0x3f) << 6 | _b8 & 0x3f;
            i += 2;
          } else if ((code & 0xc0) === 0xc0) {
            // 2 byte char
            var _b9 = code,
              _b10 = buffer[i + 1];
            code = (_b9 & 0x1f) << 6 | _b10 & 0x3f;
            i++;
          } else {
            throw new Error("invalid utf-8 data");
          }
        }
        if (code >= 65536) {
          // Split into 2-part utf-16 char codes
          code ^= 0x10000;
          var p1 = 0xd800 | code >> 10;
          var p2 = 0xdc00 | code & 0x3ff;
          str += String.fromCharCode(p1);
          str += String.fromCharCode(p2);
        } else {
          str += String.fromCharCode(code);
        }
      }
      return str;
    } else {
      throw new Error("Unsupported buffer argument");
    }
  }
}
exports.decodeString = decodeString;
function concatTypedArrays(a, b) {
  var c = new a.constructor(a.length + b.length);
  c.set(a);
  c.set(b, a.length);
  return c;
}
exports.concatTypedArrays = concatTypedArrays;
function cloneObject(original) {
  var stack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var _a;
  if (((_a = original === null || original === void 0 ? void 0 : original.constructor) === null || _a === void 0 ? void 0 : _a.name) === "DataSnapshot") {
    throw new TypeError("Object to clone is a DataSnapshot (path \"".concat(original.ref.path, "\")"));
  }
  var checkAndFixTypedArray = function checkAndFixTypedArray(obj) {
    if (obj !== null && _typeof(obj) === "object" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && ["Buffer", "Uint8Array", "Int8Array", "Uint16Array", "Int16Array", "Uint32Array", "Int32Array", "BigUint64Array", "BigInt64Array"].includes(obj.constructor.name)) {
      // FIX for typed array being converted to objects with numeric properties:
      // Convert Buffer or TypedArray to ArrayBuffer
      obj = obj.buffer.slice(obj.byteOffset, obj.byteOffset + obj.byteLength);
    }
    return obj;
  };
  original = checkAndFixTypedArray(original);
  if (_typeof(original) !== "object" || original === null || original instanceof Date || original instanceof ArrayBuffer || original instanceof PathInfo_1.PathReference || original instanceof RegExp) {
    return original;
  }
  var cloneValue = function cloneValue(val) {
    if (stack.indexOf(val) >= 0) {
      throw new ReferenceError("object contains a circular reference");
    }
    val = checkAndFixTypedArray(val);
    if (val === null || val instanceof Date || val instanceof ArrayBuffer || val instanceof PathInfo_1.PathReference || val instanceof RegExp) {
      // || val instanceof ID
      return val;
    } else if (_typeof(val) === "object") {
      stack.push(val);
      val = cloneObject(val, stack);
      stack.pop();
      return val;
    } else {
      return val; // Anything other can just be copied
    }
  };
  if (typeof stack === "undefined") {
    stack = [original];
  }
  var clone = original instanceof Array ? [] : original instanceof PartialArray_1.PartialArray ? new PartialArray_1.PartialArray() : {};
  Object.keys(original).forEach(function (key) {
    var val = original[key];
    if (typeof val === "function") {
      return; // skip functions
    }
    clone[key] = cloneValue(val);
  });
  return clone;
}
exports.cloneObject = cloneObject;
var isTypedArray = function isTypedArray(val) {
  return _typeof(val) === "object" && ["ArrayBuffer", "Buffer", "Uint8Array", "Uint16Array", "Uint32Array", "Int8Array", "Int16Array", "Int32Array"].includes(val.constructor.name);
};
// CONSIDER: updating isTypedArray to: const isTypedArray = val => typeof val === 'object' && 'buffer' in val && 'byteOffset' in val && 'byteLength' in val;
function valuesAreEqual(val1, val2) {
  if (val1 === val2) {
    return true;
  }
  if (_typeof(val1) !== _typeof(val2)) {
    return false;
  }
  if (_typeof(val1) === "object" || _typeof(val2) === "object") {
    if (val1 === null || val2 === null) {
      return false;
    }
    if (val1 instanceof PathInfo_1.PathReference || val2 instanceof PathInfo_1.PathReference) {
      return val1 instanceof PathInfo_1.PathReference && val2 instanceof PathInfo_1.PathReference && val1.path === val2.path;
    }
    if (val1 instanceof Date || val2 instanceof Date) {
      return val1 instanceof Date && val2 instanceof Date && val1.getTime() === val2.getTime();
    }
    if (val1 instanceof Array || val2 instanceof Array) {
      return val1 instanceof Array && val2 instanceof Array && val1.length === val2.length && val1.every(function (item, i) {
        return valuesAreEqual(val1[i], val2[i]);
      });
    }
    if (isTypedArray(val1) || isTypedArray(val2)) {
      if (!isTypedArray(val1) || !isTypedArray(val2) || val1.byteLength === val2.byteLength) {
        return false;
      }
      var typed1 = val1 instanceof ArrayBuffer ? new Uint8Array(val1) : new Uint8Array(val1.buffer, val1.byteOffset, val1.byteLength),
        typed2 = val2 instanceof ArrayBuffer ? new Uint8Array(val2) : new Uint8Array(val2.buffer, val2.byteOffset, val2.byteLength);
      return typed1.every(function (val, i) {
        return typed2[i] === val;
      });
    }
    var keys1 = Object.keys(val1),
      keys2 = Object.keys(val2);
    return keys1.length === keys2.length && keys1.every(function (key) {
      return keys2.includes(key);
    }) && keys1.every(function (key) {
      return valuesAreEqual(val1[key], val2[key]);
    });
  }
  return false;
}
exports.valuesAreEqual = valuesAreEqual;
var ObjectDifferences = /*#__PURE__*/function () {
  function ObjectDifferences(added, removed, changed) {
    _classCallCheck(this, ObjectDifferences);
    this.added = added;
    this.removed = removed;
    this.changed = changed;
  }
  return _createClass(ObjectDifferences, [{
    key: "forChild",
    value: function forChild(key) {
      if (this.added.includes(key)) {
        return "added";
      }
      if (this.removed.includes(key)) {
        return "removed";
      }
      var changed = this.changed.find(function (ch) {
        return ch.key === key;
      });
      return changed ? changed.change : "identical";
    }
  }]);
}();
exports.ObjectDifferences = ObjectDifferences;
var isDate = function isDate(value) {
  return value instanceof Date || typeof value === "string" && /^\d+$/.test(value) !== true && !isNaN(Date.parse(value));
};
exports.isDate = isDate;
function compareValues(oldVal, newVal) {
  var sortedResults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var voids = [undefined, null];
  if (oldVal === newVal) {
    return "identical";
  } else if (voids.indexOf(oldVal) >= 0 && voids.indexOf(newVal) < 0) {
    return "added";
  } else if (voids.indexOf(oldVal) < 0 && voids.indexOf(newVal) >= 0) {
    return "removed";
  } else if (_typeof(oldVal) !== _typeof(newVal)) {
    return "changed";
  } else if (isTypedArray(oldVal) || isTypedArray(newVal)) {
    // One or both values are typed arrays.
    if (!isTypedArray(oldVal) || !isTypedArray(newVal)) {
      return "changed";
    }
    // Both are typed. Compare lengths and byte content of typed arrays
    var typed1 = oldVal instanceof Uint8Array ? oldVal : oldVal instanceof ArrayBuffer ? new Uint8Array(oldVal) : new Uint8Array(oldVal.buffer, oldVal.byteOffset, oldVal.byteLength);
    var typed2 = newVal instanceof Uint8Array ? newVal : newVal instanceof ArrayBuffer ? new Uint8Array(newVal) : new Uint8Array(newVal.buffer, newVal.byteOffset, newVal.byteLength);
    return typed1.byteLength === typed2.byteLength && typed1.every(function (val, i) {
      return typed2[i] === val;
    }) ? "identical" : "changed";
  } else if ((0, exports.isDate)(oldVal) || (0, exports.isDate)(newVal)) {
    return (0, exports.isDate)(oldVal) && (0, exports.isDate)(newVal) && new Date(oldVal).getTime() === new Date(newVal).getTime() ? "identical" : "changed";
  } else if (oldVal instanceof PathInfo_1.PathReference || newVal instanceof PathInfo_1.PathReference) {
    return oldVal instanceof PathInfo_1.PathReference && newVal instanceof PathInfo_1.PathReference && oldVal.path === newVal.path ? "identical" : "changed";
  } else if (_typeof(oldVal) === "object") {
    // Do key-by-key comparison of objects
    var isArray = oldVal instanceof Array;
    var getKeys = function getKeys(obj) {
      var keys = Object.keys(obj).filter(function (key) {
        return !voids.includes(obj[key]);
      });
      if (isArray) {
        keys = keys.map(function (v) {
          return parseInt(v);
        });
      }
      return keys;
    };
    var oldKeys = getKeys(oldVal);
    var newKeys = getKeys(newVal);
    var removedKeys = oldKeys.filter(function (key) {
      return !newKeys.includes(key);
    });
    var addedKeys = newKeys.filter(function (key) {
      return !oldKeys.includes(key);
    });
    var changedKeys = newKeys.reduce(function (changed, key) {
      if (oldKeys.includes(key)) {
        var val1 = oldVal[key];
        var val2 = newVal[key];
        var c = compareValues(val1, val2);
        if (c !== "identical") {
          changed.push({
            key: key,
            change: c
          });
        }
      }
      return changed;
    }, []);
    if (addedKeys.length === 0 && removedKeys.length === 0 && changedKeys.length === 0) {
      return "identical";
    } else {
      return new ObjectDifferences(addedKeys, removedKeys, sortedResults ? changedKeys.sort(function (a, b) {
        return a.key < b.key ? -1 : 1;
      }) : changedKeys);
    }
  }
  return "changed";
}
exports.compareValues = compareValues;
function getMutations(oldVal, newVal) {
  var sortedResults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var process = function process(target, compareResult, prev, val) {
    switch (compareResult) {
      case "identical":
        return [];
      case "changed":
        return [{
          target: target,
          prev: prev,
          val: val
        }];
      case "added":
        return [{
          target: target,
          prev: null,
          val: val
        }];
      case "removed":
        return [{
          target: target,
          prev: prev,
          val: null
        }];
      default:
        {
          var changes = [];
          compareResult.added.forEach(function (key) {
            return changes.push({
              target: target.concat(key),
              prev: null,
              val: val[key]
            });
          });
          compareResult.removed.forEach(function (key) {
            return changes.push({
              target: target.concat(key),
              prev: prev[key],
              val: null
            });
          });
          compareResult.changed.forEach(function (item) {
            var childChanges = process(target.concat(item.key), item.change, prev[item.key], val[item.key]);
            changes = changes.concat(childChanges);
          });
          return changes;
        }
    }
  };
  var compareResult = compareValues(oldVal, newVal, sortedResults);
  return process([], compareResult, oldVal, newVal);
}
exports.getMutations = getMutations;
function getChildValues(childKey, oldValue, newValue) {
  oldValue = !oldValue || !oldValue[childKey] ? null : oldValue[childKey];
  if (typeof oldValue === "undefined") {
    oldValue = null;
  }
  newValue = !newValue || !newValue[childKey] ? null : newValue[childKey];
  if (typeof newValue === "undefined") {
    newValue = null;
  }
  return {
    oldValue: oldValue,
    newValue: newValue
  };
}
exports.getChildValues = getChildValues;
function defer(fn) {
  process_1["default"].nextTick(fn);
}
exports.defer = defer;
function getGlobalObject() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("Unable to locate global object.");
}
exports.getGlobalObject = getGlobalObject;
function contains(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
exports.contains = contains;
function safeGet(obj, key) {
  if (Object.prototype.hasOwnProperty.call(obj, key)) {
    return obj[key];
  } else {
    return undefined;
  }
}
exports.safeGet = safeGet;
function isEmpty(obj) {
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
exports.isEmpty = isEmpty;
/**
 * Deep equal two objects. Support Arrays and Objects.
 */
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  for (var _i = 0, _aKeys = aKeys; _i < _aKeys.length; _i++) {
    var k = _aKeys[_i];
    if (!bKeys.includes(k)) {
      return false;
    }
    var aProp = a[k];
    var bProp = b[k];
    if (isObject(aProp) && isObject(bProp)) {
      if (!deepEqual(aProp, bProp)) {
        return false;
      }
    } else if (aProp !== bProp) {
      return false;
    }
  }
  for (var _i2 = 0, _bKeys = bKeys; _i2 < _bKeys.length; _i2++) {
    var _k = _bKeys[_i2];
    if (!aKeys.includes(_k)) {
      return false;
    }
  }
  return true;
}
exports.deepEqual = deepEqual;
function isObject(thing) {
  return thing !== null && _typeof(thing) === "object";
}
/**
 * Copied from https://stackoverflow.com/a/2117523
 * Generates a new uuid.
 * @public
 */
function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
      v = c === "x" ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
exports.uuidv4 = uuidv4;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"../process":153,"./PartialArray":140,"./PathInfo":141,"buffer":90}],150:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = void 0;
var Assert_1 = require("./Assert");
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return Assert_1.assert;
  }
});

},{"./Assert":135}],151:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

},{}],152:[function(require,module,exports){
"use strict";

var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __exportStar = void 0 && (void 0).__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectCollection = exports.PartialArray = exports.SimpleObservable = exports.SchemaDefinition = exports.SimpleEventEmitter = exports.ascii85 = exports.Utils = exports.TypeMappings = exports.Transport = exports.EventSubscription = exports.EventPublisher = exports.EventStream = exports.PathInfo = exports.PathReference = exports.ID = exports.DebugLogger = exports.Lib = exports.MutationsDataSnapshot = exports.DataSnapshot = exports.DataReferencesArray = exports.DataSnapshotsArray = exports.QueryDataRetrievalOptions = exports.DataRetrievalOptions = exports.DataReferenceQuery = exports.DataReference = exports.Types = exports.Api = exports.DataBaseSettings = exports.DataBase = void 0;
var DataBase_1 = require("./DataBase");
Object.defineProperty(exports, "DataBase", {
  enumerable: true,
  get: function get() {
    return DataBase_1.DataBase;
  }
});
Object.defineProperty(exports, "DataBaseSettings", {
  enumerable: true,
  get: function get() {
    return DataBase_1.DataBaseSettings;
  }
});
var api_1 = require("./DataBase/api");
Object.defineProperty(exports, "Api", {
  enumerable: true,
  get: function get() {
    return __importDefault(api_1)["default"];
  }
});
exports.Types = __importStar(require("./Types"));
var reference_1 = require("./DataBase/reference");
Object.defineProperty(exports, "DataReference", {
  enumerable: true,
  get: function get() {
    return reference_1.DataReference;
  }
});
Object.defineProperty(exports, "DataReferenceQuery", {
  enumerable: true,
  get: function get() {
    return reference_1.DataReferenceQuery;
  }
});
Object.defineProperty(exports, "DataRetrievalOptions", {
  enumerable: true,
  get: function get() {
    return reference_1.DataRetrievalOptions;
  }
});
Object.defineProperty(exports, "QueryDataRetrievalOptions", {
  enumerable: true,
  get: function get() {
    return reference_1.QueryDataRetrievalOptions;
  }
});
Object.defineProperty(exports, "DataSnapshotsArray", {
  enumerable: true,
  get: function get() {
    return reference_1.DataSnapshotsArray;
  }
});
Object.defineProperty(exports, "DataReferencesArray", {
  enumerable: true,
  get: function get() {
    return reference_1.DataReferencesArray;
  }
});
var snapshot_1 = require("./DataBase/snapshot");
Object.defineProperty(exports, "DataSnapshot", {
  enumerable: true,
  get: function get() {
    return snapshot_1.DataSnapshot;
  }
});
Object.defineProperty(exports, "MutationsDataSnapshot", {
  enumerable: true,
  get: function get() {
    return snapshot_1.MutationsDataSnapshot;
  }
});
exports.Lib = __importStar(require("./Lib"));
var DebugLogger_1 = require("./Lib/DebugLogger");
Object.defineProperty(exports, "DebugLogger", {
  enumerable: true,
  get: function get() {
    return __importDefault(DebugLogger_1)["default"];
  }
});
var ID_1 = require("./Lib/ID");
Object.defineProperty(exports, "ID", {
  enumerable: true,
  get: function get() {
    return __importDefault(ID_1)["default"];
  }
});
var PathInfo_1 = require("./Lib/PathInfo");
Object.defineProperty(exports, "PathReference", {
  enumerable: true,
  get: function get() {
    return PathInfo_1.PathReference;
  }
});
Object.defineProperty(exports, "PathInfo", {
  enumerable: true,
  get: function get() {
    return PathInfo_1.PathInfo;
  }
});
var Subscription_1 = require("./Lib/Subscription");
Object.defineProperty(exports, "EventStream", {
  enumerable: true,
  get: function get() {
    return Subscription_1.EventStream;
  }
});
Object.defineProperty(exports, "EventPublisher", {
  enumerable: true,
  get: function get() {
    return Subscription_1.EventPublisher;
  }
});
Object.defineProperty(exports, "EventSubscription", {
  enumerable: true,
  get: function get() {
    return Subscription_1.EventSubscription;
  }
});
exports.Transport = __importStar(require("./Lib/Transport"));
var TypeMappings_1 = require("./Lib/TypeMappings");
Object.defineProperty(exports, "TypeMappings", {
  enumerable: true,
  get: function get() {
    return __importDefault(TypeMappings_1)["default"];
  }
});
exports.Utils = __importStar(require("./Lib/Utils"));
__exportStar(require("./Lib/SimpleCache"), exports);
var Ascii85_1 = require("./Lib/Ascii85");
Object.defineProperty(exports, "ascii85", {
  enumerable: true,
  get: function get() {
    return Ascii85_1.ascii85;
  }
});
var SimpleEventEmitter_1 = require("./Lib/SimpleEventEmitter");
Object.defineProperty(exports, "SimpleEventEmitter", {
  enumerable: true,
  get: function get() {
    return __importDefault(SimpleEventEmitter_1)["default"];
  }
});
var Schema_1 = require("./Lib/Schema");
Object.defineProperty(exports, "SchemaDefinition", {
  enumerable: true,
  get: function get() {
    return Schema_1.SchemaDefinition;
  }
});
var SimpleObservable_1 = require("./Lib/SimpleObservable");
Object.defineProperty(exports, "SimpleObservable", {
  enumerable: true,
  get: function get() {
    return __importDefault(SimpleObservable_1)["default"];
  }
});
var PartialArray_1 = require("./Lib/PartialArray");
Object.defineProperty(exports, "PartialArray", {
  enumerable: true,
  get: function get() {
    return PartialArray_1.PartialArray;
  }
});
var ObjectCollection_1 = require("./Lib/ObjectCollection");
Object.defineProperty(exports, "ObjectCollection", {
  enumerable: true,
  get: function get() {
    return ObjectCollection_1.ObjectCollection;
  }
});

},{"./DataBase":131,"./DataBase/api":130,"./DataBase/reference":132,"./DataBase/snapshot":133,"./Lib":150,"./Lib/Ascii85":134,"./Lib/DebugLogger":136,"./Lib/ID":137,"./Lib/ObjectCollection":138,"./Lib/PartialArray":140,"./Lib/PathInfo":141,"./Lib/Schema":142,"./Lib/SimpleCache":143,"./Lib/SimpleEventEmitter":144,"./Lib/SimpleObservable":145,"./Lib/Subscription":146,"./Lib/Transport":147,"./Lib/TypeMappings":148,"./Lib/Utils":149,"./Types":151}],153:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = {
  // eslint-disable-next-line @typescript-eslint/ban-types
  nextTick: function nextTick(fn) {
    setTimeout(fn, 0);
  }
};

},{}],154:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = _typeof(val);
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options["long"] ? fmtLong(val) : fmtShort(val);
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],155:[function(require,module,exports){
"use strict";

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};

},{}],156:[function(require,module,exports){
"use strict";

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Backoff = void 0;
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
exports.Backoff = Backoff;
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */
Backoff.prototype.duration = function () {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */
Backoff.prototype.reset = function () {
  this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */
Backoff.prototype.setMin = function (min) {
  this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */
Backoff.prototype.setMax = function (max) {
  this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */
Backoff.prototype.setJitter = function (jitter) {
  this.jitter = jitter;
};

},{}],157:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.connect = exports.io = exports.Socket = exports.Manager = exports.protocol = void 0;
var url_js_1 = require("./url.js");
var manager_js_1 = require("./manager.js");
Object.defineProperty(exports, "Manager", {
  enumerable: true,
  get: function get() {
    return manager_js_1.Manager;
  }
});
var socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", {
  enumerable: true,
  get: function get() {
    return socket_js_1.Socket;
  }
});
var debug_1 = __importDefault(require("debug")); // debug()
var debug = debug_1["default"]("socket.io-client"); // debug()
/**
 * Managers cache.
 */
var cache = {};
function lookup(uri, opts) {
  if (_typeof(uri) === "object") {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};
  var parsed = url_js_1.url(uri, opts.path || "/socket.io");
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id]["nsps"];
  var newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  var io;
  if (newConnection) {
    debug("ignoring socket cache for %s", source);
    io = new manager_js_1.Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug("new io instance for %s", source);
      cache[id] = new manager_js_1.Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
exports.io = lookup;
exports.connect = lookup;
exports["default"] = lookup;
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
  Manager: manager_js_1.Manager,
  Socket: socket_js_1.Socket,
  io: lookup,
  connect: lookup
});
/**
 * Protocol version.
 *
 * @public
 */
var socket_io_parser_1 = require("socket.io-parser");
Object.defineProperty(exports, "protocol", {
  enumerable: true,
  get: function get() {
    return socket_io_parser_1.protocol;
  }
});
module.exports = lookup;

},{"./manager.js":158,"./socket.js":160,"./url.js":161,"debug":95,"socket.io-parser":163}],158:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __createBinding = void 0 && (void 0).__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = void 0 && (void 0).__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Manager = void 0;
var engine_io_client_1 = require("engine.io-client");
var socket_js_1 = require("./socket.js");
var parser = __importStar(require("socket.io-parser"));
var on_js_1 = require("./on.js");
var backo2_js_1 = require("./contrib/backo2.js");
var component_emitter_1 = require("@socket.io/component-emitter");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = debug_1["default"]("socket.io-client:manager"); // debug()
var Manager = /*#__PURE__*/function (_component_emitter_1$) {
  function Manager(uri, opts) {
    var _this;
    _classCallCheck(this, Manager);
    var _a;
    _this = _callSuper(this, Manager);
    _this.nsps = {};
    _this.subs = [];
    if (uri && "object" === _typeof(uri)) {
      opts = uri;
      uri = undefined;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    _this.opts = opts;
    engine_io_client_1.installTimerFunctions(_this, opts);
    _this.reconnection(opts.reconnection !== false);
    _this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    _this.reconnectionDelay(opts.reconnectionDelay || 1000);
    _this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
    _this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
    _this.backoff = new backo2_js_1.Backoff({
      min: _this.reconnectionDelay(),
      max: _this.reconnectionDelayMax(),
      jitter: _this.randomizationFactor()
    });
    _this.timeout(null == opts.timeout ? 20000 : opts.timeout);
    _this._readyState = "closed";
    _this.uri = uri;
    var _parser = opts.parser || parser;
    _this.encoder = new _parser.Encoder();
    _this.decoder = new _parser.Decoder();
    _this._autoConnect = opts.autoConnect !== false;
    if (_this._autoConnect) _this.open();
    return _this;
  }
  _inherits(Manager, _component_emitter_1$);
  return _createClass(Manager, [{
    key: "reconnection",
    value: function reconnection(v) {
      if (!arguments.length) return this._reconnection;
      this._reconnection = !!v;
      return this;
    }
  }, {
    key: "reconnectionAttempts",
    value: function reconnectionAttempts(v) {
      if (v === undefined) return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    }
  }, {
    key: "reconnectionDelay",
    value: function reconnectionDelay(v) {
      var _a;
      if (v === undefined) return this._reconnectionDelay;
      this._reconnectionDelay = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
      return this;
    }
  }, {
    key: "randomizationFactor",
    value: function randomizationFactor(v) {
      var _a;
      if (v === undefined) return this._randomizationFactor;
      this._randomizationFactor = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
      return this;
    }
  }, {
    key: "reconnectionDelayMax",
    value: function reconnectionDelayMax(v) {
      var _a;
      if (v === undefined) return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
      return this;
    }
  }, {
    key: "timeout",
    value: function timeout(v) {
      if (!arguments.length) return this._timeout;
      this._timeout = v;
      return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
  }, {
    key: "maybeReconnectOnOpen",
    value: function maybeReconnectOnOpen() {
      // Only try to reconnect if it's the first time we're connecting
      if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
        // keeps reconnection from firing twice for the same reconnection loop
        this.reconnect();
      }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */
  }, {
    key: "open",
    value: function open(fn) {
      var _this2 = this;
      debug("readyState %s", this._readyState);
      if (~this._readyState.indexOf("open")) return this;
      debug("opening %s", this.uri);
      this.engine = new engine_io_client_1.Socket(this.uri, this.opts);
      var socket = this.engine;
      var self = this;
      this._readyState = "opening";
      this.skipReconnect = false;
      // emit `open`
      var openSubDestroy = on_js_1.on(socket, "open", function () {
        self.onopen();
        fn && fn();
      });
      var onError = function onError(err) {
        debug("error");
        _this2.cleanup();
        _this2._readyState = "closed";
        _this2.emitReserved("error", err);
        if (fn) {
          fn(err);
        } else {
          // Only do this if there is no fn to handle the error
          _this2.maybeReconnectOnOpen();
        }
      };
      // emit `error`
      var errorSub = on_js_1.on(socket, "error", onError);
      if (false !== this._timeout) {
        var timeout = this._timeout;
        debug("connect attempt will timeout after %d", timeout);
        // set timer
        var timer = this.setTimeoutFn(function () {
          debug("connect attempt timed out after %d", timeout);
          openSubDestroy();
          onError(new Error("timeout"));
          socket.close();
        }, timeout);
        if (this.opts.autoUnref) {
          timer.unref();
        }
        this.subs.push(function () {
          _this2.clearTimeoutFn(timer);
        });
      }
      this.subs.push(openSubDestroy);
      this.subs.push(errorSub);
      return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */
  }, {
    key: "connect",
    value: function connect(fn) {
      return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
  }, {
    key: "onopen",
    value: function onopen() {
      debug("open");
      // clear old subs
      this.cleanup();
      // mark as open
      this._readyState = "open";
      this.emitReserved("open");
      // add new subs
      var socket = this.engine;
      this.subs.push(on_js_1.on(socket, "ping", this.onping.bind(this)), on_js_1.on(socket, "data", this.ondata.bind(this)), on_js_1.on(socket, "error", this.onerror.bind(this)), on_js_1.on(socket, "close", this.onclose.bind(this)), on_js_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
  }, {
    key: "onping",
    value: function onping() {
      this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
  }, {
    key: "ondata",
    value: function ondata(data) {
      try {
        this.decoder.add(data);
      } catch (e) {
        this.onclose("parse error", e);
      }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
  }, {
    key: "ondecoded",
    value: function ondecoded(packet) {
      var _this3 = this;
      // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
      engine_io_client_1.nextTick(function () {
        _this3.emitReserved("packet", packet);
      }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
  }, {
    key: "onerror",
    value: function onerror(err) {
      debug("error", err);
      this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */
  }, {
    key: "socket",
    value: function socket(nsp, opts) {
      var socket = this.nsps[nsp];
      if (!socket) {
        socket = new socket_js_1.Socket(this, nsp, opts);
        this.nsps[nsp] = socket;
      } else if (this._autoConnect && !socket.active) {
        socket.connect();
      }
      return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */
  }, {
    key: "_destroy",
    value: function _destroy(socket) {
      var nsps = Object.keys(this.nsps);
      for (var _i = 0, _nsps = nsps; _i < _nsps.length; _i++) {
        var nsp = _nsps[_i];
        var _socket = this.nsps[nsp];
        if (_socket.active) {
          debug("socket %s is still active, skipping close", nsp);
          return;
        }
      }
      this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */
  }, {
    key: "_packet",
    value: function _packet(packet) {
      debug("writing packet %j", packet);
      var encodedPackets = this.encoder.encode(packet);
      for (var i = 0; i < encodedPackets.length; i++) {
        this.engine.write(encodedPackets[i], packet.options);
      }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
  }, {
    key: "cleanup",
    value: function cleanup() {
      debug("cleanup");
      this.subs.forEach(function (subDestroy) {
        return subDestroy();
      });
      this.subs.length = 0;
      this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
  }, {
    key: "_close",
    value: function _close() {
      debug("disconnect");
      this.skipReconnect = true;
      this._reconnecting = false;
      this.onclose("forced close");
      if (this.engine) this.engine.close();
    }
    /**
     * Alias for close()
     *
     * @private
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      return this._close();
    }
    /**
     * Called upon engine close.
     *
     * @private
     */
  }, {
    key: "onclose",
    value: function onclose(reason, description) {
      debug("closed due to %s", reason);
      this.cleanup();
      this.backoff.reset();
      this._readyState = "closed";
      this.emitReserved("close", reason, description);
      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
  }, {
    key: "reconnect",
    value: function reconnect() {
      var _this4 = this;
      if (this._reconnecting || this.skipReconnect) return this;
      var self = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug("reconnect failed");
        this.backoff.reset();
        this.emitReserved("reconnect_failed");
        this._reconnecting = false;
      } else {
        var delay = this.backoff.duration();
        debug("will wait %dms before reconnect attempt", delay);
        this._reconnecting = true;
        var timer = this.setTimeoutFn(function () {
          if (self.skipReconnect) return;
          debug("attempting reconnect");
          _this4.emitReserved("reconnect_attempt", self.backoff.attempts);
          // check again for the case socket closed in above events
          if (self.skipReconnect) return;
          self.open(function (err) {
            if (err) {
              debug("reconnect attempt error");
              self._reconnecting = false;
              self.reconnect();
              _this4.emitReserved("reconnect_error", err);
            } else {
              debug("reconnect success");
              self.onreconnect();
            }
          });
        }, delay);
        if (this.opts.autoUnref) {
          timer.unref();
        }
        this.subs.push(function () {
          _this4.clearTimeoutFn(timer);
        });
      }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
  }, {
    key: "onreconnect",
    value: function onreconnect() {
      var attempt = this.backoff.attempts;
      this._reconnecting = false;
      this.backoff.reset();
      this.emitReserved("reconnect", attempt);
    }
  }]);
}(component_emitter_1.Emitter);
exports.Manager = Manager;

},{"./contrib/backo2.js":156,"./on.js":159,"./socket.js":160,"@socket.io/component-emitter":39,"debug":95,"engine.io-client":102,"socket.io-parser":163}],159:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.on = void 0;
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}
exports.on = on;

},{}],160:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Socket = void 0;
var socket_io_parser_1 = require("socket.io-parser");
var on_js_1 = require("./on.js");
var component_emitter_1 = require("@socket.io/component-emitter");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = debug_1["default"]("socket.io-client:socket"); // debug()
/**
 * Internal events.
 * These events can't be emitted by the user.
 */
var RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
/**
 * A Socket is the fundamental class for interacting with the server.
 *
 * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
 *
 * @example
 * const socket = io();
 *
 * socket.on("connect", () => {
 *   console.log("connected");
 * });
 *
 * // send an event to the server
 * socket.emit("foo", "bar");
 *
 * socket.on("foobar", () => {
 *   // an event was received from the server
 * });
 *
 * // upon disconnection
 * socket.on("disconnect", (reason) => {
 *   console.log(`disconnected due to ${reason}`);
 * });
 */
var Socket = /*#__PURE__*/function (_component_emitter_1$) {
  /**
   * `Socket` constructor.
   */
  function Socket(io, nsp, opts) {
    var _this;
    _classCallCheck(this, Socket);
    _this = _callSuper(this, Socket);
    /**
     * Whether the socket is currently connected to the server.
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.connected); // true
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.connected); // false
     * });
     */
    _this.connected = false;
    /**
     * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
     * be transmitted by the server.
     */
    _this.recovered = false;
    /**
     * Buffer for packets received before the CONNECT packet
     */
    _this.receiveBuffer = [];
    /**
     * Buffer for packets that will be sent once the socket is connected
     */
    _this.sendBuffer = [];
    /**
     * The queue of packets to be sent with retry in case of failure.
     *
     * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
     * @private
     */
    _this._queue = [];
    /**
     * A sequence to generate the ID of the {@link QueuedPacket}.
     * @private
     */
    _this._queueSeq = 0;
    _this.ids = 0;
    /**
     * A map containing acknowledgement handlers.
     *
     * The `withError` attribute is used to differentiate handlers that accept an error as first argument:
     *
     * - `socket.emit("test", (err, value) => { ... })` with `ackTimeout` option
     * - `socket.timeout(5000).emit("test", (err, value) => { ... })`
     * - `const value = await socket.emitWithAck("test")`
     *
     * From those that don't:
     *
     * - `socket.emit("test", (value) => { ... });`
     *
     * In the first case, the handlers will be called with an error when:
     *
     * - the timeout is reached
     * - the socket gets disconnected
     *
     * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive
     * an acknowledgement from the server.
     *
     * @private
     */
    _this.acks = {};
    _this.flags = {};
    _this.io = io;
    _this.nsp = nsp;
    if (opts && opts.auth) {
      _this.auth = opts.auth;
    }
    _this._opts = Object.assign({}, opts);
    if (_this.io._autoConnect) _this.open();
    return _this;
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  _inherits(Socket, _component_emitter_1$);
  return _createClass(Socket, [{
    key: "disconnected",
    get: function get() {
      return !this.connected;
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
  }, {
    key: "subEvents",
    value: function subEvents() {
      if (this.subs) return;
      var io = this.io;
      this.subs = [on_js_1.on(io, "open", this.onopen.bind(this)), on_js_1.on(io, "packet", this.onpacket.bind(this)), on_js_1.on(io, "error", this.onerror.bind(this)), on_js_1.on(io, "close", this.onclose.bind(this))];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */
  }, {
    key: "active",
    get: function get() {
      return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */
  }, {
    key: "connect",
    value: function connect() {
      if (this.connected) return this;
      this.subEvents();
      if (!this.io["_reconnecting"]) this.io.open(); // ensure open
      if ("open" === this.io._readyState) this.onopen();
      return this;
    }
    /**
     * Alias for {@link connect()}.
     */
  }, {
    key: "open",
    value: function open() {
      return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */
  }, {
    key: "send",
    value: function send() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      args.unshift("message");
      this.emit.apply(this, args);
      return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */
  }, {
    key: "emit",
    value: function emit(ev) {
      if (RESERVED_EVENTS.hasOwnProperty(ev)) {
        throw new Error('"' + ev.toString() + '" is a reserved event name');
      }
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      args.unshift(ev);
      if (this._opts.retries && !this.flags.fromQueue && !this.flags["volatile"]) {
        this._addToQueue(args);
        return this;
      }
      var packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: args
      };
      packet.options = {};
      packet.options.compress = this.flags.compress !== false;
      // event ack callback
      if ("function" === typeof args[args.length - 1]) {
        var id = this.ids++;
        debug("emitting packet with ack id %d", id);
        var ack = args.pop();
        this._registerAckCallback(id, ack);
        packet.id = id;
      }
      var isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
      var discardPacket = this.flags["volatile"] && (!isTransportWritable || !this.connected);
      if (discardPacket) {
        debug("discard packet as the transport is not currently writable");
      } else if (this.connected) {
        this.notifyOutgoingListeners(packet);
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }
      this.flags = {};
      return this;
    }
    /**
     * @private
     */
  }, {
    key: "_registerAckCallback",
    value: function _registerAckCallback(id, ack) {
      var _this2 = this;
      var _a;
      var timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
      if (timeout === undefined) {
        this.acks[id] = ack;
        return;
      }
      // @ts-ignore
      var timer = this.io.setTimeoutFn(function () {
        delete _this2.acks[id];
        for (var i = 0; i < _this2.sendBuffer.length; i++) {
          if (_this2.sendBuffer[i].id === id) {
            debug("removing packet with ack id %d from the buffer", id);
            _this2.sendBuffer.splice(i, 1);
          }
        }
        debug("event with ack id %d has timed out after %d ms", id, timeout);
        ack.call(_this2, new Error("operation has timed out"));
      }, timeout);
      var fn = function fn() {
        // @ts-ignore
        _this2.io.clearTimeoutFn(timer);
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        ack.apply(_this2, args);
      };
      fn.withError = true;
      this.acks[id] = fn;
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */
  }, {
    key: "emitWithAck",
    value: function emitWithAck(ev) {
      var _this3 = this;
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      return new Promise(function (resolve, reject) {
        var fn = function fn(arg1, arg2) {
          return arg1 ? reject(arg1) : resolve(arg2);
        };
        fn.withError = true;
        args.push(fn);
        _this3.emit.apply(_this3, [ev].concat(args));
      });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */
  }, {
    key: "_addToQueue",
    value: function _addToQueue(args) {
      var _this4 = this;
      var ack;
      if (typeof args[args.length - 1] === "function") {
        ack = args.pop();
      }
      var packet = {
        id: this._queueSeq++,
        tryCount: 0,
        pending: false,
        args: args,
        flags: Object.assign({
          fromQueue: true
        }, this.flags)
      };
      args.push(function (err) {
        if (packet !== _this4._queue[0]) {
          // the packet has already been acknowledged
          return;
        }
        var hasError = err !== null;
        if (hasError) {
          if (packet.tryCount > _this4._opts.retries) {
            debug("packet [%d] is discarded after %d tries", packet.id, packet.tryCount);
            _this4._queue.shift();
            if (ack) {
              ack(err);
            }
          }
        } else {
          debug("packet [%d] was successfully sent", packet.id);
          _this4._queue.shift();
          if (ack) {
            for (var _len5 = arguments.length, responseArgs = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
              responseArgs[_key5 - 1] = arguments[_key5];
            }
            ack.apply(void 0, [null].concat(responseArgs));
          }
        }
        packet.pending = false;
        return _this4._drainQueue();
      });
      this._queue.push(packet);
      this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */
  }, {
    key: "_drainQueue",
    value: function _drainQueue() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      debug("draining queue");
      if (!this.connected || this._queue.length === 0) {
        return;
      }
      var packet = this._queue[0];
      if (packet.pending && !force) {
        debug("packet [%d] has already been sent and is waiting for an ack", packet.id);
        return;
      }
      packet.pending = true;
      packet.tryCount++;
      debug("sending packet [%d] (try n°%d)", packet.id, packet.tryCount);
      this.flags = packet.flags;
      this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */
  }, {
    key: "packet",
    value: function packet(_packet) {
      _packet.nsp = this.nsp;
      this.io._packet(_packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */
  }, {
    key: "onopen",
    value: function onopen() {
      var _this5 = this;
      debug("transport is open - connecting");
      if (typeof this.auth == "function") {
        this.auth(function (data) {
          _this5._sendConnectPacket(data);
        });
      } else {
        this._sendConnectPacket(this.auth);
      }
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */
  }, {
    key: "_sendConnectPacket",
    value: function _sendConnectPacket(data) {
      this.packet({
        type: socket_io_parser_1.PacketType.CONNECT,
        data: this._pid ? Object.assign({
          pid: this._pid,
          offset: this._lastOffset
        }, data) : data
      });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */
  }, {
    key: "onerror",
    value: function onerror(err) {
      if (!this.connected) {
        this.emitReserved("connect_error", err);
      }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */
  }, {
    key: "onclose",
    value: function onclose(reason, description) {
      debug("close (%s)", reason);
      this.connected = false;
      delete this.id;
      this.emitReserved("disconnect", reason, description);
      this._clearAcks();
    }
    /**
     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
     * the server.
     *
     * @private
     */
  }, {
    key: "_clearAcks",
    value: function _clearAcks() {
      var _this6 = this;
      Object.keys(this.acks).forEach(function (id) {
        var isBuffered = _this6.sendBuffer.some(function (packet) {
          return String(packet.id) === id;
        });
        if (!isBuffered) {
          // note: handlers that do not accept an error as first argument are ignored here
          var ack = _this6.acks[id];
          delete _this6.acks[id];
          if (ack.withError) {
            ack.call(_this6, new Error("socket has been disconnected"));
          }
        }
      });
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */
  }, {
    key: "onpacket",
    value: function onpacket(packet) {
      var sameNamespace = packet.nsp === this.nsp;
      if (!sameNamespace) return;
      switch (packet.type) {
        case socket_io_parser_1.PacketType.CONNECT:
          if (packet.data && packet.data.sid) {
            this.onconnect(packet.data.sid, packet.data.pid);
          } else {
            this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          }
          break;
        case socket_io_parser_1.PacketType.EVENT:
        case socket_io_parser_1.PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;
        case socket_io_parser_1.PacketType.ACK:
        case socket_io_parser_1.PacketType.BINARY_ACK:
          this.onack(packet);
          break;
        case socket_io_parser_1.PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case socket_io_parser_1.PacketType.CONNECT_ERROR:
          this.destroy();
          var err = new Error(packet.data.message);
          // @ts-ignore
          err.data = packet.data.data;
          this.emitReserved("connect_error", err);
          break;
      }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */
  }, {
    key: "onevent",
    value: function onevent(packet) {
      var args = packet.data || [];
      debug("emitting event %j", args);
      if (null != packet.id) {
        debug("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }
      if (this.connected) {
        this.emitEvent(args);
      } else {
        this.receiveBuffer.push(Object.freeze(args));
      }
    }
  }, {
    key: "emitEvent",
    value: function emitEvent(args) {
      if (this._anyListeners && this._anyListeners.length) {
        var listeners = this._anyListeners.slice();
        var _iterator = _createForOfIteratorHelper(listeners),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var listener = _step.value;
            listener.apply(this, args);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      _get(_getPrototypeOf(Socket.prototype), "emit", this).apply(this, args);
      if (this._pid && args.length && typeof args[args.length - 1] === "string") {
        this._lastOffset = args[args.length - 1];
      }
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
  }, {
    key: "ack",
    value: function ack(id) {
      var self = this;
      var sent = false;
      return function () {
        // prevent double callbacks
        if (sent) return;
        sent = true;
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        debug("sending ack %j", args);
        self.packet({
          type: socket_io_parser_1.PacketType.ACK,
          id: id,
          data: args
        });
      };
    }
    /**
     * Called upon a server acknowledgement.
     *
     * @param packet
     * @private
     */
  }, {
    key: "onack",
    value: function onack(packet) {
      var ack = this.acks[packet.id];
      if (typeof ack !== "function") {
        debug("bad ack %s", packet.id);
        return;
      }
      delete this.acks[packet.id];
      debug("calling ack %s with %j", packet.id, packet.data);
      // @ts-ignore FIXME ack is incorrectly inferred as 'never'
      if (ack.withError) {
        packet.data.unshift(null);
      }
      // @ts-ignore
      ack.apply(this, packet.data);
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
  }, {
    key: "onconnect",
    value: function onconnect(id, pid) {
      debug("socket connected with id %s", id);
      this.id = id;
      this.recovered = pid && this._pid === pid;
      this._pid = pid; // defined only if connection state recovery is enabled
      this.connected = true;
      this.emitBuffered();
      this.emitReserved("connect");
      this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
  }, {
    key: "emitBuffered",
    value: function emitBuffered() {
      var _this7 = this;
      this.receiveBuffer.forEach(function (args) {
        return _this7.emitEvent(args);
      });
      this.receiveBuffer = [];
      this.sendBuffer.forEach(function (packet) {
        _this7.notifyOutgoingListeners(packet);
        _this7.packet(packet);
      });
      this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
  }, {
    key: "ondisconnect",
    value: function ondisconnect() {
      debug("server disconnect (%s)", this.nsp);
      this.destroy();
      this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.subs) {
        // clean subscriptions to avoid reconnections
        this.subs.forEach(function (subDestroy) {
          return subDestroy();
        });
        this.subs = undefined;
      }
      this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */
  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this.connected) {
        debug("performing disconnect (%s)", this.nsp);
        this.packet({
          type: socket_io_parser_1.PacketType.DISCONNECT
        });
      }
      // remove socket from pool
      this.destroy();
      if (this.connected) {
        // fire events
        this.onclose("io client disconnect");
      }
      return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */
  }, {
    key: "close",
    value: function close() {
      return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
  }, {
    key: "compress",
    value: function compress(_compress) {
      this.flags.compress = _compress;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */
  }, {
    key: "volatile",
    get: function get() {
      this.flags["volatile"] = true;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */
  }, {
    key: "timeout",
    value: function timeout(_timeout) {
      this.flags.timeout = _timeout;
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */
  }, {
    key: "onAny",
    value: function onAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.push(listener);
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */
  }, {
    key: "prependAny",
    value: function prependAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.unshift(listener);
      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */
  }, {
    key: "offAny",
    value: function offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }
      if (listener) {
        var listeners = this._anyListeners;
        for (var i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }
      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
  }, {
    key: "listenersAny",
    value: function listenersAny() {
      return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
  }, {
    key: "onAnyOutgoing",
    value: function onAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.push(listener);
      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
  }, {
    key: "prependAnyOutgoing",
    value: function prependAnyOutgoing(listener) {
      this._anyOutgoingListeners = this._anyOutgoingListeners || [];
      this._anyOutgoingListeners.unshift(listener);
      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */
  }, {
    key: "offAnyOutgoing",
    value: function offAnyOutgoing(listener) {
      if (!this._anyOutgoingListeners) {
        return this;
      }
      if (listener) {
        var listeners = this._anyOutgoingListeners;
        for (var i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyOutgoingListeners = [];
      }
      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
  }, {
    key: "listenersAnyOutgoing",
    value: function listenersAnyOutgoing() {
      return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */
  }, {
    key: "notifyOutgoingListeners",
    value: function notifyOutgoingListeners(packet) {
      if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
        var listeners = this._anyOutgoingListeners.slice();
        var _iterator2 = _createForOfIteratorHelper(listeners),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var listener = _step2.value;
            listener.apply(this, packet.data);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }
  }]);
}(component_emitter_1.Emitter);
exports.Socket = Socket;

},{"./on.js":159,"@socket.io/component-emitter":39,"debug":95,"socket.io-parser":163}],161:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.url = void 0;
var engine_io_client_1 = require("engine.io-client");
var debug_1 = __importDefault(require("debug")); // debug()
var debug = debug_1["default"]("socket.io-client:url"); // debug()
/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */
function url(uri) {
  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var loc = arguments.length > 2 ? arguments[2] : undefined;
  var obj = uri;
  // default to window.location
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri) uri = loc.protocol + "//" + loc.host;
  // relative path support
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug("protocol-less url %s", uri);
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    // parse
    debug("parse %s", uri);
    obj = engine_io_client_1.parse(uri);
  }
  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  var ipv6 = obj.host.indexOf(":") !== -1;
  var host = ipv6 ? "[" + obj.host + "]" : obj.host;
  // define unique id
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  // define href
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
exports.url = url;

},{"debug":95,"engine.io-client":102}],162:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reconstructPacket = exports.deconstructPacket = void 0;
var is_binary_js_1 = require("./is-binary.js");
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */
function deconstructPacket(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {
    packet: pack,
    buffers: buffers
  };
}
exports.deconstructPacket = deconstructPacket;
function _deconstructPacket(data, buffers) {
  if (!data) return data;
  if ((0, is_binary_js_1.isBinary)(data)) {
    var placeholder = {
      _placeholder: true,
      num: buffers.length
    };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    var newData = new Array(data.length);
    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (_typeof(data) === "object" && !(data instanceof Date)) {
    var _newData = {};
    for (var key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        _newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return _newData;
  }
  return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments; // no longer useful
  return packet;
}
exports.reconstructPacket = reconstructPacket;
function _reconstructPacket(data, buffers) {
  if (!data) return data;
  if (data && data._placeholder === true) {
    var isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num]; // appropriate buffer (should be natural order anyway)
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (_typeof(data) === "object") {
    for (var key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}

},{"./is-binary.js":164}],163:[function(require,module,exports){
"use strict";

function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
var component_emitter_1 = require("@socket.io/component-emitter");
var binary_js_1 = require("./binary.js");
var is_binary_js_1 = require("./is-binary.js");
var debug_1 = require("debug"); // debug()
var debug = (0, debug_1["default"])("socket.io-parser"); // debug()
/**
 * These strings must not be used as event names, as they have a special meaning.
 */
var RESERVED_EVENTS = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener" // used by the Node.js EventEmitter
];
/**
 * Protocol version.
 *
 * @public
 */
exports.protocol = 5;
var PacketType;
(function (PacketType) {
  PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
  PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType[PacketType["EVENT"] = 2] = "EVENT";
  PacketType[PacketType["ACK"] = 3] = "ACK";
  PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType = exports.PacketType || (exports.PacketType = {}));
/**
 * A socket.io Encoder instance
 */
var Encoder = /*#__PURE__*/function () {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  function Encoder(replacer) {
    _classCallCheck(this, Encoder);
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  return _createClass(Encoder, [{
    key: "encode",
    value: function encode(obj) {
      debug("encoding packet %j", obj);
      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if ((0, is_binary_js_1.hasBinary)(obj)) {
          return this.encodeAsBinary({
            type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
            nsp: obj.nsp,
            data: obj.data,
            id: obj.id
          });
        }
      }
      return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
  }, {
    key: "encodeAsString",
    value: function encodeAsString(obj) {
      // first is type
      var str = "" + obj.type;
      // attachments if we have them
      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str += obj.attachments + "-";
      }
      // if we have a namespace other than `/`
      // we append it followed by a comma `,`
      if (obj.nsp && "/" !== obj.nsp) {
        str += obj.nsp + ",";
      }
      // immediately followed by the id
      if (null != obj.id) {
        str += obj.id;
      }
      // json data
      if (null != obj.data) {
        str += JSON.stringify(obj.data, this.replacer);
      }
      debug("encoded %j as %s", obj, str);
      return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
  }, {
    key: "encodeAsBinary",
    value: function encodeAsBinary(obj) {
      var deconstruction = (0, binary_js_1.deconstructPacket)(obj);
      var pack = this.encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;
      buffers.unshift(pack); // add packet info to beginning of data list
      return buffers; // write all the buffers
    }
  }]);
}();
exports.Encoder = Encoder;
// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
function isObject(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */
var Decoder = /*#__PURE__*/function (_component_emitter_1$) {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  function Decoder(reviver) {
    var _this;
    _classCallCheck(this, Decoder);
    _this = _callSuper(this, Decoder);
    _this.reviver = reviver;
    return _this;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  _inherits(Decoder, _component_emitter_1$);
  return _createClass(Decoder, [{
    key: "add",
    value: function add(obj) {
      var packet;
      if (typeof obj === "string") {
        if (this.reconstructor) {
          throw new Error("got plaintext data when reconstructing a packet");
        }
        packet = this.decodeString(obj);
        var isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
        if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
          packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
          // binary packet's json
          this.reconstructor = new BinaryReconstructor(packet);
          // no attachments, labeled binary but no binary data to follow
          if (packet.attachments === 0) {
            _get(_getPrototypeOf(Decoder.prototype), "emitReserved", this).call(this, "decoded", packet);
          }
        } else {
          // non-binary full packet
          _get(_getPrototypeOf(Decoder.prototype), "emitReserved", this).call(this, "decoded", packet);
        }
      } else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) {
        // raw binary data
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            // received final buffer
            this.reconstructor = null;
            _get(_getPrototypeOf(Decoder.prototype), "emitReserved", this).call(this, "decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
  }, {
    key: "decodeString",
    value: function decodeString(str) {
      var i = 0;
      // look up type
      var p = {
        type: Number(str.charAt(0))
      };
      if (PacketType[p.type] === undefined) {
        throw new Error("unknown packet type " + p.type);
      }
      // look up attachments if type binary
      if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
        var start = i + 1;
        while (str.charAt(++i) !== "-" && i != str.length) {}
        var buf = str.substring(start, i);
        if (buf != Number(buf) || str.charAt(i) !== "-") {
          throw new Error("Illegal attachments");
        }
        p.attachments = Number(buf);
      }
      // look up namespace (if any)
      if ("/" === str.charAt(i + 1)) {
        var _start = i + 1;
        while (++i) {
          var c = str.charAt(i);
          if ("," === c) break;
          if (i === str.length) break;
        }
        p.nsp = str.substring(_start, i);
      } else {
        p.nsp = "/";
      }
      // look up id
      var next = str.charAt(i + 1);
      if ("" !== next && Number(next) == next) {
        var _start2 = i + 1;
        while (++i) {
          var _c = str.charAt(i);
          if (null == _c || Number(_c) != _c) {
            --i;
            break;
          }
          if (i === str.length) break;
        }
        p.id = Number(str.substring(_start2, i + 1));
      }
      // look up json data
      if (str.charAt(++i)) {
        var payload = this.tryParse(str.substr(i));
        if (Decoder.isPayloadValid(p.type, payload)) {
          p.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }
      debug("decoded %s as %j", str, p);
      return p;
    }
  }, {
    key: "tryParse",
    value: function tryParse(str) {
      try {
        return JSON.parse(str, this.reviver);
      } catch (e) {
        return false;
      }
    }
  }, {
    key: "destroy",
    value:
    /**
     * Deallocates a parser's resources
     */
    function destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
        this.reconstructor = null;
      }
    }
  }], [{
    key: "isPayloadValid",
    value: function isPayloadValid(type, payload) {
      switch (type) {
        case PacketType.CONNECT:
          return isObject(payload);
        case PacketType.DISCONNECT:
          return payload === undefined;
        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || isObject(payload);
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
  }]);
}(component_emitter_1.Emitter);
exports.Decoder = Decoder;
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */
var BinaryReconstructor = /*#__PURE__*/function () {
  function BinaryReconstructor(packet) {
    _classCallCheck(this, BinaryReconstructor);
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  return _createClass(BinaryReconstructor, [{
    key: "takeBinaryData",
    value: function takeBinaryData(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) {
        // done with buffer list
        var packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
  }, {
    key: "finishedReconstruction",
    value: function finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  }]);
}();

},{"./binary.js":162,"./is-binary.js":164,"@socket.io/component-emitter":39,"debug":95}],164:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasBinary = exports.isBinary = void 0;
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
exports.isBinary = isBinary;
function hasBinary(obj, toJSON) {
  if (!obj || _typeof(obj) !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
exports.hasBinary = hasBinary;

},{}]},{},[6])(6)
});
